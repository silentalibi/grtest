<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Halation Editor - Final</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            overscroll-behavior: none;
            touch-action: none;
            overflow: hidden;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #000; color: #fff; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility; }

        .app-container {
            display: flex;
            flex-direction: column;
            height: var(--app-height, 100vh);
            background: #000;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        .image-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            transition: background-color 0.5s ease;
        }
        .image-loading-overlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.9); opacity: 0; pointer-events: none; transition: opacity 0.2s ease; z-index: 20; }
        .image-loading-overlay.active { opacity: 1; pointer-events: auto; }
        .loading-overlay-content { display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .loading-spinner { width: 32px; height: 32px; border-radius: 50%; border: 3px solid rgba(255, 255, 255, 0.25); border-top-color: #fff; animation: loading-spin 1s linear infinite; }
        .loading-text { font-size: 14px; letter-spacing: 0.08em; text-transform: uppercase; color: #fff; }
        @keyframes loading-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .bottom-ui { position: relative; z-index: 1000; flex-shrink: 0; }
        .main-controls {
            position: relative;
            z-index: 2;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: calc(35px + env(safe-area-inset-bottom));
        }
        .slider-panel { position: absolute; bottom: var(--controls-height, 85px); left: 0; right: 0; width: 100%; max-width: 1280px; margin: 0 auto; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); z-index: 1; overflow: hidden; max-height: 0; padding-left: 20px; padding-right: 20px; padding-top: 0; padding-bottom: 0; opacity: 0; transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease; }
        .slider-panel.active { max-height: 40vh; padding-top: 20px; padding-bottom: 20px; opacity: 1; overflow-y: auto; }

        /* New Top Toolbar Styles */
        .top-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-top: calc(10px + env(safe-area-inset-top));
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            flex-shrink: 0; /* Prevent shrinking */
            z-index: 1000;
        }

        /* Top drop-down panel (mirrors bottom slider panels, opens downward) */
        .top-slider-panel { position: absolute; top: var(--topbar-height, 64px); left: 0; right: 0; width: 100%; max-width: 1280px; margin: 0 auto; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); z-index: 1100; overflow: hidden; max-height: 0; padding-left: 20px; padding-right: 20px; padding-top: 0; padding-bottom: 0; opacity: 0; transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .top-slider-panel.active { max-height: 80px; padding-top: 12px; padding-bottom: 12px; opacity: 1; overflow-x: auto; overflow-y: hidden; }
        .top-slider-panel .slider-row { flex-wrap: nowrap; align-items: center; }
        .top-slider-panel .slider-item { min-width: unset; flex: 0 0 auto; }
        .top-slider-panel .engine-buttons { flex-wrap: nowrap; }
        .engine-btn.disabled { opacity: 0.4; pointer-events: none; }

        .frame-btn { background: #000; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 25px; width: 44px; height: 44px; padding: 10px; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; position: relative; pointer-events: all; }
        .frame-btn:hover { background: rgba(255, 255, 255, 0.1); }
        .frame-btn .icon-frame { display: block; width: 100%; height: 100%; background-color: rgba(255,255,255,0.7); -webkit-mask-image: url('./assets/icons/frame.png'); mask-image: url('./assets/icons/frame.png'); -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; -webkit-mask-position: center; mask-position: center; -webkit-mask-size: contain; mask-size: contain; }
        .image-wrapper { position: absolute; left: 50%; top: 50%; transform-origin: center center; transition: none; }
        .app-container.image-loaded.drop-shadow-enabled .image-wrapper { filter: drop-shadow(0 0 15px rgba(0,0,0,0.3)); }
        .image-wrapper.animating { transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        canvas { display: block; border-radius: 8px; cursor: grab; image-rendering: crisp-edges; image-rendering: -webkit-crisp-edges; opacity: 0; transition: opacity 0.5s ease; }
        .app-container.image-loaded canvas { opacity: 1; }
        canvas.grabbing { cursor: grabbing; }

        .initial-logo-container { position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: opacity 0.5s ease; }
        .initial-logo-container img { width: 50%; max-width: 300px; height: auto; }
        .app-container.image-loaded .initial-logo-container { opacity: 0; pointer-events: none; }

        .zoom-indicator { position: absolute; bottom: 20px; right: 20px; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 8px 16px; border-radius: 20px; font-size: 14px; z-index: 999; opacity: 0; transition: opacity 0.3s ease, bottom 0.3s ease; }
        .zoom-indicator.visible { opacity: 1; }
        .slider-row { display: flex; gap: 20px; margin-bottom: 15px; flex-wrap: wrap; }
        .slider-row:last-child { margin-bottom: 0; }
        .slider-item { flex: 1; min-width: 120px; cursor: ew-resize; }
        .slider-item.hidden { display: none; }
        .slider-label { font-size: 12px; color: #ccc; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
        .slider-value { color: #fff; font-weight: 500; }
        input[type="range"] { width: 100%; height: 4px; background: rgba(255, 255, 255, 0.2); border-radius: 2px; outline: none; -webkit-appearance: none; pointer-events: none; }
        /* Only enable range interactions when the container is visible/active */
        .slider-panel.active input[type="range"],
        .settings-menu input[type="range"],
        .film-stock-menu-overlay.visible input[type="range"],
        .presets-menu-overlay.visible input[type="range"],
        .modal-overlay.visible input[type="range"] {
            pointer-events: auto;
        }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #fff; border-radius: 50%; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #fff; border-radius: 50%; border: none; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); }
        .main-controls { display: flex; justify-content: center; padding: 20px; gap: 15px; overflow-x: auto; max-width: 1280px; margin: 0 auto; width: 100%; }
        .main-controls::-webkit-scrollbar { display: none; }
        .main-btn { background: rgba(255, 255, 255, 0.1); border: none; color: #fff; padding: 10px 20px; border-radius: 12px; font-size: 12px; cursor: pointer; min-width: 80px; text-align: center; transition: all 0.3s ease; white-space: nowrap; flex-shrink: 0; }
        .main-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .main-btn.active { background: #444; }
        .file-input { display: none; }
        .panel-toggle-btn { display: block; width: 100%; margin-bottom: 20px; text-align: center; }
        .panel-toggle-btn.active { background: #fff; color: #000; }
        .slider-panel .panel-toggle-btn { padding-top: 8px; padding-bottom: 8px; }
        .styled-select { width: 100%; padding: 8px 12px; background: rgba(255, 255, 255, 0.2); color: #fff; border: none; border-radius: 4px; font-size: 14px; cursor: pointer; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23cccccc%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 12px top 50%; background-size: .6em auto; }
        .styled-select:focus { outline: 1px solid rgba(255,255,255,0.5); outline-offset: -1px; }
        .slider-item .slider-label { line-height: 1.2; }
        .top-bar-left-controls, .top-bar-right-controls { pointer-events: all; width: 44px; display: flex; justify-content: center; align-items: center; }
        .engine-buttons { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
        .engine-btn { flex: 0 0 auto; min-width: 60px; text-align: center; background: rgba(255, 255, 255, 0.1); border: 1px solid transparent; color: #fff; border-radius: 16px; padding: 6px 10px; font-size: 12px; cursor: pointer; transition: all 0.2s ease; }
        .engine-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .engine-btn.selected { background: #FFC107; color: #000; font-weight: 500; }
        .engine-btn.round { border-radius: 50%; width: 36px; height: 36px; min-width: 36px; padding: 0; display: flex; align-items: center; justify-content: center; font-weight: 500; }
        .selector-group { display: flex; align-items: center; gap: 12px; }
        .selector-label { font-size: 12px; color: #ccc; margin-right: 4px; }
        .film-stock-btn { background: #FFC107; border: none; border-radius: 25px; width: 44px; height: 44px; padding: 10px; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; }
        .film-stock-btn:hover { background: #FFD54F; }
        .film-stock-btn .icon { display: block; width: 100%; height: 100%; background-size: contain; background-repeat: no-repeat; background-position: center; transition: opacity 0.2s ease, transform 0.2s ease; }
        .film-stock-btn .icon-filmroll { background-image: url(./assets/icons/filmroll.png); }
        .film-stock-btn .icon-close { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M18 6L6 18" stroke="%23000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/%3E%3Cpath d="M6 6L18 18" stroke="%23000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/%3E%3C/svg%3E'); opacity: 0; transform: scale(0.5); position: absolute; }
        .film-stock-btn.menu-open .icon-filmroll { opacity: 0; transform: scale(0.5); }
        .film-stock-btn.menu-open .icon-close { opacity: 1; transform: scale(1); }
        .film-stock-menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .film-stock-menu-overlay.visible { opacity: 1; pointer-events: all; }
        .film-stock-menu {
            position: absolute;
            left: 20px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            width: auto;
            max-width: 320px;
            transform-origin: top left;
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .film-stock-menu-overlay.visible .film-stock-menu { transform: scale(1); }

        .settings-btn, .presets-btn { background: #000; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 25px; width: 44px; height: 44px; padding: 10px; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; position: relative; pointer-events: all; }
        .settings-btn:hover, .presets-btn:hover { background: rgba(255, 255, 255, 0.1); }
        .settings-btn .icon, .presets-btn .icon { display: block; width: 100%; height: 100%; background-size: contain; background-repeat: no-repeat; background-position: center; transition: opacity 0.2s ease, transform 0.2s ease; }
        .settings-btn .icon-settings { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Ccircle cx="12" cy="12" r="1.5" fill="white"/%3E%3Ccircle cx="6" cy="12" r="1.5" fill="white"/%3E%3Ccircle cx="18" cy="12" r="1.5" fill="white"/%3E%3C/svg%3E'); }
        .presets-btn .icon-presets { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M4 6h16M4 12h16M4 18h16" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/%3E%3C/svg%3E'); }
        .settings-btn .icon-close, .presets-btn .icon-close { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M18 6L6 18" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/%3E%3Cpath d="M6 6L18 18" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/%3E%3C/svg%3E'); opacity: 0; transform: scale(0.5); position: absolute; }
        .settings-btn.menu-open .icon-settings, .presets-btn.menu-open .icon-presets { opacity: 0; transform: scale(0.5); }
        .settings-btn.menu-open .icon-close, .presets-btn.menu-open .icon-close { opacity: 1; transform: scale(1); }
        .settings-menu-overlay, .presets-menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; visibility: hidden; }
        .settings-menu-overlay.visible, .presets-menu-overlay.visible { opacity: 1; pointer-events: all; visibility: visible; }
        .settings-menu { position: fixed; left: 50%; top: 50%; background: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 12px; padding: 20px; width: 75vw; height: 50vh; max-width: none; transform: translate(-50%, -50%) scale(0.95); transform-origin: center center; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); overflow-y: auto; }
        .presets-menu { position: absolute; right: 75px; background: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 12px; padding: 15px; width: auto; min-width: 280px; max-width: 320px; transform-origin: top right; transform: scale(0.95); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-menu-overlay.visible .settings-menu, .presets-menu-overlay.visible .presets-menu { transform: translate(-50%, -50%) scale(1); }
        .presets-menu-overlay.visible .presets-menu { transform: scale(1); }
        .settings-menu input[type="range"] { pointer-events: auto; }
        .settings-menu .slider-label { margin-bottom: 10px; font-size: 11px; }
        .color-picker-wrapper { display: flex; align-items: center; gap: 10px; }
        input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 44px; height: 28px; background: none; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; cursor: pointer; padding: 0; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 3px; }

        .toggle-switch { display: flex; align-items: center; justify-content: space-between; cursor: pointer; width: 100%;}
        .toggle-switch .slider-label { margin-bottom: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-switch .switch { position: relative; display: inline-block; width: 40px; height: 22px; background-color: rgba(255,255,255,0.2); border-radius: 22px; transition: background-color 0.2s; }
        .toggle-switch .switch::before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; top: 3px; background-color: white; border-radius: 50%; transition: transform 0.2s; }
        .toggle-switch input:checked + .switch { background-color: #FFC107; }
        .toggle-switch input:checked + .switch::before { transform: translateX(18px); }
        .panel-toggle-container { margin-bottom: 20px; }

        .gauge-slider-container { margin-bottom: 20px; cursor: ew-resize; }
        .gauge-slider-container .slider-label { font-size: 14px; }
        .gauge-slider { position: relative; padding-bottom: 15px; }
        .gauge-slider-labels { display: flex; justify-content: space-between; font-size: 12px; color: #999; padding: 0 5px; }
        .film-stock-grid { display: flex; flex-direction: column; gap: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .film-stock-grid-row { display: flex; align-items: center; gap: 10px; }
        .film-stock-grid-icon { width: 24px; height: 24px; background-size: contain; background-repeat: no-repeat; background-position: center; }
        .icon-grid-filmroll { background-image: url(./assets/icons/filmroll.png); }
        .icon-grid-movie { background-image: url(./assets/icons/movie.png); }
        .film-stock-buttons { display: flex; gap: 10px; flex: 1; }
        .stock-btn { flex: 1; min-width: 60px; text-align: center; background: rgba(255, 255, 255, 0.1); border: 1px solid transparent; color: #fff; border-radius: 20px; padding: 8px 12px; font-size: 14px; cursor: pointer; transition: all 0.2s ease; }
        .stock-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .stock-btn.selected { background: #FFC107; color: #000; font-weight: 500; }
        .top-bar-center { position: relative; pointer-events: none; display: flex; align-items: center; gap: 10px; }
        .top-bar-center .frame-btn, .top-bar-center .presets-btn { pointer-events: all; }

        /* Preset Menu Styles */
        .presets-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .presets-header h3 { font-size: 16px; font-weight: 500; color: #ccc; }
        .add-preset-btn { background: rgba(255,255,255,0.15); border: none; border-radius: 8px; width: 30px; height: 30px; color: #fff; font-size: 20px; cursor: pointer; transition: background 0.2s; }
        .add-preset-btn:hover { background: rgba(255,255,255,0.3); }
        .presets-list { max-height: 40vh; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        .preset-item { display: flex; align-items: center; justify-content: space-between; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; transition: background 0.2s; }
        .preset-item:hover { background: rgba(255,255,255,0.15); }
        .preset-item-name { flex-grow: 1; font-size: 14px; }
        .preset-actions { display: flex; gap: 6px; }
        .icon-btn { width: 28px; height: 28px; border-radius: 50%; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.1); display:flex; align-items:center; justify-content:center; cursor: pointer; }
        .icon-btn:hover { background: rgba(255,255,255,0.25); }
        .icon-btn .icon { display:block; width: 16px; height: 16px; background-color: rgba(255,255,255,0.85); -webkit-mask-repeat:no-repeat; mask-repeat:no-repeat; -webkit-mask-position:center; mask-position:center; -webkit-mask-size:contain; mask-size:contain; }
        /* icon masks for generic icons */
        .icon-upload { -webkit-mask-image: url('./assets/icons/upload.png'); mask-image: url('./assets/icons/upload.png'); }
        .icon-batch { -webkit-mask-image: url('./assets/icons/batch.png'); mask-image: url('./assets/icons/batch.png'); }
        .icon-save { -webkit-mask-image: url('./assets/icons/save.png'); mask-image: url('./assets/icons/save.png'); }
        .icon-settings { -webkit-mask-image: url('./assets/icons/settings.png'); mask-image: url('./assets/icons/settings.png'); }
        .icon-edit { -webkit-mask-image: url('./assets/icons/edit.png'); mask-image: url('./assets/icons/edit.png'); }
        .icon-trash { -webkit-mask-image: url('./assets/icons/trash.png'); mask-image: url('./assets/icons/trash.png'); }

        /* top toolbar frame-btn icons */
        .frame-btn .icon { display:block; width: 24px; height: 24px; background-color: rgba(255,255,255,0.9); -webkit-mask-repeat:no-repeat; mask-repeat:no-repeat; -webkit-mask-position:center; mask-position:center; -webkit-mask-size:contain; mask-size:contain; }
        .preset-item-menu-btn { background: transparent; border: none; color: #ccc; cursor: pointer; padding: 5px; position: relative; }
        .preset-item-menu { display: none; position: absolute; right: 0; top: 25px; background: #333; border-radius: 8px; padding: 5px; z-index: 10; list-style: none; }
        .preset-item-menu.show { display: block; }
        .preset-item-menu li { padding: 8px 12px; cursor: pointer; }
        .preset-item-menu li:hover { background: #444; }

        /* Add/Edit Preset Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); z-index: 3000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal-overlay.visible { opacity: 1; pointer-events: all; }
        .modal-content { background: #1e1e1e; padding: 25px; border-radius: 16px; width: 90%; max-width: 400px; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-content h3 { margin-top: 0; margin-bottom: 15px; }
        .modal-content p { font-size: 14px; color: #ccc; margin-bottom: 20px; }
        .modal-input { width: 100%; padding: 10px; background: #333; border: 1px solid #444; border-radius: 8px; color: #fff; font-size: 16px; margin-bottom: 20px; }
        .preset-params-list { display: flex; flex-direction: column; gap: 12px; margin-bottom: 25px; max-height: 25vh; overflow-y: auto; padding-right: 10px; }
        .preset-param-item { display: flex; align-items: center; justify-content: space-between; }
        .preset-param-item label { font-size: 14px; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; }
        .modal-btn { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; }
        .modal-btn-primary { background: #FFC107; color: #000; }
        .modal-btn-secondary { background: #444; color: #fff; }

        @media (max-width: 768px) {
            .top-toolbar { padding: 10px 15px; padding-top: calc(10px + env(safe-area-inset-top)); }
            .top-btn { padding: 10px 16px; font-size: 12px; }
            .main-btn {
                min-width: 70px;
                padding: 19px 15px;
                font-size: 11px;
            }
            .slider-panel .panel-toggle-btn {
                padding: 12px 15px;
            }
            .main-controls {
                padding: 15px;
                padding-bottom: 35px;
                gap: 10px;
            }
            .slider-panel.active { max-height: calc(var(--panel-max-height, 250px) * 2); padding-left: 15px; padding-right: 15px; }
            .slider-row { display: block; margin-bottom: 0; }
            .slider-item { flex-basis: auto; width: 100%; min-width: unset; margin-bottom: 25px; }
            .slider-row:last-child .slider-item:last-child { margin-bottom: 0; }
            .film-stock-menu { left: 15px; }
            .settings-menu { right: 15px; }
            .presets-menu { right: 15px; left: 15px; width: auto; max-width: none; }
        }



.progress-indicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    color: white;
    padding: 20px 30px;
    border-radius: 12px;
    z-index: 10000;
    font-size: 16px;
    text-align: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
.progress-indicator.visible {
    opacity: 1;
}


    </style>
</head>
<body>
    <div class="app-container drop-shadow-enabled" id="appContainer">
        <!-- Top Toolbar structure -->
        <div class="top-toolbar" id="topToolbar">
            <div class="top-bar-left-controls">
                <button class="film-stock-btn" id="filmStockBtn">
                    <span class="icon icon-filmroll"></span>
                    <span class="icon icon-close"></span>
                </button>
            </div>
            <div class="top-bar-center">
                <button class="frame-btn" id="loadImageBtn" title="Load">
                    <span class="icon icon-upload"></span>
                </button>
                <button class="frame-btn" id="batchBtn" title="Batch">
                    <span class="icon icon-batch"></span>
                </button>
                <button class="frame-btn" id="frameBtn" style="display:none;">
                    <span class="icon-frame"></span>
                </button>
                <button class="presets-btn" id="presetsBtn">
                    <span class="icon icon-presets"></span>
                    <span class="icon icon-close"></span>
                </button>
                <!-- Canvas menu button -->
                <button class="frame-btn" id="canvasMenuBtn" title="Canvas">
                    <span class="icon icon-frame"></span>
                </button>
                <button class="frame-btn" id="settingsBtn" title="Settings">
                    <span class="icon icon-settings"></span>
                </button>
            </div>
            <div class="top-bar-right-controls">
                <button class="frame-btn" id="saveBtn" title="Save">
                    <span class="icon icon-save"></span>
                </button>
            </div>
        </div>

        <!-- Top drop-down panel for Canvas menu -->
        <div class="top-slider-panel" id="canvasPanel">
            <div class="slider-row" style="display:flex;align-items:center;gap:20px;">
                <div class="slider-item" style="display:flex;align-items:center;gap:10px;flex:0 1 auto;">
                    <div class="slider-label">Canvas shape</div>
                    <div class="engine-buttons" id="canvasShapeToggle" style="display:flex;gap:8px;">
                        <button class="engine-btn selected" data-shape="image">Image</button>
                        <button class="engine-btn" data-shape="border">Border</button>
                    </div>
                </div>
                <div class="slider-item" style="display:flex;align-items:center;gap:10px;flex:0 1 auto;overflow:hidden;">
                    <div class="engine-buttons" id="canvasAspectButtons" style="display:flex;gap:8px;overflow-x:auto;overflow-y:hidden;flex-wrap:nowrap;">
                        <button class="engine-btn round disabled" data-aspect="16:9">16:9</button>
                        <button class="engine-btn round disabled" data-aspect="5:3">5:3</button>
                        <button class="engine-btn round disabled" data-aspect="3:2">3:2</button>
                        <button class="engine-btn round disabled" data-aspect="7:5">7:5</button>
                        <button class="engine-btn round disabled" data-aspect="4:3">4:3</button>
                        <button class="engine-btn round disabled" data-aspect="5:4">5:4</button>
                        <button class="engine-btn round disabled" data-aspect="1:1">1:1</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="image-viewport" id="viewport">
            <div class="initial-logo-container">
                <img src="./assets/icons/logo.png" alt="Halation Editor Logo">
            </div>
            <div class="image-wrapper" id="imageWrapper">
                <canvas id="canvas"></canvas>
            </div>
            <div class="image-loading-overlay" id="imageLoadingOverlay" role="status" aria-live="polite" aria-hidden="true">
                <div class="loading-overlay-content">
                    <div class="loading-spinner" aria-hidden="true"></div>
                    <p class="loading-text">Loading image...</p>
                </div>
            </div>
            <div class="zoom-indicator" id="zoomIndicator"></div>
        </div>
        <div class="bottom-ui" id="bottomUI">
            <!-- Slider Panels -->
            <div class="slider-panel" id="halationPanel">
                <div class="panel-toggle-container">
                    <label class="toggle-switch">
                        <span class="slider-label">Halation</span>
                        <input type="checkbox" id="halationEnabledToggle" checked>
                        <span class="switch"></span>
                    </label>
                </div>

                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Whitepoint Compensation <span class="slider-value" id="whiteCompVal">0.00</span></div>
                        <input type="range" id="whiteCompSlider" min="0" max="1" step="0.01" value="0.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Limit <span class="slider-value" id="whiteCompLimitVal">0.80</span></div>
                        <input type="range" id="whiteCompLimit" min="0.4" max="1.0" step="0.01" value="0.8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Intensity <span class="slider-value" id="halationIntensityVal">1.00</span></div>
                        <input type="range" id="halationIntensity" min="0" max="2" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Whitepoint <span class="slider-value" id="whitepointVal">2.00</span></div>
                        <input type="range" id="whitepoint" min="1" max="5" step="0.01" value="2.0">
                    </div>
                </div>
                
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Blackpoint <span class="slider-value" id="blackpointVal">0.20</span></div>
                        <input type="range" id="blackpoint" min="0" max="1" step="0.01" value="0.2">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Threshold Gamma <span class="slider-value" id="thresholdGammaVal">0.70</span></div>
                        <input type="range" id="thresholdGamma" min="0" max="1" step="0.01" value="0.7">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Core Blur <span class="slider-value" id="coreBlurVal">3.0</span></div>
                        <input type="range" id="coreBlur" min="0" max="60" step="0.1" value="3.0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Mid Blur <span class="slider-value" id="midBlurVal">6.0</span></div>
                        <input type="range" id="midBlur" min="0" max="60" step="0.1" value="6.0">
                    </div>
                     <div class="slider-item">
                        <div class="slider-label">Outer Blur <span class="slider-value" id="outerBlurVal">20.0</span></div>
                        <input type="range" id="outerBlur" min="0" max="60" step="0.1" value="20.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item hidden"></div>
                    <div class="slider-item">
                        <div class="slider-label">Mid Gain <span class="slider-value" id="midBlurGainVal">0.90</span></div>
                        <input type="range" id="midBlurGain" min="0" max="2" step="0.01" value="0.9">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Outer Gain <span class="slider-value" id="outerBlurGainVal">0.60</span></div>
                        <input type="range" id="outerBlurGain" min="0" max="2" step="0.01" value="0.6">
                    </div>
                </div>
                 <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">R Tint <span class="slider-value" id="tintR2Val">1.00</span></div>
                        <input type="range" id="tintR2" min="0" max="3" step="0.01" value="1.0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">G Tint <span class="slider-value" id="tintG2Val">0.30</span></div>
                        <input type="range" id="tintG2" min="0" max="3" step="0.01" value="0.30">
                    </div>
                     <div class="slider-item">
                        <div class="slider-label">B Tint <span class="slider-value" id="tintB2Val">0.02</span></div>
                        <input type="range" id="tintB2" min="0" max="3" step="0.01" value="0.02">
                    </div>
                </div>
                
            </div>
            <!-- New Optics Panel -->
            <div class="slider-panel" id="opticsPanel">
                <div class="panel-toggle-container">
                    <label class="toggle-switch">
                        <span class="slider-label">Optics</span>
                        <input type="checkbox" checked disabled>
                        <span class="switch"></span>
                    </label>
                </div>
                <div class="slider-item" style="margin-bottom: 20px;">
                    <label class="toggle-switch">
                        <span class="slider-label">MTF in Linear</span>
                        <input type="checkbox" id="mtfLinearToggle" checked>
                        <span class="switch"></span>
                    </label>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">MTF Mask <span class="slider-value" id="mtfMaskVal">2.5</span></div>
                        <input type="range" id="mtfMask" min="0" max="20" step="0.1" value="2.5">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">MTF Softness <span class="slider-value" id="mtfSoftnessVal">9.0</span></div>
                        <input type="range" id="mtfSoftness" min="0" max="40" step="0.1" value="9.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Diffusion Threshold <span class="slider-value" id="diffusionThresholdVal">1.00</span></div>
                        <input type="range" id="diffusionThreshold" min="0" max="2" step="0.01" value="1.0">
                    </div>
                    <div class="slider-item" style="display:flex;align-items:center;">
                        <label class="toggle-switch">
                            <span class="slider-label">Preview</span>
                            <input type="checkbox" id="diffusionThresholdPreviewToggle" checked>
                            <span class="switch"></span>
                        </label>
                    </div>
                </div>
                <!-- Diffusion settings moved here -->
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Diffusion A Radius <span class="slider-value" id="diffusionRadiusVal">0.0</span></div>
                        <input type="range" id="diffusionRadius" min="0" max="1000" step="0.1" value="0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Diffusion A Strength <span class="slider-value" id="diffusionStrengthVal">0.00</span></div>
                        <input type="range" id="diffusionStrength" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Diffusion B Radius <span class="slider-value" id="diffusionRadiusBVal">0.0</span></div>
                        <input type="range" id="diffusionRadiusB" min="0" max="1000" step="0.1" value="0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Diffusion B Strength <span class="slider-value" id="diffusionStrengthBVal">0.00</span></div>
                        <input type="range" id="diffusionStrengthB" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Diffusion C Radius <span class="slider-value" id="diffusionRadiusCVal">0.0</span></div>
                        <input type="range" id="diffusionRadiusC" min="0" max="1000" step="0.1" value="0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Diffusion C Strength <span class="slider-value" id="diffusionStrengthCVal">0.00</span></div>
                        <input type="range" id="diffusionStrengthC" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Diffusion R Tint <span class="slider-value" id="diffusionTintRVal">1.00</span></div>
                        <input type="range" id="diffusionTintR" min="0" max="2" step="0.01" value="1.0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Diffusion G Tint <span class="slider-value" id="diffusionTintGVal">1.00</span></div>
                        <input type="range" id="diffusionTintG" min="0" max="2" step="0.01" value="1.0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Diffusion B Tint <span class="slider-value" id="diffusionTintBVal">1.00</span></div>
                        <input type="range" id="diffusionTintB" min="0" max="2" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" style="width:100%">
                        <div class="slider-label">Diffusion Spread <span class="slider-value" id="diffusionSpreadVal">1.00</span></div>
                        <input type="range" id="diffusionSpread" min="0" max="1" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" style="width:100%">
                        <div class="slider-label">Diffusion Gamma <span class="slider-value" id="diffusionGammaVal">1.00</span></div>
                        <input type="range" id="diffusionGamma" min="0" max="2" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" style="width:100%">
                        <div class="slider-label">Diffusion Intensity <span class="slider-value" id="diffusionIntensityVal">0.00</span></div>
                        <input type="range" id="diffusionIntensity" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
                <div class="panel-toggle-container" style="margin-top: 20px;">
                    <label class="toggle-switch">
                        <span class="slider-label">Subtract Source</span>
                        <input type="checkbox" id="diffusionSubtractToggle">
                        <span class="switch"></span>
                    </label>
                </div>
                
                <!-- Diffusion DEF Section -->
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="text-align: center; margin-bottom: 15px; color: #ccc; font-size: 14px;">Diffusion 02</div>
                    <div class="slider-row">
                        <div class="slider-item">
                        <div class="slider-label">D Radius <span class="slider-value" id="diffusionRadiusDVal">5.0</span></div>
                            <input type="range" id="diffusionRadiusD" min="0" max="1000" step="0.1" value="5.0">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">D Strength <span class="slider-value" id="diffusionStrengthDVal">0.20</span></div>
                            <input type="range" id="diffusionStrengthD" min="0" max="1" step="0.01" value="0.2">
                        </div>
                    </div>
                    <div class="slider-row">
                        <div class="slider-item">
                            <div class="slider-label">E Radius <span class="slider-value" id="diffusionRadiusEVal">10.0</span></div>
                            <input type="range" id="diffusionRadiusE" min="0" max="1000" step="0.1" value="10.0">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">E Strength <span class="slider-value" id="diffusionStrengthEVal">0.15</span></div>
                            <input type="range" id="diffusionStrengthE" min="0" max="1" step="0.01" value="0.15">
                        </div>
                    </div>
                    <div class="slider-row">
                        <div class="slider-item">
                            <div class="slider-label">F Radius <span class="slider-value" id="diffusionRadiusFVal">20.0</span></div>
                            <input type="range" id="diffusionRadiusF" min="0" max="1000" step="0.1" value="20.0">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">F Strength <span class="slider-value" id="diffusionStrengthFVal">0.10</span></div>
                            <input type="range" id="diffusionStrengthF" min="0" max="1" step="0.01" value="0.1">
                        </div>
                    </div>
                    <div class="slider-row">
                        <div class="slider-item">
                            <div class="slider-label">Diffusion 02 Tint R <span class="slider-value" id="diffusionTint2RVal">1.00</span></div>
                            <input type="range" id="diffusionTint2R" min="0" max="2" step="0.01" value="1.0">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">Diffusion 02 Tint G <span class="slider-value" id="diffusionTint2GVal">0.85</span></div>
                            <input type="range" id="diffusionTint2G" min="0" max="2" step="0.01" value="0.85">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">Diffusion 02 Tint B <span class="slider-value" id="diffusionTint2BVal">0.70</span></div>
                            <input type="range" id="diffusionTint2B" min="0" max="2" step="0.01" value="0.7">
                        </div>
                    </div>
                    <div class="slider-row">
                        <div class="slider-item">
                            <div class="slider-label">Diffusion 02 Spread <span class="slider-value" id="diffusionSpread2Val">0.50</span></div>
                            <input type="range" id="diffusionSpread2" min="0" max="1" step="0.01" value="0.5">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">Diffusion 02 Gamma <span class="slider-value" id="diffusionGamma2Val">1.00</span></div>
                            <input type="range" id="diffusionGamma2" min="0.1" max="3" step="0.01" value="1.0">
                        </div>
                    </div>
                    <div class="slider-row">
                        <div class="slider-item">
                            <div class="slider-label">Diffusion 02 Intensity <span class="slider-value" id="diffusionIntensity2Val">0.00</span></div>
                            <input type="range" id="diffusionIntensity2" min="0" max="1" step="0.01" value="0">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">Diffusion 02 Threshold <span class="slider-value" id="diffusionThreshold2Val">1.00</span></div>
                            <input type="range" id="diffusionThreshold2" min="0.1" max="3" step="0.01" value="1.0">
                        </div>
                    </div>
                    <div class="slider-row">
                        <div class="slider-item">
                            <div class="slider-label">Threshold Gamma <span class="slider-value" id="thresholdGamma2Val">1.00</span></div>
                            <input type="range" id="thresholdGamma2" min="0" max="1" step="0.01" value="1.0">
                        </div>
                        <div class="slider-item">
                            <div class="slider-label">Threshold White <span class="slider-value" id="thresholdWhite2Val">7.22</span></div>
                            <input type="range" id="thresholdWhite2" min="1" max="7.22" step="0.01" value="7.22">
                        </div>
                    </div>
                    <div class="panel-toggle-container" style="margin-top: 15px;">
                        <label class="toggle-switch">
                            <span class="slider-label">Diffusion 02 Threshold Preview</span>
                            <input type="checkbox" id="diffusionThresholdPreview2Toggle">
                            <span class="switch"></span>
                        </label>
                    </div>
                    <div class="panel-toggle-container">
                        <label class="toggle-switch">
                            <span class="slider-label">Subtract Source 02</span>
                            <input type="checkbox" id="diffusionSubtract2Toggle">
                            <span class="switch"></span>
                        </label>
                    </div>
                    <div class="panel-toggle-container">
                        <label class="toggle-switch">
                            <span class="slider-label">Min RGB</span>
                            <input type="checkbox" id="diffusionMinRgbToggle" checked>
                            <span class="switch"></span>
                        </label>
                    </div>
                    <div class="panel-toggle-container">
                        <label class="toggle-switch">
                            <span class="slider-label">Premultiply</span>
                            <input type="checkbox" id="diffusionPremultiplyToggle" checked>
                            <span class="switch"></span>
                        </label>
                    </div>
                    <div class="panel-toggle-container">
                        <label class="toggle-switch">
                            <span class="slider-label">Screen</span>
                            <input type="checkbox" id="halationScreenToggle">
                            <span class="switch"></span>
                        </label>
                    </div>
                </div>
                <!-- Chroma Ab section (pre-baked) -->
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                  <div style="text-align: center; margin-bottom: 8px; color: #ccc; font-size: 14px;">Chroma Ab</div>
                  <div class="panel-toggle-container" style="margin-bottom: 12px;">
                    <label class="toggle-switch">
                      <span class="slider-label">Enable Chroma Ab</span>
                      <input type="checkbox" id="chromaToggle" checked>
                      <span class="switch"></span>
                    </label>
                  </div>
                  <div class="slider-row">
                    <div class="slider-item">
                      <div class="slider-label">Samples <span class="slider-value" id="chromaSamplesVal">5</span></div>
                      <input type="range" id="chromaSamples" min="0" max="50" step="1" value="5">
                    </div>
                    <div class="slider-item">
                      <div class="slider-label">Blur <span class="slider-value" id="chromaBlurVal">0.010</span></div>
                      <input type="range" id="chromaBlur" min="0" max="0.1" step="0.001" value="0.01">
                    </div>
                  </div>
                  <div class="slider-row">
                    <div class="slider-item" style="width:100%">
                      <div class="slider-label">Falloff <span class="slider-value" id="chromaFalloffVal">1.00</span></div>
                      <input type="range" id="chromaFalloff" min="0.1" max="4" step="0.01" value="1">
                    </div>
                  </div>
                </div>
            </div>
            <div class="slider-panel" id="texturePanel">
                <div class="panel-toggle-container">
                     <label class="toggle-switch">
                        <span class="slider-label">Texture</span>
                        <input type="checkbox" id="textureEnabledToggle" checked>
                        <span class="switch"></span>
                    </label>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Stock</div>
                        <select id="grainStockSelect" class="styled-select">
                            <option value="35mm P400">35mm P400</option>
                            <option value="35mm P800">35mm P800</option>
                            <option value="35mm 250D">35mm 250D</option>
                            <option value="35mm 500T">35mm 500T</option>
                            <option value="16mm 500T">16mm 500T</option>
                        </select>
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Grain Scale <span class="slider-value" id="grainScaleVal">1.00</span></div>
                        <input type="range" id="grainScale" min="0.5" max="2" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Grain Intensity <span class="slider-value" id="grainIntensityVal">0.60</span></div>
                        <input type="range" id="grainIntensity" min="0" max="1" step="0.01" value="0.6">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Grain Saturation <span class="slider-value" id="grainSaturationVal">1.00</span></div>
                        <input type="range" id="grainSaturation" min="0" max="2" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Reduce Shadows <span class="slider-value" id="grainReduceShadowsVal">0.00</span></div>
                        <input type="range" id="grainReduceShadows" min="0" max="1" step="0.01" value="0.0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Shadow Sat <span class="slider-value" id="grainShadowSatVal">1.00</span></div>
                        <input type="range" id="grainShadowSat" min="0" max="1" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Reduce Highlights <span class="slider-value" id="grainReduceHighlightsVal">0.00</span></div>
                        <input type="range" id="grainReduceHighlights" min="0" max="1" step="0.01" value="0.0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">Highlight Sat <span class="slider-value" id="grainHighlightSatVal">1.00</span></div>
                        <input type="range" id="grainHighlightSat" min="0" max="1" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">High Pass Radius <span class="slider-value" id="highPassRadiusVal">30.0</span></div>
                        <input type="range" id="highPassRadius" min="0" max="200" step="0.1" value="30.0">
                    </div>
                    <div class="slider-item">
                        <div class="slider-label">High Pass Opacity <span class="slider-value" id="highPassOpacityVal">0.10</span></div>
                        <input type="range" id="highPassOpacity" min="0" max="1" step="0.01" value="0.1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item"><div class="slider-label">Return Min Value</div><button class="main-btn panel-toggle-btn" id="returnMinBtn">Return Min</button></div>
                </div>
                <div class="slider-row">
                    <div class="slider-item"><div class="slider-label">Return Max Value</div><button class="main-btn panel-toggle-btn" id="returnMaxBtn">Return Max</button></div>
                </div>
                <div class="slider-row">
                    <div class="slider-item"><div class="slider-label">Return Max Source</div><button class="main-btn panel-toggle-btn" id="returnMaxSourceBtn">Return Max Source</button></div>
                </div>
            </div>
            <div class="slider-panel" id="borderPanel">
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Border engine</div>
                        <div class="engine-buttons" id="borderEngineButtons">
                            <button class="engine-btn" data-engine="8mm">8mm</button>
                            <button class="engine-btn" data-engine="16mm">16mm</button>
                            <button class="engine-btn" data-engine="35mm-178">35mm 1.78</button>
                            <button class="engine-btn" data-engine="35mm-240">35mm 2.40</button>
                            <button class="engine-btn" data-engine="35mm-133">35mm 1.33</button>
                            <button class="engine-btn selected" data-engine="35mm-add">35mm Stills</button>
                            <button class="engine-btn" data-engine="medium-format">Medium Format</button>
                        </div>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" id="overscanSliderItem">
                        <div class="slider-label">Overscan <span class="slider-value" id="overscanVal">0.00</span></div>
                        <input type="range" id="overscan" min="0" max="1" step="0.001" value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" id="framingSliderItem">
                        <div class="slider-label">Framing <span class="slider-value" id="framingVal">1.00</span></div>
                        <input type="range" id="framing" min="0" max="2" step="0.001" value="1">
                    </div>
                </div>
                <div class="slider-row" id="sprocket8mmRow" style="display:none;">
                    <div class="slider-item">
                        <div class="engine-buttons" style="display: flex; gap: 20px; margin-top: 0;">
                            <div class="selector-group">
                                <span class="selector-label">Sprocket</span>
                                <div id="sprocket8mmButtons" style="display: flex; gap: 8px;">
                                    <button class="engine-btn round selected" data-sprocket="A">1</button>
                                    <button class="engine-btn round" data-sprocket="B">2</button>
                    </div>
                            </div>
                            <div class="selector-group">
                                <span class="selector-label">Border</span>
                                <div id="border8mmButtons" style="display: flex; gap: 8px;">
                                    <button class="engine-btn round selected" data-border="A">1</button>
                                    <button class="engine-btn round" data-border="B">2</button>
                                    <button class="engine-btn round" data-border="C">3</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="sprocket16mmRow" style="display:none;">
                    <div class="slider-item">
                        <div class="engine-buttons" style="display: flex; gap: 20px; margin-top: 0;">
                            <div class="selector-group">
                                <span class="selector-label">Sprocket</span>
                                <div id="sprocket16mmButtons" style="display: flex; gap: 8px;">
                                    <button class="engine-btn round selected" data-sprocket="A">1</button>
                                    <button class="engine-btn round" data-sprocket="B">2</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="border16mmRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Border</div>
                        <div class="engine-buttons" id="border16mmButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="engine-btn round selected" data-border="A">1</button>
                            <button class="engine-btn round" data-border="B">2</button>
                            <button class="engine-btn round" data-border="C">3</button>
                            <button class="engine-btn round" data-border="D">4</button>
                            <button class="engine-btn round" data-border="E">5</button>
                            <button class="engine-btn round" data-border="F">6</button>
                            <button class="engine-btn round" data-border="G">7</button>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="sprocket16mmScaleSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Scale <span class="slider-value" id="sprocket16mmScaleVal">1.00</span></div>
                        <input type="range" id="sprocket16mmScale" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <!-- 35mm 1.78 engine UI -->
                <div class="slider-row" id="sprocket35mm178Row" style="display:none;">
                    <div class="slider-item">
                        <div class="engine-buttons" style="display: flex; gap: 20px; margin-top: 0;">
                            <div class="selector-group">
                                <span class="selector-label">Sprocket</span>
                                <div id="sprocket35mm178Buttons" style="display: flex; gap: 8px;">
                                    <button class="engine-btn round selected" data-sprocket="A">1</button>
                                    <button class="engine-btn round" data-sprocket="B">2</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="border35mm178Row" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Border</div>
                        <div class="engine-buttons" id="border35mm178Buttons" style="display: flex; gap: 8px;">
                            <button class="engine-btn round selected" data-border="A">1</button>
                            <button class="engine-btn round" data-border="B">2</button>
                            <button class="engine-btn round" data-border="C">3</button>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="sprocket35mm178ScaleSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Scale <span class="slider-value" id="sprocket35mm178ScaleVal">1.00</span></div>
                        <input type="range" id="sprocket35mm178Scale" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row" id="sprocket35mm178TranslationSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Translation <span class="slider-value" id="sprocket35mm178TranslationVal">1.00</span></div>
                        <input type="range" id="sprocket35mm178Translation" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <!-- 35mm 2.40 engine UI -->
                <div class="slider-row" id="sprocket35mm240Row" style="display:none;">
                    <div class="slider-item">
                        <div class="engine-buttons" style="display: flex; gap: 20px; margin-top: 0;">
                            <div class="selector-group">
                                <span class="selector-label">Sprocket</span>
                                <div id="sprocket35mm240Buttons" style="display: flex; gap: 8px;">
                                    <button class="engine-btn round selected" data-sprocket="A">1</button>
                                    <button class="engine-btn round" data-sprocket="B">2</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="border35mm240Row" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Border</div>
                        <div class="engine-buttons" id="border35mm240Buttons" style="display: flex; gap: 8px;">
                            <button class="engine-btn round selected" data-border="A">1</button>
                            <button class="engine-btn round" data-border="B">2</button>
                            <button class="engine-btn round" data-border="C">3</button>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="sprocket35mm240ScaleSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Scale <span class="slider-value" id="sprocket35mm240ScaleVal">1.00</span></div>
                        <input type="range" id="sprocket35mm240Scale" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row" id="sprocket35mm240TranslationSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Translation <span class="slider-value" id="sprocket35mm240TranslationVal">1.00</span></div>
                        <input type="range" id="sprocket35mm240Translation" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <!-- 35mm 1.33 engine UI -->
                <div class="slider-row" id="sprocket35mm133Row" style="display:none;">
                    <div class="slider-item">
                        <div class="engine-buttons" style="display: flex; gap: 20px; margin-top: 0;">
                            <div class="selector-group">
                                <span class="selector-label">Sprocket</span>
                                <div id="sprocket35mm133Buttons" style="display: flex; gap: 8px;">
                                    <button class="engine-btn round selected" data-sprocket="A">1</button>
                                    <button class="engine-btn round" data-sprocket="B">2</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="border35mm133Row" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Border</div>
                        <div class="engine-buttons" id="border35mm133Buttons" style="display: flex; gap: 8px;">
                            <button class="engine-btn round selected" data-border="A">1</button>
                            <button class="engine-btn round" data-border="B">2</button>
                            <button class="engine-btn round" data-border="C">3</button>
                        </div>
                    </div>
                </div>
                <div class="slider-row" id="sprocket35mm133ScaleSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Scale <span class="slider-value" id="sprocket35mm133ScaleVal">1.00</span></div>
                        <input type="range" id="sprocket35mm133Scale" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row" id="sprocket35mm133TranslationSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Translation <span class="slider-value" id="sprocket35mm133TranslationVal">1.00</span></div>
                        <input type="range" id="sprocket35mm133Translation" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label" id="sprocketStockLabel">Sprocket Stock</div>
                        <select id="sprocketStockSelect" class="styled-select">
                            <option value="spectra400">Spectra 400</option>
                            <option value="spectra800">Spectra 800</option>
                            <option value="portra400">Portra 400</option>
                            <option value="portra800">Portra 800</option>
                        </select>
                    </div>
                </div>
                <div class="slider-row" id="sprocketMediumFormatRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Medium Format Sprocket</div>
                        <select id="sprocketMediumFormatSelect" class="styled-select">
                            <option value="spectra800" selected>Spectra 800</option>
                            <option value="spectra400">Spectra 400</option>
                        </select>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" id="borderScaleSliderItem">
                        <div class="slider-label">Border Scale <span class="slider-value" id="borderScaleVal">1.00</span></div>
                        <input type="range" id="borderScale" min="0.5" max="2" step="0.001" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" id="imageScaleSliderItem">
                        <div class="slider-label">Image Scale <span class="slider-value" id="imageScaleVal">1.00</span></div>
                        <input type="range" id="imageScale" min="0.25" max="2" step="0.001" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" id="cheatAspectXSliderItem">
                        <div class="slider-label">Cheat Aspect X <span class="slider-value" id="cheatAspectXVal">1.00</span></div>
                        <input type="range" id="cheatAspectX" min="0.75" max="1.25" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item" id="cheatAspectYSliderItem">
                        <div class="slider-label">Cheat Aspect Y <span class="slider-value" id="cheatAspectYVal">1.00</span></div>
                        <input type="range" id="cheatAspectY" min="0.75" max="1.25" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-item">
                        <label class="toggle-switch">
                            <span class="slider-label">Cheat Aspect in Proxy</span>
                            <input type="checkbox" id="cheatAspectProxyToggle" checked>
                            <span class="switch"></span>
                        </label>
                    </div>
                </div>
                <div class="slider-row" id="adjacentFrameDistanceSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Adjacent Frame Distance <span class="slider-value" id="adjacentFrameDistanceVal">100</span></div>
                        <input type="range" id="adjacentFrameDistance" min="80" max="150" step="0.1" value="100">
                    </div>
                </div>
                <div class="slider-row" id="framePaddingSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Frame Padding <span class="slider-value" id="framePaddingVal">0.00</span></div>
                        <input type="range" id="framePadding" min="-0.10" max="0.20" step="0.01" value="0.00">
                    </div>
                </div>
                <div class="slider-row" id="sprocketScaleSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Translation <span class="slider-value" id="sprocketScaleVal">1.00</span></div>
                        <input type="range" id="sprocketScale" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                <div class="slider-row" id="borderBlurSliderRow" style="display:none;">
                    <div class="slider-item">
                        <div class="slider-label">Border Blur <span class="slider-value" id="borderBlurVal">0.0</span></div>
                        <input type="range" id="borderBlur" min="0" max="40" step="0.1" value="0">
                    </div>
                </div>
                <div class="slider-row"><div class="slider-item"><div class="slider-label">Black Level Bias <span class="slider-value" id="blackLevelBiasVal">0.90</span></div><input type="range" id="blackLevelBias" min="0" max="1" step="0.01" value="0.9"></div></div>
                <div class="slider-row">
                    <div class="slider-item">
                        <div class="slider-label">Sprocket Contrast <span class="slider-value" id="sprocketContrastVal">1.00</span></div>
                        <input type="range" id="sprocketContrast" min="0.5" max="2" step="0.01" value="1.0">
                    </div>
                </div>
            </div>
            <div class="slider-panel" id="dustPanel">
                 <div class="panel-toggle-container" style="margin-bottom: 20px;">
                    <label class="toggle-switch">
                        <span class="slider-label">Dust</span>
                        <input type="checkbox" id="dustEnabledToggle">
                        <span class="switch"></span>
                    </label>
                </div>
                <button class="main-btn panel-toggle-btn" id="randomizeDustBtn">Randomize</button>
                <div class="slider-row">
                    <div class="slider-item"><div class="slider-label">Move X <span class="slider-value" id="dustMoveXVal">0.00</span></div><input type="range" id="dustMoveX" min="-1" max="2" step="0.01" value="0"></div>
                    <div class="slider-item"><div class="slider-label">Move Y <span class="slider-value" id="dustMoveYVal">0.00</span></div><input type="range" id="dustMoveY" min="-1" max="2" step="0.01" value="0"></div>
                </div>
                 <div class="slider-row">
                    <div class="slider-item"><div class="slider-label">Rotate <span class="slider-value" id="dustRotateVal">1.00</span></div><input type="range" id="dustRotate" min="0" max="2" step="0.01" value="1.0"></div>
                </div>
            </div>
            <div class="main-controls" id="mainControls">
                <button class="main-btn" id="halationBtn">Halation</button>
                <button class="main-btn" id="opticsBtn">Optics</button>
                <button class="main-btn" id="borderBtn">Border</button>
                <button class="main-btn" id="textureBtn">Texture</button>
                <button class="main-btn" id="dustBtn">Dust</button>
            </div>
        </div>
        <input type="file" accept="image/*" id="uploadImage" class="file-input">
        <input type="file" accept="image/*" id="uploadBatch" class="file-input" multiple>
    </div>

    <div class="film-stock-menu-overlay" id="filmStockMenuOverlay">
        <div class="film-stock-menu">
            <div class="gauge-slider-container">
                <div class="slider-label">Gauge</div>
                <div class="gauge-slider">
                    <input type="range" id="gaugeSlider" min="0" max="2" step="1" value="2">
                    <div class="gauge-slider-labels">
                        <span>8mm</span>
                        <span>16mm</span>
                        <span>35mm</span>
                    </div>
                </div>
            </div>
            <div class="film-stock-grid">
                <div class="film-stock-grid-row">
                    <div class="film-stock-grid-icon icon-grid-filmroll"></div>
                    <div class="film-stock-buttons">
                        <button class="stock-btn">100</button>
                        <button class="stock-btn selected">400</button>
                        <button class="stock-btn">800</button>
                    </div>
                </div>
                <div class="film-stock-grid-row">
                    <div class="film-stock-grid-icon icon-grid-movie"></div>
                    <div class="film-stock-buttons">
                        <button class="stock-btn">50D</button>
                        <button class="stock-btn">250D</button>
                        <button class="stock-btn">500T</button>
                    </div>
                </div>
            </div>
            <div style="margin-top: 12px;">
                <button class="main-btn" id="filmStockApplyBtn" style="width: 100%;">Apply</button>
            </div>
        </div>
    </div>

    <div class="settings-menu-overlay" id="settingsMenuOverlay">
        <div class="settings-menu">
            <div class="gauge-slider-container">
                <div class="slider-label">Preview Resolution limit <span class="slider-value" id="maxResVal">2048 px</span></div>
                <div class="gauge-slider">
                    <input type="range" id="maxResSlider" min="1024" max="4096" step="1024" value="2048">
                    <div class="gauge-slider-labels">
                        <span>1k</span>
                        <span>2k</span>
                        <span>3k</span>
                        <span>4k</span>
                    </div>
                </div>
            </div>
            <div class="gauge-slider-container">
                <div class="slider-label">Export Resolution limit <span class="slider-value" id="exportResVal">4096 px</span></div>
                <div class="gauge-slider">
                    <input type="range" id="exportResSlider" min="1024" max="5120" step="1024" value="4096">
                    <div class="gauge-slider-labels">
                        <span>1k</span>
                        <span>2k</span>
                        <span>3k</span>
                        <span>4k</span>
                        <span>Original</span>
                    </div>
                </div>
            </div>
            <div class="settings-row" style="margin-top: 10px;">
                <label class="toggle-switch">
                    <span class="slider-label">CPU Tiling</span>
                    <input type="checkbox" id="cpuTilingToggle">
                    <span class="switch"></span>
                </label>
            </div>
            <div class="settings-row" id="bandedCPURow" style="margin-top: 6px; display: none;">
                <label class="toggle-switch">
                    <span class="slider-label">Banded CPU</span>
                    <input type="checkbox" id="bandedCPUToggle">
                    <span class="switch"></span>
                </label>
            </div>
            <div class="settings-divider">Canvas</div>
            <div class="settings-row" style="margin-bottom: 8px;">
                <div class="flex-1 slider-item" id="backgroundSliderItem">
                    <div class="slider-label">Background colour <span class="slider-value" id="backgroundVal">0%</span></div>
                    <input type="range" id="backgroundSlider" min="0" max="100" step="5" value="0">
                </div>
            </div>
            <div class="settings-row" style="margin-top: 26px;">
                <label class="toggle-switch">
                    <span class="slider-label">Drop Shadow</span>
                    <input type="checkbox" id="dropShadowToggle" checked>
                    <span class="switch"></span>
                </label>
            </div>
            
            <!-- App Settings Default Buttons -->
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; gap: 10px;">
                    <button class="main-btn" id="setDefaultsBtn" style="flex: 1;">Set as Default</button>
                    <button class="main-btn" id="resetDefaultsBtn" style="flex: 1;">Reset to Defaults</button>
                </div>
            </div>
        </div>
    </div>

        <div class="presets-menu-overlay" id="presetsMenuOverlay">
        <div class="presets-menu">
            <div class="presets-header">
                <h3>My Presets</h3>
                <button class="add-preset-btn" id="addPresetBtn">+</button>
            </div>
            
            <!-- Default Settings Item -->
            <div class="preset-item" id="defaultSettingsItem" style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.2);">
                <span class="preset-item-name">Default Settings</span>
                <div style="display: flex; gap: 5px;">
                    <button class="main-btn" id="setFactoryDefaultBtn" style="font-size: 12px; padding: 4px 8px;">Set</button>
                    <button class="main-btn" id="restoreFactoryDefaultBtn" style="font-size: 12px; padding: 4px 8px;">Restore</button>
                </div>
            </div>
            
            <div class="presets-list" id="userPresetsList">
                <!-- User presets will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- Modal: CPU required warning -->
    <div class="modal-overlay" id="cpuWarningModal">
        <div class="modal-content">
            <h3>CPU Tiling Required</h3>
            <p>Original resolution output requires CPU tiling. Disable Original first to turn CPU tiling off.</p>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" id="cpuWarningOkBtn">OK</button>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="addPresetModal">
        <div class="modal-content">
            <h3 id="presetModalTitle">Add New Preset</h3>
            <p>Current settings will be stored as a new preset.</p>
            <input type="text" id="presetNameInput" placeholder="Preset Name" class="modal-input">
            <div class="preset-params-list" id="presetParamsList">
                <!-- Checkboxes will be dynamically inserted here -->
            </div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancelPresetBtn">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="savePresetBtn">Save</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="batchProcessModal">
        <div class="modal-content">
            <h3>Process Batch</h3>
            <p id="batchModalDescription">Process X images</p>
            
            <!-- Settings Toggle -->
            <div style="margin: 20px 0;">
                <label class="toggle-switch">
                    <span class="slider-label">Use Current Settings</span>
                    <input type="checkbox" id="useCurrentSettingsToggle" checked>
                    <span class="switch"></span>
                </label>
            </div>
            
            <!-- Preset Selection -->
            <div id="presetSelectionContainer" style="margin: 20px 0;">
                <div class="slider-label" style="margin-bottom: 10px;">Select Preset:</div>
                <div id="batchPresetsList" style="max-height: 120px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; background: rgba(0,0,0,0.3);">
                    <!-- Presets will be populated dynamically -->
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancelBatchBtn">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="confirmBatchBtn">Process</button>
            </div>
        </div>
    </div>

<div class="progress-indicator" id="progressIndicator">Processing...</div>


<script>
    (() => {
        const appContainer = document.getElementById('appContainer');
        const viewport = document.getElementById('viewport');
        const imageWrapper = document.getElementById('imageWrapper');
        const canvas = document.getElementById('canvas');
        const zoomIndicator = document.getElementById('zoomIndicator');
        const bottomUI = document.getElementById('bottomUI');
        const mainControls = document.getElementById('mainControls');
        const returnMinBtn = document.getElementById("returnMinBtn");
        const returnMaxBtn = document.getElementById("returnMaxBtn");
        const returnMaxSourceBtn = document.getElementById("returnMaxSourceBtn");
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomFitBtn = document.getElementById('zoomFitBtn');
        const zoom100Btn = document.getElementById('zoom100Btn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const loadImageBtn = document.getElementById('loadImageBtn');
        const saveBtn = document.getElementById('saveBtn');
        const halationBtn = document.getElementById('halationBtn');
        const whiteCompSlider = document.getElementById('whiteCompSlider');
        const whiteCompValLabel = document.getElementById('whiteCompVal');
        const whiteCompLimitSlider = document.getElementById('whiteCompLimit');
        const whiteCompLimitValLabel = document.getElementById('whiteCompLimitVal');
        const opticsBtn = document.getElementById('opticsBtn');
        const textureBtn = document.getElementById('textureBtn');
        const dustBtn = document.getElementById('dustBtn');
        const borderBtn = document.getElementById('borderBtn');
        const halationPanel = document.getElementById('halationPanel');
        const opticsPanel = document.getElementById('opticsPanel');
        const texturePanel = document.getElementById('texturePanel');
        const dustPanel = document.getElementById('dustPanel');
        const borderPanel = document.getElementById('borderPanel');
        const uploadImageInput = document.getElementById("uploadImage");
        const grainIntensitySlider=document.getElementById("grainIntensity");
        const highPassRadiusSlider=document.getElementById("highPassRadius");
        const highPassOpacitySlider=document.getElementById("highPassOpacity");
        const grainScaleSlider=document.getElementById("grainScale");
        const grainStockSelect=document.getElementById("grainStockSelect");
        const grainIntensityValLabel=document.getElementById("grainIntensityVal");
        const highPassRadiusValLabel=document.getElementById("highPassRadiusVal");
        const highPassOpacityValLabel=document.getElementById("highPassOpacityVal");
        const grainScaleValLabel=document.getElementById("grainScaleVal");
        const batchBtn = document.getElementById('batchBtn');
        const uploadBatchInput = document.getElementById('uploadBatch');
        const randomizeDustBtn = document.getElementById('randomizeDustBtn');
        const dustMoveXSlider = document.getElementById('dustMoveX');
        const dustMoveYSlider = document.getElementById('dustMoveY');
        const dustRotateSlider = document.getElementById('dustRotate');
        const dustMoveXValLabel = document.getElementById('dustMoveXVal');
        const dustMoveYValLabel = document.getElementById('dustMoveYVal');
        const dustRotateValLabel = document.getElementById('dustRotateVal');
        const grainSaturationSlider = document.getElementById('grainSaturation');
        const grainSaturationValLabel = document.getElementById('grainSaturationVal');
        const grainReduceShadowsSlider = document.getElementById('grainReduceShadows');
        const grainReduceShadowsValLabel = document.getElementById('grainReduceShadowsVal');
        const grainShadowSatSlider = document.getElementById('grainShadowSat');
        const grainShadowSatValLabel = document.getElementById('grainShadowSatVal');
        const grainReduceHighlightsSlider = document.getElementById('grainReduceHighlights');
        const grainReduceHighlightsValLabel = document.getElementById('grainReduceHighlightsVal');
        const grainHighlightSatSlider = document.getElementById('grainHighlightSat');
        const grainHighlightSatValLabel = document.getElementById('grainHighlightSatVal');
        const borderScaleSliderItem = document.getElementById('borderScaleSliderItem');
        const borderScaleSlider = document.getElementById('borderScale');
        const borderScaleValLabel = document.getElementById('borderScaleVal');
        const blackLevelBiasSlider = document.getElementById('blackLevelBias');
        const blackLevelBiasValLabel = document.getElementById('blackLevelBiasVal');
        const sprocketStockSelect = document.getElementById('sprocketStockSelect');
        const sprocketContrastSlider = document.getElementById('sprocketContrast');
        const sprocketContrastValLabel = document.getElementById('sprocketContrastVal');
        const imageScaleSlider = document.getElementById('imageScale');
        const imageScaleValLabel = document.getElementById('imageScaleVal');
        const cheatAspectXSlider = document.getElementById('cheatAspectX');
        const cheatAspectXValLabel = document.getElementById('cheatAspectXVal');
        const cheatAspectYSlider = document.getElementById('cheatAspectY');
        const cheatAspectYValLabel = document.getElementById('cheatAspectYVal');
        const cheatAspectProxyToggle = document.getElementById('cheatAspectProxyToggle');
        const overscanSlider = document.getElementById('overscan');
        const overscanValLabel = document.getElementById('overscanVal');
        const overscanSliderItem = document.getElementById('overscanSliderItem');
        const framingSlider = document.getElementById('framing');
        const framingValLabel = document.getElementById('framingVal');
        const framingSliderItem = document.getElementById('framingSliderItem');
        const imageScaleSliderItem = document.getElementById('imageScaleSliderItem');
        const backgroundSlider = document.getElementById('backgroundSlider');
        const backgroundVal = document.getElementById('backgroundVal');
        const dropShadowToggle = document.getElementById('dropShadowToggle');
        const adjacentFrameDistanceSlider = document.getElementById('adjacentFrameDistance');
        const adjacentFrameDistanceValLabel = document.getElementById('adjacentFrameDistanceVal');
        const framePaddingSlider = document.getElementById('framePadding');
        const framePaddingValLabel = document.getElementById('framePaddingVal');
        const cpuTilingToggle = document.getElementById('cpuTilingToggle');
        const bandedCPUToggle = document.getElementById('bandedCPUToggle');
        const bandedCPURow = document.getElementById('bandedCPURow');
        const cpuWarningModal = document.getElementById('cpuWarningModal');
        const cpuWarningOkBtn = document.getElementById('cpuWarningOkBtn');

        // Resolution special handling
        const ORIGINAL_SLIDER_VALUE = 5120; // sentinel value => Original
        let globalResolutionOverride = null; // override for u_canvasResolution across tiles
        let virtualCanvasSize = null; // used by overscan calculators to use export sizing
        let isBatchExportMode = false; // suppress per-image alerts in batch
        let thresholdPreviewActive = false; // show premultiplied feed during threshold drag

        // Store the original adjacent frame distance value before any CheatY scaling
        let originalAdjacentFrameDistance = parseFloat(adjacentFrameDistanceSlider.value);
        const borderBlurSlider = document.getElementById('borderBlur');
        const borderBlurValLabel = document.getElementById('borderBlurVal');
        const diffusionThresholdSlider = document.getElementById('diffusionThreshold');
        const diffusionThresholdValLabel = document.getElementById('diffusionThresholdVal');
        const diffusionThresholdPreviewToggle = document.getElementById('diffusionThresholdPreviewToggle');
        
        // Store border blur values for each engine mode separately
        const borderBlurSettings = {
            '8mm': 0,
            '16mm': 0,
            '35mm-178': 0,
            '35mm-240': 0,
            '35mm-133': 0,
            '35mm-add': 0,
            'medium-format': 0
        };
        
        // Sprocket scale offset values for each border engine
        const sprocketScaleOffsets = {
            '35mm-133': 0.1,
            '35mm-240': 0.28,
            '35mm-178': 0.25
        };
        

        const sprocketScaleSlider = document.getElementById('sprocketScale');
        const sprocketScaleValLabel = document.getElementById('sprocketScaleVal');
        
        const halationEnabledToggle = document.getElementById('halationEnabledToggle');
        const textureEnabledToggle = document.getElementById('textureEnabledToggle');
        const dustEnabledToggle = document.getElementById('dustEnabledToggle');
        const mtfLinearToggle = document.getElementById('mtfLinearToggle');
        const halationIntensitySlider = document.getElementById('halationIntensity');
        const halationIntensityValLabel = document.getElementById('halationIntensityVal');
        const mtfMaskSlider = document.getElementById('mtfMask');
        const mtfSoftnessSlider = document.getElementById('mtfSoftness');
        const blackpointSlider = document.getElementById('blackpoint');
        const whitepointSlider = document.getElementById('whitepoint');
        const thresholdGammaSlider = document.getElementById('thresholdGamma');
        const coreBlurSlider = document.getElementById('coreBlur');
        const midBlurSlider = document.getElementById('midBlur');
        const outerBlurSlider = document.getElementById('outerBlur');
        const midBlurGainSlider = document.getElementById('midBlurGain');
        const outerBlurGainSlider = document.getElementById('outerBlurGain');
        const tintR2Slider = document.getElementById('tintR2');
        const tintG2Slider = document.getElementById('tintG2');
        const tintB2Slider = document.getElementById('tintB2');
        const diffusionRadiusSlider = document.getElementById('diffusionRadius');
        const diffusionStrengthSlider = document.getElementById('diffusionStrength');
        const diffusionRadiusBSlider = document.getElementById('diffusionRadiusB');
        const diffusionStrengthBSlider = document.getElementById('diffusionStrengthB');
        const diffusionRadiusCSlider = document.getElementById('diffusionRadiusC');
        const diffusionStrengthCSlider = document.getElementById('diffusionStrengthC');
        const diffusionTintRSlider = document.getElementById('diffusionTintR');
        const diffusionTintGSlider = document.getElementById('diffusionTintG');
        const diffusionTintBSlider = document.getElementById('diffusionTintB');
        const diffusionSpreadSlider = document.getElementById('diffusionSpread');
        const diffusionGammaSlider = document.getElementById('diffusionGamma');
        const diffusionIntensitySlider = document.getElementById('diffusionIntensity');
        const diffusionSubtractToggle = document.getElementById('diffusionSubtractToggle');
        
        // Diffusion DEF (02) sliders
        const diffusionRadiusDSlider = document.getElementById('diffusionRadiusD');
        const diffusionStrengthDSlider = document.getElementById('diffusionStrengthD');
        const diffusionRadiusESlider = document.getElementById('diffusionRadiusE');
        const diffusionStrengthESlider = document.getElementById('diffusionStrengthE');
        const diffusionRadiusFSlider = document.getElementById('diffusionRadiusF');
        const diffusionStrengthFSlider = document.getElementById('diffusionStrengthF');
        const diffusionTint2RSlider = document.getElementById('diffusionTint2R');
        const diffusionTint2GSlider = document.getElementById('diffusionTint2G');
        const diffusionTint2BSlider = document.getElementById('diffusionTint2B');
        const diffusionSpread2Slider = document.getElementById('diffusionSpread2');
        const diffusionGamma2Slider = document.getElementById('diffusionGamma2');
        const diffusionIntensity2Slider = document.getElementById('diffusionIntensity2');
        const diffusionThreshold2Slider = document.getElementById('diffusionThreshold2');
        const thresholdGamma2Slider = document.getElementById('thresholdGamma2');
        const thresholdWhite2Slider = document.getElementById('thresholdWhite2');
        const diffusionThresholdPreview2Toggle = document.getElementById('diffusionThresholdPreview2Toggle');
        const diffusionSubtract2Toggle = document.getElementById('diffusionSubtract2Toggle');
        const diffusionMinRgbToggle = document.getElementById('diffusionMinRgbToggle');
        const diffusionPremultiplyToggle = document.getElementById('diffusionPremultiplyToggle');
        const halationScreenToggle = document.getElementById('halationScreenToggle');
        const mtfMaskValLabel = document.getElementById('mtfMaskVal');
        const mtfSoftnessValLabel = document.getElementById('mtfSoftnessVal');
        const blackpointValLabel = document.getElementById('blackpointVal');
        const whitepointValLabel = document.getElementById('whitepointVal');
        const thresholdGammaValLabel = document.getElementById('thresholdGammaVal');
        const coreBlurValLabel = document.getElementById('coreBlurVal');
        const midBlurValLabel = document.getElementById('midBlurVal');
        const outerBlurValLabel = document.getElementById('outerBlurVal');
        const midBlurGainValLabel = document.getElementById('midBlurGainVal');
        const outerBlurGainValLabel = document.getElementById('outerBlurGainVal');
        const tintR2ValLabel = document.getElementById('tintR2Val');
        const tintG2ValLabel = document.getElementById('tintG2Val');
        const tintB2ValLabel = document.getElementById('tintB2Val');
        const diffusionRadiusValLabel = document.getElementById('diffusionRadiusVal');
        const diffusionStrengthValLabel = document.getElementById('diffusionStrengthVal');
        const diffusionRadiusBValLabel = document.getElementById('diffusionRadiusBVal');
        const diffusionStrengthBValLabel = document.getElementById('diffusionStrengthBVal');
        const diffusionRadiusCValLabel = document.getElementById('diffusionRadiusCVal');
        const diffusionStrengthCValLabel = document.getElementById('diffusionStrengthCVal');
        const diffusionTintRValLabel = document.getElementById('diffusionTintRVal');
        const diffusionTintGValLabel = document.getElementById('diffusionTintGVal');
        const diffusionTintBValLabel = document.getElementById('diffusionTintBVal');
        const diffusionSpreadValLabel = document.getElementById('diffusionSpreadVal');
        const diffusionGammaValLabel = document.getElementById('diffusionGammaVal');
        const diffusionIntensityValLabel = document.getElementById('diffusionIntensityVal');
        
        // Diffusion DEF (02) value labels
        const diffusionRadiusDValLabel = document.getElementById('diffusionRadiusDVal');
        const diffusionStrengthDValLabel = document.getElementById('diffusionStrengthDVal');
        const diffusionRadiusEValLabel = document.getElementById('diffusionRadiusEVal');
        const diffusionStrengthEValLabel = document.getElementById('diffusionStrengthEVal');
        const diffusionRadiusFValLabel = document.getElementById('diffusionRadiusFVal');
        const diffusionStrengthFValLabel = document.getElementById('diffusionStrengthFVal');
        const diffusionTint2RValLabel = document.getElementById('diffusionTint2RVal');
        const diffusionTint2GValLabel = document.getElementById('diffusionTint2GVal');
        const diffusionTint2BValLabel = document.getElementById('diffusionTint2BVal');
        const diffusionSpread2ValLabel = document.getElementById('diffusionSpread2Val');
        const diffusionGamma2ValLabel = document.getElementById('diffusionGamma2Val');
        const diffusionIntensity2ValLabel = document.getElementById('diffusionIntensity2Val');
        const diffusionThreshold2ValLabel = document.getElementById('diffusionThreshold2Val');
        const thresholdGamma2ValLabel = document.getElementById('thresholdGamma2Val');
        const thresholdWhite2ValLabel = document.getElementById('thresholdWhite2Val');
        const progressIndicator = document.getElementById('progressIndicator');
        let progressIndicatorTimeout = null;
        
        function showProgressIndicator(immediate = false) {
            if (!progressIndicator) return;
            
            // Clear any existing timeout
            if (progressIndicatorTimeout) {
                clearTimeout(progressIndicatorTimeout);
                progressIndicatorTimeout = null;
            }
            
            if (immediate) {
                progressIndicator.classList.add('visible');
            } else {
                // Delay showing by 500ms to avoid flicker for fast operations
                progressIndicatorTimeout = setTimeout(() => {
                    if (progressIndicator) {
                        progressIndicator.classList.add('visible');
                    }
                    progressIndicatorTimeout = null;
                }, 500);
            }
        }
        
        function hideProgressIndicator() {
            if (!progressIndicator) return;
            
            // Clear any pending timeout
            if (progressIndicatorTimeout) {
                clearTimeout(progressIndicatorTimeout);
                progressIndicatorTimeout = null;
            }
            
            progressIndicator.classList.remove('visible');
        }
        const imageLoadingOverlay = document.getElementById('imageLoadingOverlay');

        // Prefer not preserving the default framebuffer to reduce GPU memory pressure on mobile
        const gl = canvas.getContext("webgl2", { preserveDrawingBuffer: false, antialias: false, powerPreference: "low-power" }) || canvas.getContext("webgl", { preserveDrawingBuffer: false, antialias: false, powerPreference: "low-power" });
        if (!gl) { alert("WebGL not supported"); return; }
        
        let isTilingRenderInProgress = false;
        let renderDebounceTimeout = null;
        // Heuristics for iOS WebKit memory limits
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        // Default: avoid precomputing diffusion on iOS to prevent GPU OOM
        if (typeof window.__disablePrecomputedDiffusion === 'undefined') {
          window.__disablePrecomputedDiffusion = isIOS;
        }
        const TILE_SIZE = isIOS ? 768 : 1024;
        const BLUR_OVERLAP_FACTOR = isIOS ? 3.0 : 3.5;
        const MAX_SAFE_FBO_RES = isIOS ? 1536 : 2048;
        // Guard for viewport artifacts: when source is undersized (<=1024 on short edge)
        // and preview cap is >= 2048, force the robust preview/tiled path.
        function isEffectivelyLargeForPreview() {
          try {
            const maxResSliderEl = document.getElementById('maxResSlider');
            const previewCap = maxResSliderEl ? parseInt(maxResSliderEl.value, 10) : 2048;
            const isBorderEngine = (
              window.__borderEngine === '8mm' ||
              window.__borderEngine === '16mm' ||
              window.__borderEngine === '35mm-178' ||
              window.__borderEngine === '35mm-240' ||
              window.__borderEngine === '35mm-133' ||
              window.__borderEngine === '35mm-add' ||
              window.__borderEngine === 'medium-format'
            );
            // Unconditional: any border engine at 1k should use robust preview/tiled path
            if (isBorderEngine && previewCap === 1024) return true;

            const srcW = (window.sourceNativeDimensions && window.sourceNativeDimensions.w) ? window.sourceNativeDimensions.w : (originalImageDimensions && originalImageDimensions.w) ? originalImageDimensions.w : canvas.width;
            const srcH = (window.sourceNativeDimensions && window.sourceNativeDimensions.h) ? window.sourceNativeDimensions.h : (originalImageDimensions && originalImageDimensions.h) ? originalImageDimensions.h : canvas.height;
            const undersized = (Math.min(srcW, srcH) <= 1024);
            // Case: undersized sources at high preview caps (≥2k)
            if (undersized && previewCap >= 2048) return true;

            return false;
          } catch (_) { return false; }
        }
        let isBorderInteractivePreview = false;
        let savedMaxResValue = null;
        let preserveViewOnNextLoad = false;
        let suppressImageFade = false;
        let isImageLoadTransitionActive = false;
        let suppressRenders = false; // pause renders during batch apply
        // Document aspect mode for border canvas: '16:9' (default), '6:4', '1:1'
        window.__docAspectMode = window.__docAspectMode || '16:9';

        function getDocAspectRatio() {
            // Returns numeric ratio (width/height) for the current document aspect mode
            const m = (window.__docAspectMode || '16:9');
            if (m === '1:1') return 1.0;
            if (m === '5:4') return 5/4;
            if (m === '4:3') return 4/3;
            if (m === '7:5') return 7/5;
            if (m === '3:2' || m === '6:4') return 3/2; // Keep 6:4 for backwards compatibility
            if (m === '5:3') return 5/3;
            if (m === '16:9') return 16/9;
            return 16/9; // default
        }

        function getAspectRatioMultiplier() {
            // Calculate multiplier to compensate for aspect ratio cropping
            // This ensures the final cropped long edge matches the slider value
            if (!currentShapeIsBorder()) return 1.0;
            
            const currentAspect = window.__docAspectMode || '16:9';
            if (currentAspect === '16:9') return 1.0; // No multiplier needed for 16:9
            
            const baseAspect = 16/9; // Base aspect ratio (16:9)
            const targetAspect = getDocAspectRatio(); // Current selected aspect ratio
            
            // Calculate the basic multiplier: (baseAspect / targetAspect)
            let multiplier = baseAspect / targetAspect;
            
            // Apply small correction for rounding errors to ensure exact target resolution
            if (currentAspect === '3:2' || currentAspect === '6:4') {
                multiplier = 1.185185185185185; // More precise value to avoid rounding errors
            } else if (currentAspect === '1:1') {
                multiplier = 16/9; // Exact fraction
            } else if (currentAspect === '5:4') {
                multiplier = (16/9) / (5/4); // 1.422...
            } else if (currentAspect === '4:3') {
                multiplier = (16/9) / (4/3); // 1.333...
            } else if (currentAspect === '7:5') {
                multiplier = (16/9) / (7/5); // 1.269...
            } else if (currentAspect === '5:3') {
                multiplier = (16/9) / (5/3); // 1.066...
            }
            
            return multiplier;
        }

        function getCropRectForDims(w, h) {
            // Compute centered crop rect in pixel coords for the full document (w,h)
            if (!currentShapeIsBorder() || (window.__docAspectMode || '16:9') === '16:9') {
                return { x: 0, y: 0, w, h };
            }
            const docIsPortrait = h > w;
            const target = getDocAspectRatio();
            const targetAR = docIsPortrait ? (1/target) : target; // rotate target for portrait doc
            const docAR = w / h;
            let cw = w, ch = h;
            if (docAR > targetAR) {
                // Too wide -> crop width
                cw = Math.floor(h * targetAR);
            } else if (docAR < targetAR) {
                // Too tall -> crop height
                ch = Math.floor(w / targetAR);
            }
            const cx = Math.floor((w - cw) / 2);
            const cy = Math.floor((h - ch) / 2);
            return { x: cx, y: cy, w: cw, h: ch };
        }

        function getCropRectForPreview(previewW, previewH) {
            // Map crop based on preview FBO size instead of full canvas
            if (!currentShapeIsBorder() || (window.__docAspectMode || '16:9') === '16:9') {
                return { x: 0, y: 0, w: previewW, h: previewH };
            }
            // Use the same logic but in preview space
            return getCropRectForDims(previewW, previewH);
        }

        function computeExportDocAndCrop(oW, oH, targetMax) {
            // Compute scaled document size (before crop), and crop rect such that
            // the final cropped long edge equals targetMax (unless targetMax is 'Original').
            const mode = window.__docAspectMode || '16:9';
            const docIsPortrait = oH > oW;
            const t = (mode === '1:1') ? 1.0 : (mode === '6:4' ? (6/4) : (16/9));
            const targetAR = docIsPortrait ? (1/t) : t;
            const docAR = oW / oH;
            let s = 1.0;
            if (!(parseInt(targetMax,10) >= ORIGINAL_SLIDER_VALUE)) {
                const maxEdge = parseInt(targetMax,10) || 1024;
                if (mode === '16:9') {
                    s = Math.min(1.0, maxEdge / Math.max(oW, oH));
                } else {
                    // Solve for s so that cropped long edge equals maxEdge
                    const targetIsLandscape = targetAR >= 1.0;
                    if (docAR > targetAR) {
                        // width crop
                        const longEdgeFactor = targetIsLandscape ? (oH * targetAR) : oH;
                        s = Math.min(1.0, maxEdge / longEdgeFactor);
                    } else {
                        // height crop
                        const longEdgeFactor = targetIsLandscape ? oW : (oW / targetAR);
                        s = Math.min(1.0, maxEdge / longEdgeFactor);
                    }
                }
            }
            const docW = Math.max(1, Math.round(oW * s));
            const docH = Math.max(1, Math.round(oH * s));
            const crop = (mode === '16:9') ? { x:0, y:0, w:docW, h:docH } : getCropRectForDims(docW, docH);
            return { docW, docH, crop };
        }

        function checkFloatSupport() {
            const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
            if (isWebGL2) return !!gl.getExtension('EXT_color_buffer_float');
            return !!(gl.getExtension('OES_texture_float') && gl.getExtension('WEBGL_color_buffer_float'));
        }
        const supportsFloat = checkFloatSupport();

        let imageTexture = null, grainTexture = null, dustTexture = null, borderTexture = null, sprocketTexture = null,
            rawImageTexture = null, rawSrgbTexture = null, chromaProcessedTexture = null,
            maskATexture = null, maskBTexture = null, maskCTexture = null,
            originalBorderTexture = null, // <<< FIX: ADDED VARIABLE
            originalSrgbTexture = null, // Store original sRGB before white point processing
            postMtfSrgbTexture = null, // Store post-MTF sRGB for white point processing
            grainDimensions = { w: 0, h: 0 };
        let originalImageDimensions = { w: 0, h: 0 };
        let originalFileBlob = null;
        let minPixelValue = [0, 0, 0];
        let maxPixelValue = [1, 1, 1];
        let maxPixelLinear = [1, 1, 1];
        let maxPixelSampleCanvas = null;
        let shouldEnableWhiteComp = false;
        let isPreviewingBorder = false;
        let isSimplePreviewing = false;
        // Aspect crop animation state (normalized rects)
        let __aspectCropAnim = null; // { active, start:{x,y,w,h}, end:{x,y,w,h}, t0, dur }
        let scale = 1, offsetX = 0, offsetY = 0, isDragging = false, dragStartX = 0, dragStartY = 0, dragStartOffsetX = 0, dragStartOffsetY = 0, fitScale = 1, zoomIndicatorTimeout = null;
        let lastPanelPadding = 0; // stores last known open panel height for pan headroom during menu switches
        let holdTimeout = null, isHolding = false;
        const ZOOM_STEP = 0.25;
        const grainSources = {
            '35mm P400': './assets/grain/35mmP400.png',
            '35mm P800': './assets/grain/35mmP800.png',
            '35mm 250D': './assets/grain/35mm250D.png',
            '35mm 500T': './assets/grain/35mm500T.png',
            '16mm 500T': './assets/grain/16mm500T.png',
            '35mm E100': './assets/grain/35mmE100.png',
            '35mm 50D': './assets/grain/35mm50D.png',
            '16mm 250D': './assets/grain/16mm250D.png',
            '16mm 50D': './assets/grain/16mm50D.png',
            '8mm 500T': './assets/grain/8mm500T.png',
            '8mm 250D': './assets/grain/8mm250D.png',
            '8mm 50D': './assets/grain/8mm50D.png'
        };
        const dustSources = Array.from({length: 20}, (_, i) => `./assets/grain/dust${(i + 1).toString().padStart(2, '0')}.png`);
        const LIVE_FULL_RENDER_SLIDER_IDS = new Set([
            // Optics sliders (excluding special preview-based ones)
            'mtfMask', 'mtfSoftness', 'diffusionRadius', 'diffusionStrength',
            'diffusionRadiusB', 'diffusionStrengthB', 'diffusionRadiusC', 'diffusionStrengthC',
            'diffusionTintR', 'diffusionTintG', 'diffusionTintB', 'diffusionSpread',
            'diffusionGamma', 'diffusionIntensity', 'diffusionRadiusD', 'diffusionStrengthD',
            'diffusionRadiusE', 'diffusionStrengthE', 'diffusionRadiusF', 'diffusionStrengthF',
            'diffusionTint2R', 'diffusionTint2G', 'diffusionTint2B', 'diffusionSpread2',
            'diffusionGamma2', 'diffusionIntensity2',
            // Texture sliders
            'grainScale', 'grainIntensity', 'grainSaturation', 'grainReduceShadows',
            'grainShadowSat', 'grainReduceHighlights', 'grainHighlightSat', 'highPassRadius',
            'highPassOpacity',
            // Dust sliders
            'dustMoveX', 'dustMoveY', 'dustRotate'
        ]);
        const LIVE_FULL_RENDER_MIN_INTERVAL = 90;
        const liveFullRenderStates = new Map();
        function triggerLiveFullRender(sliderId, immediate = false) {
            if (!LIVE_FULL_RENDER_SLIDER_IDS.has(sliderId) || !imageTexture) return;
            let state = liveFullRenderStates.get(sliderId);
            if (!state) {
                state = { lastTime: 0, timer: null };
                liveFullRenderStates.set(sliderId, state);
            }
            const now = performance.now();
            if (immediate) {
                if (state.timer) {
                    clearTimeout(state.timer);
                    state.timer = null;
                }
                state.lastTime = now;
                if (isSimplePreviewing) isSimplePreviewing = false;
                render();
                return;
            }
            const elapsed = now - state.lastTime;
            if (elapsed >= LIVE_FULL_RENDER_MIN_INTERVAL) {
                state.lastTime = now;
                if (state.timer) {
                    clearTimeout(state.timer);
                    state.timer = null;
                }
                if (isSimplePreviewing) isSimplePreviewing = false;
                render();
            } else {
                const remaining = LIVE_FULL_RENDER_MIN_INTERVAL - elapsed;
                if (state.timer) clearTimeout(state.timer);
                state.timer = setTimeout(() => {
                    state.lastTime = performance.now();
                    state.timer = null;
                    if (isSimplePreviewing) isSimplePreviewing = false;
                    if (imageTexture) render();
                }, remaining);
            }
        }
        const sprocketSources = {
            'Spectra 100': './assets/grain/spectra100.png',
            'Spectra 400': './assets/grain/spectra400.png',
            'Spectra 800': './assets/grain/spectra800.png',
            'Ektar 100': './assets/grain/ektar100.png',
            'Fujifilm Pro 400H': './assets/grain/fuji400.png',
            'Lomography 800': './assets/grain/lomo800.png',
            'Portra 400': './assets/grain/portra400.png',
            'Portra 800': './assets/grain/portra800.png'
        };

        function getViewportDimensions() { return viewport.getBoundingClientRect(); }
        function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2; }
        function __rectToNorm(rect, w, h){ return { x: rect.x / w, y: rect.y / h, w: rect.w / w, h: rect.h / h }; }
        function __normToRect(n, w, h){ return { x: Math.floor(n.x * w), y: Math.floor(n.y * h), w: Math.floor(n.w * w), h: Math.floor(n.h * h) }; }
        function getAnimatedCropRect(targetW, targetH, isPreview=false) {
            // When animating aspect change, interpolate between previous and next crop rects
            if (__aspectCropAnim && __aspectCropAnim.active) {
                const now = performance.now();
                const t = Math.min(1, (now - __aspectCropAnim.t0) / (__aspectCropAnim.dur || 300));
                const e = easeInOutCubic(t);
                const nx = __aspectCropAnim.start.x + ( __aspectCropAnim.end.x - __aspectCropAnim.start.x ) * e;
                const ny = __aspectCropAnim.start.y + ( __aspectCropAnim.end.y - __aspectCropAnim.start.y ) * e;
                const nw = __aspectCropAnim.start.w + ( __aspectCropAnim.end.w - __aspectCropAnim.start.w ) * e;
                const nh = __aspectCropAnim.start.h + ( __aspectCropAnim.end.h - __aspectCropAnim.start.h ) * e;
                return __normToRect({ x: nx, y: ny, w: nw, h: nh }, targetW, targetH);
            }
            return isPreview ? getCropRectForPreview(targetW, targetH) : getCropRectForDims(targetW, targetH);
        }
        function calculateFitScale() { 
            if (!imageTexture) return 1; 
            const vp = getViewportDimensions(); 
            
            // For cropped aspect ratios in border mode, fit to the visible crop area instead of full canvas
            let displayWidth = canvas.width;
            let displayHeight = canvas.height;
            
            if (currentShapeIsBorder() && (window.__docAspectMode || '16:9') !== '16:9') {
                const crop = getCropRectForDims(canvas.width, canvas.height);
                displayWidth = crop.w;
                displayHeight = crop.h;
            }
            
            const scaleX = vp.width / displayWidth; 
            const scaleY = vp.height / displayHeight; 
            return Math.min(scaleX, scaleY) * 0.95; 
        }
        function getMinScale() { return fitScale; }
        function getMaxScale() { return 1; }
        function constrainScale(newScale) { const min = getMinScale(), max = getMaxScale(); if (scale <= 0.26 && newScale < scale) return min; return Math.max(min, Math.min(max, newScale)); }
        function constrainPan() {
            const vp = getViewportDimensions();
            
            // For cropped aspect ratios in border mode, constrain pan to the visible crop area
            let displayWidth = canvas.width;
            let displayHeight = canvas.height;
            
            if (currentShapeIsBorder() && (window.__docAspectMode || '16:9') !== '16:9') {
                const crop = getCropRectForDims(canvas.width, canvas.height);
                displayWidth = crop.w;
                displayHeight = crop.h;
            }
            
            const sW = displayWidth * scale;
            const sH = displayHeight * scale;
            const mX = Math.max(0, (sW - vp.width) / 2);
            const mY = Math.max(0, (sH - vp.height) / 2);
            // Allow extra upward pan equal to the active bottom menu height (so you can see behind it)
            let extraUp = 0;
            const activePanel = document.querySelector('.slider-panel.active');
            if (activePanel) {
                let h = 0;
                try { h = activePanel.getBoundingClientRect().height || 0; } catch(_) { h = 0; }
                // Use stored height during expansion so we don't lose headroom when switching menus
                if (h > 0) { lastPanelPadding = h; }
                extraUp = Math.max(lastPanelPadding, h);
            } else {
                extraUp = 0;
            }
            // Clamp with asymmetric vertical limits: more headroom upward when menus are open
            const minY = -mY - extraUp; // allow more negative (up) offset
            const maxY = mY;           // unchanged downward limit
            offsetX = Math.max(-mX, Math.min(mX, offsetX));
            offsetY = Math.max(minY, Math.min(maxY, offsetY));
        }
        function updateTransform(animate = false) { constrainPan(); imageWrapper.classList.toggle('animating', animate); if (animate) setTimeout(() => imageWrapper.classList.remove('animating'), 300); imageWrapper.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px) scale(${scale})`; showZoomIndicator(); }
        function showZoomIndicator() { const p = Math.round(scale * 100); zoomIndicator.textContent = `${p}%`; zoomIndicator.classList.add('visible'); clearTimeout(zoomIndicatorTimeout); zoomIndicatorTimeout = setTimeout(() => zoomIndicator.classList.remove('visible'), 1500); }
        function setZoom(newScale, cX = null, cY = null, animate = true) { if (!imageTexture) return; const vp = getViewportDimensions(); const oldS = scale; newScale = constrainScale(newScale); if (newScale === oldS) return; cX = cX === null ? vp.width / 2 : cX; cY = cY === null ? vp.height / 2 : cY; const zX = (cX - vp.width / 2 - offsetX) / oldS; const zY = (cY - vp.height / 2 - offsetY) / oldS; scale = newScale; offsetX = (cX - vp.width / 2) - zX * scale; offsetY = (cY - vp.height / 2) - zY * scale; updateTransform(animate); }
        function fitToView() { if (!imageTexture) return; scale = fitScale; offsetX = 0; offsetY = 0; updateTransform(true); }
        function zoomTo100() { if (!imageTexture) return; scale = 1; offsetX = 0; offsetY = 0; updateTransform(true); }
        function zoomIn() { if (!imageTexture) return; const step = Math.round(scale / ZOOM_STEP) * ZOOM_STEP; setZoom(step + ZOOM_STEP, null, null, true); }
        function zoomOut() { if (!imageTexture) return; const step = Math.round(scale / ZOOM_STEP) * ZOOM_STEP; setZoom(step - ZOOM_STEP, null, null, true); }

        function startHold() {
            if (!imageTexture || isDragging) return;
            if (holdTimeout) clearTimeout(holdTimeout);
            isHolding = false;
            holdTimeout = setTimeout(() => {
                if (canvas.classList.contains('grabbing') && !isDragging) {
                    isHolding = true;
                    render();
                }
            }, 180);
        }
        function cancelHold() {
            if (holdTimeout) clearTimeout(holdTimeout);
            holdTimeout = null;
            if (isHolding) { isHolding = false; render(); }
        }

        function handleMouseDown(e) { 
            if (!imageTexture) return; 
            // Block interactions when any overlay/menu is open or if touching their content
            const target = e.target || e.touches?.[0]?.target;
            const blockerOpen = document.querySelector('.settings-menu-overlay.visible, .presets-menu-overlay.visible, .film-stock-menu-overlay.visible, .modal-overlay.visible');
            if (blockerOpen) return;
            // Check if the event target is within a popup menu or slider panel anyway
            if (target && (target.closest('.slider-panel') || target.closest('.settings-menu') || target.closest('.film-stock-menu') || target.closest('.presets-menu') || target.closest('.modal-overlay'))) {
                return; // Don't handle image pan/hold when interacting with menus
            }
            try { if (document.activeElement) document.activeElement.blur(); } catch(_){} 
            isDragging = false; 
            canvas.classList.add('grabbing'); 
            const rect = viewport.getBoundingClientRect(); 
            dragStartX = e.clientX - rect.left; 
            dragStartY = e.clientY - rect.top; 
            dragStartOffsetX = offsetX; 
            dragStartOffsetY = offsetY; 
            startHold(); 
            e.preventDefault(); 
        }
        function handleMouseMove(e) { const blockerOpen = document.querySelector('.settings-menu-overlay.visible, .presets-menu-overlay.visible, .film-stock-menu-overlay.visible, .modal-overlay.visible'); if (blockerOpen) return; if (!canvas.classList.contains('grabbing')) return; const currentX = e.clientX - viewport.getBoundingClientRect().left; const currentY = e.clientY - viewport.getBoundingClientRect().top; const deltaX = Math.abs(currentX - dragStartX); const deltaY = Math.abs(currentY - dragStartY); if (isHolding && (deltaX > 3 || deltaY > 3)) { cancelHold(); } if (deltaX > 5 || deltaY > 5 || isDragging) { if (!isDragging) { isDragging = true; cancelHold(); } offsetX = dragStartOffsetX + (currentX - dragStartX); offsetY = dragStartOffsetY + (currentY - dragStartY); updateTransform(false); } e.preventDefault(); }
        function handleMouseUp() { isDragging = false; canvas.classList.remove('grabbing'); cancelHold(); }
        function handleWheel(e) { if (!imageTexture) return; const blockerOpen = document.querySelector('.settings-menu-overlay.visible, .presets-menu-overlay.visible, .film-stock-menu-overlay.visible, .modal-overlay.visible'); if (blockerOpen) return; e.preventDefault(); const rect = viewport.getBoundingClientRect(); const mX = e.clientX - rect.left; const mY = e.clientY - rect.top; const delta = e.deltaY > 0 ? -0.1 : 0.1; setZoom(scale * (1 + delta), mX, mY, false); }

        function createShader(type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error("Shader compile error:", gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; }
        function createProgram(vs, fs) { const p = gl.createProgram(); gl.attachShader(p, createShader(gl.VERTEX_SHADER, vs)); gl.attachShader(p, createShader(gl.FRAGMENT_SHADER, fs)); gl.linkProgram(p); if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { console.error("Program link error:", gl.getProgramInfoLog(p)); gl.deleteProgram(p); return null; } return p; }
        
        const vertexShaderSource = `#version 300 es
            precision mediump float;
            in vec2 a_position;
            uniform vec4 u_sourceRect;
            uniform vec4 u_destRect;
            uniform vec4 u_fullUVRect;
            uniform vec2 u_fullResolution;      // resolution of the current source texture/FBO
            uniform vec2 u_viewportResolution;  // resolution of the current framebuffer/viewport
            uniform vec2 u_globalResolution;    // resolution of the full canvas for UVs across tiles
            out vec2 v_uv;
            out vec2 v_fullUV;
            void main() {
                vec2 uv = a_position * 0.5 + 0.5;
                // Sampling UV inside the current source
                v_uv = (u_sourceRect.xy + uv * u_sourceRect.zw) / u_fullResolution;
                // Full-canvas UV so overlays align across tiles; allow explicit rect override
                vec4 fullRect = u_fullUVRect;
                v_fullUV = (fullRect.xy + uv * fullRect.zw) / u_globalResolution;
                // Position within the current framebuffer
                vec2 pos = u_destRect.xy + uv * u_destRect.zw;
                vec2 clip_pos = (pos / u_viewportResolution) * 2.0 - 1.0;
                gl_Position = vec4(clip_pos, 0, 1);
            }`;




//
// ... inside the <script> block ...
//

        const fsLib = {
            triptychCompositor: `precision highp float;
                in vec2 v_uv;
                in vec2 v_fullUV;
                uniform sampler2D u_source; uniform sampler2D u_maskA; uniform sampler2D u_maskB; uniform sampler2D u_maskC; uniform sampler2D u_gateTexture;
                uniform float u_borderScale; uniform float u_imageScale;
                uniform vec2 u_canvasResolution; uniform vec2 u_sourceResolution; uniform vec2 u_borderResolution;
                uniform bool u_disableAC;
                uniform bool u_is8mmEngine;
                uniform float u_adjacentFrameDistance;
                uniform float u_framing;
                uniform float u_nativeSourceAspect; // long/short aspect of native image (>=1)
                uniform float u_framingLimit;       // scales the computed maxOffset to avoid revealing padding
                uniform vec2 u_zoneBDims;
                uniform float u_cheatAspectX;
                uniform float u_cheatAspectY;
                out vec4 c;

                vec4 sample_at(vec2 uv) {
                    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
                        return texture(u_source, uv);
                    }
                    return vec4(0.0);
                }

                void main() {
                    bool canvasIsPortrait = u_canvasResolution.y > u_canvasResolution.x;
                    float canvasAspect = u_canvasResolution.x / u_canvasResolution.y;

                    if (u_is8mmEngine) {
                        // --- 8mm Engine Path ---

                        // 1. Calculate all source and translation UVs first
                        float sourceAspect = u_sourceResolution.x / u_sourceResolution.y;
                        vec2 scaleToCoverSource = vec2(1.0);
                        if (canvasAspect > sourceAspect) { scaleToCoverSource.y = sourceAspect / canvasAspect; } else { scaleToCoverSource.x = canvasAspect / sourceAspect; }

                        vec2 covered_uv = (v_fullUV - 0.5) / scaleToCoverSource + 0.5;
                        vec2 pivotB = vec2(0.5, 0.5);
                        vec2 sourceUV_B = ((covered_uv - pivotB) / u_imageScale) + pivotB;
                        
                        vec2 image_size_in_uv = scaleToCoverSource / u_imageScale;
                        vec2 translation_uv_space = canvasIsPortrait ? vec2(image_size_in_uv.x, 0.0) : vec2(0.0, image_size_in_uv.y);
                        // Scale adjacent frame distance inversely by the short-edge cheat
                        float cheatShort = canvasIsPortrait ? u_cheatAspectX : u_cheatAspectY;
                        translation_uv_space *= (u_adjacentFrameDistance / cheatShort);
                        
                        vec2 sourceUV_L = sourceUV_B - translation_uv_space;
                        vec2 sourceUV_R = sourceUV_B + translation_uv_space;

                        // 2. Sample colors for each frame
                        vec4 colorB = sample_at(sourceUV_B);
                        vec4 colorL = sample_at(sourceUV_L);
                        vec4 colorR = sample_at(sourceUV_R);

                        // 3. Calculate gate UVs for each frame (main and translated)
                        vec2 finalBorderRes = u_borderResolution;
                        if (canvasIsPortrait) { finalBorderRes = vec2(u_borderResolution.y, u_borderResolution.x); }
                        float borderAspect = finalBorderRes.x / finalBorderRes.y;
                        vec2 scale = vec2(1.0);
                        if (canvasAspect > borderAspect) { scale.y = borderAspect / canvasAspect; } else { scale.x = canvasAspect / borderAspect; }

                        // The translation vector must be converted from image UV space to the global (v_fullUV) space
                        vec2 translation_v_fullUV = translation_uv_space * scaleToCoverSource;

                        vec2 gateUV_B_unrotated = (v_fullUV - 0.5) * scale / u_borderScale + 0.5;
                        vec2 gateUV_L_unrotated = ((v_fullUV - translation_v_fullUV) - 0.5) * scale / u_borderScale + 0.5;
                        vec2 gateUV_R_unrotated = ((v_fullUV + translation_v_fullUV) - 0.5) * scale / u_borderScale + 0.5;

                        vec2 gateUV_B = canvasIsPortrait ? vec2(gateUV_B_unrotated.y, 1.0 - gateUV_B_unrotated.x) : gateUV_B_unrotated;
                        vec2 gateUV_L = canvasIsPortrait ? vec2(gateUV_L_unrotated.y, 1.0 - gateUV_L_unrotated.x) : gateUV_L_unrotated;
                        vec2 gateUV_R = canvasIsPortrait ? vec2(gateUV_R_unrotated.y, 1.0 - gateUV_R_unrotated.x) : gateUV_R_unrotated;

                        // 4. Get the alpha for each frame from its corresponding translated position
                        float alpha_B = 1.0 - texture(u_gateTexture, gateUV_B).a;
                        float alpha_L = 1.0 - texture(u_gateTexture, gateUV_L).a;
                        float alpha_R = 1.0 - texture(u_gateTexture, gateUV_R).a;

                        // 5. PREMULTIPLY each frame with its own, correctly positioned alpha
                        vec4 premultipliedB = vec4(colorB.rgb * alpha_B, alpha_B);
                        vec4 premultipliedL = vec4(colorL.rgb * alpha_L, alpha_L);
                        vec4 premultipliedR = vec4(colorR.rgb * alpha_R, alpha_R);

                        // 6. Combine the premultiplied frames
                        c = max(premultipliedB, max(premultipliedL, premultipliedR));

                    } else {
                        // --- 35mm Triptych Engine Path (unchanged) ---
                        vec2 finalBorderRes = u_borderResolution;
                        if (canvasIsPortrait) { finalBorderRes = vec2(u_borderResolution.y, u_borderResolution.x); }
                        float borderAspect = finalBorderRes.x / finalBorderRes.y;
                        vec2 maskScale = vec2(1.0);
                        if (canvasAspect > borderAspect) { maskScale.y = borderAspect / canvasAspect; } else { maskScale.x = canvasAspect / borderAspect; }
                        vec2 maskUV = (v_fullUV - 0.5) * maskScale / u_borderScale + 0.5;
                        if (canvasIsPortrait) { maskUV = vec2(maskUV.y, 1.0 - maskUV.x); }
                        
                        float maskA_alpha = texture(u_maskA, maskUV).r;
                        float maskB_alpha = texture(u_maskB, maskUV).r;
                        float maskC_alpha = texture(u_maskC, maskUV).r;
                        
                        if (u_disableAC) { maskA_alpha = 0.0; maskC_alpha = 0.0; maskB_alpha = 1.0; }
                        if (maskA_alpha < 0.01) maskA_alpha = 0.0;
                        if (maskB_alpha < 0.01) maskB_alpha = 0.0;
                        if (maskC_alpha < 0.01) maskC_alpha = 0.0;
                        
                        float bSolid = maskB_alpha >= 0.5 ? 1.0 : 0.0;
                        maskA_alpha *= (1.0 - bSolid);
                        maskC_alpha *= (1.0 - bSolid);
                        
                        float sourceAspect = u_sourceResolution.x / u_sourceResolution.y;
                        vec2 scaleToCoverSource = vec2(1.0);
                        if (canvasAspect > sourceAspect) { scaleToCoverSource.y = sourceAspect / canvasAspect; } else { scaleToCoverSource.x = canvasAspect / sourceAspect; }
                        vec2 covered_uv = (v_fullUV - 0.5) / scaleToCoverSource + 0.5;
                        
                        // Calculate framing offset based on Zone B vs Image aspect ratios
                        // Use the actual Zone B dimensions for accurate framing calculations
                        float zoneBAspect = u_zoneBDims.x / u_zoneBDims.y;
                        vec2 framingOffset = vec2(0.0);
                        
                        // Normalize aspect ratios so long edge is always first for consistent cropping logic
                        float normalizedSourceAspect = max(u_nativeSourceAspect, 1.0);
                        float normalizedZoneBAspect = zoneBAspect >= 1.0 ? zoneBAspect : 1.0 / zoneBAspect;
                        
                        // Determine which dimension is being cropped and calculate framing
                        if (normalizedSourceAspect > normalizedZoneBAspect) {
                            // Source is wider than zone B - vertical cropping occurs, translate horizontally
                            float maxOffset = (1.0 - normalizedZoneBAspect / normalizedSourceAspect) * 0.5 * u_framingLimit;
                            if (canvasIsPortrait) {
                                // In portrait mode, swap X/Y translation
                                framingOffset.y = (u_framing - 1.0) * maxOffset;
                            } else {
                                // In landscape mode, use X axis for horizontal movement
                                framingOffset.x = (u_framing - 1.0) * maxOffset;
                            }
                        } else {
                            // Source is taller than zone B - horizontal cropping occurs, translate vertically
                            float maxOffset = (1.0 - normalizedSourceAspect / normalizedZoneBAspect) * 0.5 * u_framingLimit;
                            if (canvasIsPortrait) {
                                // In portrait mode, swap X/Y translation
                                framingOffset.x = (u_framing - 1.0) * maxOffset;
                            } else {
                                // In landscape mode, use Y axis for vertical movement
                                framingOffset.y = (u_framing - 1.0) * maxOffset;
                            }
                        }
                        
                        vec2 translationA = vec2(0.5, 0.0), translationC = vec2(-0.5, 0.0);
                        vec2 pivotA = vec2(1.0, 0.5), pivotC = vec2(0.0, 0.5), pivotB = vec2(0.5, 0.5);
                        if (canvasIsPortrait) {
                            translationA = vec2(0.0, 0.5); translationC = vec2(0.0, -0.5);
                            pivotA = vec2(0.5, 1.0); pivotC = vec2(0.5, 0.0);
                        }
                        vec2 sourceUV_B = ((covered_uv - pivotB) / u_imageScale) + pivotB + framingOffset;
                        vec2 sourceUV_A = ((covered_uv + translationA - pivotA) / u_imageScale) + pivotA + framingOffset;
                        vec2 sourceUV_C = ((covered_uv + translationC - pivotC) / u_imageScale) + pivotC + framingOffset;
                        
                        vec4 colorA = sample_at(sourceUV_A);
                        vec4 colorB = sample_at(sourceUV_B);
                        vec4 colorC = sample_at(sourceUV_C);
                        
                        c = max(max(colorA * maskA_alpha, colorB * maskB_alpha), colorC * maskC_alpha);
                    }
                }`,
            sprocketOverlay: `precision highp float; in vec2 v_uv; in vec2 v_fullUV; uniform sampler2D u_base; uniform sampler2D u_overlay; uniform float u_borderScale; uniform float u_sprocketScale; uniform float u_sprocketSizeScale; uniform vec2 u_canvasResolution; uniform vec2 u_borderResolution; uniform float u_sprocketContrast; uniform bool u_extendEdges; out vec4 c; vec3 hardLight(vec3 base, vec3 blend){ return mix( 2.0*base*blend, 1.0-2.0*(1.0-base)*(1.0-blend), step(0.5, blend) ); } void main() { vec2 finalBorderRes = u_borderResolution; bool canvasIsPortrait = u_canvasResolution.y > u_canvasResolution.x; if (canvasIsPortrait) { finalBorderRes = vec2(u_borderResolution.y, u_borderResolution.x); } float canvasAspect = u_canvasResolution.x / u_canvasResolution.y; float borderAspect = finalBorderRes.x / finalBorderRes.y; vec2 scale = vec2(1.0); if (canvasAspect > borderAspect) { scale.y = borderAspect / canvasAspect; } else { scale.x = canvasAspect / borderAspect; } vec2 uv = (v_fullUV - 0.5) * scale / (u_borderScale * u_sprocketSizeScale) + 0.5; float translationAmount = (u_sprocketScale - 1.0); if (canvasIsPortrait) { uv = vec2(uv.y, 1.0 - uv.x); uv.x += translationAmount; } else { uv.x += translationAmount; }
                vec4 baseColor = texture(u_base, v_uv);
                vec4 overlayColor = vec4(0.0);
                if (u_extendEdges) {
                    vec2 uvc = clamp(uv, vec2(0.0), vec2(1.0));
                    overlayColor = texture(u_overlay, uvc);
                } else {
                    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
                        overlayColor = texture(u_overlay, uv);
                    }
                }
                if (u_sprocketContrast > 1.0) { float contrast = u_sprocketContrast - 1.0; vec3 contrasted = overlayColor.rgb * overlayColor.rgb * (3.0 - 2.0 * overlayColor.rgb); overlayColor.rgb = mix(overlayColor.rgb, contrasted, contrast); } else { overlayColor.rgb = mix(vec3(0.5), overlayColor.rgb, u_sprocketContrast); }
                vec3 blended = hardLight(baseColor.rgb, overlayColor.rgb); c = vec4(mix(baseColor.rgb, blended, overlayColor.a), 1.0); }`,
            borderOverlay: `precision highp float; in vec2 v_uv; in vec2 v_fullUV; uniform sampler2D u_base; uniform sampler2D u_border; uniform vec3 u_minPixelValue; uniform float u_borderScale; uniform float u_cheatAspectX; uniform float u_cheatAspectY; uniform vec2 u_canvasResolution; uniform vec2 u_borderResolution; out vec4 c; vec3 ACES(vec3 x) { return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0); } vec3 ACES_Inv(vec3 x) { x = clamp(x, 0.0, 0.9999); return (sqrt(max(vec3(0.0), -10127.0 * x * x + 13702.0 * x + 9.0)) + 59.0 * x - 3.0) / (502.0 - 486.0 * x); } void main() { vec2 finalBorderRes = u_borderResolution; bool canvasIsPortrait = u_canvasResolution.y > u_canvasResolution.x; if (canvasIsPortrait) { finalBorderRes = vec2(u_borderResolution.y, u_borderResolution.x); } float canvasAspect = u_canvasResolution.x / u_canvasResolution.y; float borderAspect = finalBorderRes.x / finalBorderRes.y; vec2 scale = vec2(1.0); if (canvasAspect > borderAspect) { scale.y = borderAspect / canvasAspect; } else { scale.x = canvasAspect / borderAspect; } 
                
                // Apply cheat aspect X to the width and Y to the height
                scale.x *= u_cheatAspectX;
                scale.y *= u_cheatAspectY;
                
                vec2 uv = (v_fullUV - 0.5) * scale / u_borderScale + 0.5; if (canvasIsPortrait) { uv = vec2(uv.y, 1.0 - uv.x); } vec3 baseColor = texture(u_base, v_uv).rgb; vec4 rawBorder = vec4(0.0); if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) { rawBorder = texture(u_border, uv); } vec3 premultipliedColor = u_minPixelValue * rawBorder.a; vec3 linearBase = ACES_Inv(pow(baseColor, vec3(2.2))); vec3 linearBorder = ACES_Inv(pow(premultipliedColor, vec3(2.2))); vec3 linearBlended = linearBase * (1.0 - rawBorder.a) + linearBorder; vec3 finalRgb = pow(ACES(linearBlended), vec3(1.0 / 2.2)); c = vec4(clamp(finalRgb, 0.0, 1.0), 1.0); }`,
            borderOverlay8mm: `precision highp float; in vec2 v_uv; in vec2 v_fullUV; uniform sampler2D u_base; uniform vec3 u_minPixelValue; out vec4 c; vec3 ACES(vec3 x) { return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0); } vec3 ACES_Inv(vec3 x) { x = clamp(x, 0.0, 0.9999); return (sqrt(max(vec3(0.0), -10127.0 * x * x + 13702.0 * x + 9.0)) + 59.0 * x - 3.0) / (502.0 - 486.0 * x); } void main() { 
                vec4 premultipliedImage = texture(u_base, v_uv);
                vec3 linearImageRgb = ACES_Inv(pow(premultipliedImage.rgb, vec3(2.2)));
                vec3 linearBg = ACES_Inv(pow(u_minPixelValue, vec3(2.2)));
                vec3 linearComposite = linearImageRgb + linearBg * (1.0 - premultipliedImage.a);
                vec3 finalRgb = pow(ACES(linearComposite), vec3(1.0 / 2.2));
                c = vec4(clamp(finalRgb, 0.0, 1.0), 1.0);
            }`,
// ... inside the const fsLib = { ... }; block

        borderComposite8mm: `precision highp float;
            in vec2 v_uv;
            in vec2 v_fullUV;

            uniform sampler2D u_source;
            uniform sampler2D u_gateTexture;
            uniform vec3 u_minPixelValue;
            uniform float u_borderScale;
            uniform float u_imageScale;
            uniform float u_adjacentFrameDistance;
            uniform float u_framing;
            uniform float u_nativeSourceAspect;
            uniform float u_framingLimit;
            uniform vec2 u_canvasResolution;
            uniform vec2 u_sourceResolution;
            uniform vec2 u_borderResolution;
            uniform float u_cheatAspectX;
            uniform float u_cheatAspectY;
            
            out vec4 c;

            // --- Constants & Helpers ---
            uniform vec2 u_zoneBDims; // The pixel dimensions of ZoneB inside the border texture
            vec3 ACES(vec3 x) { return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0); }
            vec3 ACES_Inv(vec3 x) { x = clamp(x, 0.0, 0.9999); return (sqrt(max(vec3(0.0), -10127.0 * x * x + 13702.0 * x + 9.0)) + 59.0 * x - 3.0) / (502.0 - 486.0 * x); }
            vec4 sample_at(sampler2D tex, vec2 uv) {
                return (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) ? texture(tex, uv) : vec4(0.0);
            }

            void main() {
                // --- 1. Coordinate & Scale Calculation ---
                bool canvasIsPortrait = u_canvasResolution.y > u_canvasResolution.x;
                float canvasAspect = u_canvasResolution.x / u_canvasResolution.y;
                vec2 finalBorderRes = u_borderResolution;
                
                // <<< START OF FINAL, CORRECTED LOGIC >>>
                // Part A: Calculate the scaling for TEXTURE MAPPING.
                // This logic is proven to work correctly for preventing stretching in all orientations.
                vec2 finalGateRes = finalBorderRes;
                if (canvasIsPortrait) { finalGateRes = vec2(finalBorderRes.y, finalBorderRes.x); }
                float gateAspect = finalGateRes.x / finalGateRes.y;
                vec2 gateUvScale = vec2(1.0);
                if (canvasAspect > gateAspect) {
                    gateUvScale.y = gateAspect / canvasAspect;
                } else {
                    gateUvScale.x = canvasAspect / gateAspect;
                }
                
                // Apply cheat aspect X and Y directly to the respective dimensions
                gateUvScale.x *= u_cheatAspectX;
                gateUvScale.y *= u_cheatAspectY;

                // Part B: Calculate the physical OFFSET DISTANCE.
                // This still uses the normalized logic to find the true on-screen size.
                float normCanvasAspect = canvasIsPortrait ? (u_canvasResolution.y / u_canvasResolution.x) : canvasAspect;
                float normBorderAspect = finalBorderRes.x / finalBorderRes.y;
                vec2 scaleToFitBorder = vec2(1.0);
                if (normCanvasAspect > normBorderAspect) {
                    scaleToFitBorder.y = normBorderAspect / normCanvasAspect;
                } else {
                    scaleToFitBorder.x = normCanvasAspect / normBorderAspect;
                }
                
                vec2 zoneB_uv_size = u_zoneBDims / u_borderResolution;
                
                // Calculate the adjacent frame distance
                // The shader will apply appropriate cheat aspect scaling based on orientation
                
                // Calculate the base distance using the current zoneB dimensions
                float onScreen_shortEdge_size = (zoneB_uv_size.y * u_borderScale) / scaleToFitBorder.y;
                
                // Scale adjacent frame distance inversely by the short-edge cheat
                float cheatShort = canvasIsPortrait ? u_cheatAspectX : u_cheatAspectY;
                float offset_dist = onScreen_shortEdge_size * (u_adjacentFrameDistance / cheatShort);
                vec2 v_fullUV_offset = canvasIsPortrait ? vec2(offset_dist, 0.0) : vec2(0.0, offset_dist);
                // <<< END OF FINAL, CORRECTED LOGIC >>>
                
                // --- 3. Calculate UVs for all 3 frames ---
                vec2 v_fullUV_B = v_fullUV;
                vec2 v_fullUV_L = v_fullUV - v_fullUV_offset;
                vec2 v_fullUV_R = v_fullUV + v_fullUV_offset;

                vec2 gateUV_unrotated_B = (v_fullUV_B - 0.5) * gateUvScale / u_borderScale + 0.5;
                vec2 gateUV_unrotated_L = (v_fullUV_L - 0.5) * gateUvScale / u_borderScale + 0.5;
                vec2 gateUV_unrotated_R = (v_fullUV_R - 0.5) * gateUvScale / u_borderScale + 0.5;

                vec2 gateUV_B = canvasIsPortrait ? vec2(gateUV_unrotated_B.y, 1.0 - gateUV_unrotated_B.x) : gateUV_unrotated_B;
                vec2 gateUV_L = canvasIsPortrait ? vec2(gateUV_unrotated_L.y, 1.0 - gateUV_unrotated_L.x) : gateUV_unrotated_L;
                vec2 gateUV_R = canvasIsPortrait ? vec2(gateUV_unrotated_R.y, 1.0 - gateUV_unrotated_R.x) : gateUV_unrotated_R;

                float sourceAspect = u_sourceResolution.x / u_sourceResolution.y;
                vec2 scaleToCoverSource = vec2(1.0);
                if (canvasAspect > sourceAspect) { scaleToCoverSource.y = sourceAspect / canvasAspect; } else { scaleToCoverSource.x = canvasAspect / sourceAspect; }
                
                // Calculate framing offset based on Zone B vs Image aspect ratios
                float zoneBAspect = u_zoneBDims.x / u_zoneBDims.y;
                // Normalize aspect ratios so long edge is always first for consistent cropping logic
                float normalizedSourceAspect = max(u_nativeSourceAspect, 1.0);
                float normalizedZoneBAspect = zoneBAspect >= 1.0 ? zoneBAspect : 1.0 / zoneBAspect;
                vec2 framingOffset = vec2(0.0);
                
                // Determine which dimension is being cropped and calculate framing
                if (normalizedSourceAspect > normalizedZoneBAspect) {
                    // Source is wider than zone B - vertical cropping occurs, translate horizontally
                    float maxOffset = (1.0 - normalizedZoneBAspect / normalizedSourceAspect) * 0.5 * u_framingLimit;
                    if (canvasIsPortrait) {
                        // In portrait mode, swap X/Y translation
                        framingOffset.y = (u_framing - 1.0) * maxOffset;
                    } else {
                        // In landscape mode, use X axis for horizontal movement
                        framingOffset.x = (u_framing - 1.0) * maxOffset;
                    }
                } else {
                    // Source is taller than zone B - horizontal cropping occurs, translate vertically
                    float maxOffset = (1.0 - normalizedSourceAspect / normalizedZoneBAspect) * 0.5 * u_framingLimit;
                    if (canvasIsPortrait) {
                        // In portrait mode, swap X/Y translation
                        framingOffset.x = (u_framing - 1.0) * maxOffset;
                    } else {
                        // In landscape mode, use Y axis for vertical movement
                        framingOffset.y = (u_framing - 1.0) * maxOffset;
                    }
                }
                
                // Calculate the sourceUVs first
                vec2 sourceUV_B = (((v_fullUV_B - 0.5) / scaleToCoverSource + 0.5) - vec2(0.5)) / u_imageScale + vec2(0.5);
                vec2 sourceUV_L = (((v_fullUV_L - 0.5) / scaleToCoverSource + 0.5) - vec2(0.5)) / u_imageScale + vec2(0.5);
                vec2 sourceUV_R = (((v_fullUV_R - 0.5) / scaleToCoverSource + 0.5) - vec2(0.5)) / u_imageScale + vec2(0.5);
                
                // Apply framing offset to the scaled UVs (like the working version)
                sourceUV_B += framingOffset;
                sourceUV_L += framingOffset;
                sourceUV_R += framingOffset;

                // --- 4. Sample Alphas and Colors for all 3 frames ---
                float alpha_B = 1.0 - texture(u_gateTexture, clamp(gateUV_B, 0.0, 1.0)).a;
                float alpha_L = 1.0 - texture(u_gateTexture, clamp(gateUV_L, 0.0, 1.0)).a;
                float alpha_R = 1.0 - texture(u_gateTexture, clamp(gateUV_R, 0.0, 1.0)).a;

                vec3 color_B = sample_at(u_source, sourceUV_B).rgb;
                vec3 color_L = sample_at(u_source, sourceUV_L).rgb;
                vec3 color_R = sample_at(u_source, sourceUV_R).rgb;
                
                // --- 5. Composite in Linear Space (Correct "Over" operation) ---
                vec3 linearBg = ACES_Inv(pow(u_minPixelValue, vec3(2.2)));
                
                vec3 subtracted_B = ACES_Inv(pow(color_B, vec3(2.2))) - linearBg;
                vec3 subtracted_L = ACES_Inv(pow(color_L, vec3(2.2))) - linearBg;
                vec3 subtracted_R = ACES_Inv(pow(color_R, vec3(2.2))) - linearBg;

                vec3 premultiplied_B = subtracted_B * alpha_B;
                vec3 premultiplied_L = subtracted_L * alpha_L;
                vec3 premultiplied_R = subtracted_R * alpha_R;
                
                vec3 finalLinear = linearBg + premultiplied_B + premultiplied_L + premultiplied_R;

                // --- 6. Convert Final Composite back to sRGB ---
                vec3 finalSrgb = pow(ACES(finalLinear), vec3(1.0 / 2.2));
                c = vec4(clamp(finalSrgb, 0.0, 1.0), 1.0);
            }`,
            borderComposite35add: `precision highp float;
            in vec2 v_uv;
            in vec2 v_fullUV;

            uniform sampler2D u_source;
            uniform sampler2D u_gateTexture;
            uniform vec3 u_minPixelValue;
            uniform float u_borderScale;
            uniform float u_imageScale;
            uniform float u_adjacentFrameDistance;
            uniform float u_framing;
            uniform float u_nativeSourceAspect;
            uniform float u_framingLimit;
            uniform vec2 u_canvasResolution;
            uniform vec2 u_sourceResolution;
            uniform vec2 u_borderResolution;
            uniform float u_cheatAspectX;
            uniform float u_cheatAspectY;
            uniform vec2 u_zoneBDims;
            out vec4 c;

            vec3 ACES(vec3 x) { return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0); }
            vec3 ACES_Inv(vec3 x) { x = clamp(x, 0.0, 0.9999); return (sqrt(max(vec3(0.0), -10127.0 * x * x + 13702.0 * x + 9.0)) + 59.0 * x - 3.0) / (502.0 - 486.0 * x); }
            vec4 sample_at(sampler2D tex, vec2 uv) { return (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) ? texture(tex, uv) : vec4(0.0); }

            void main() {
                // Orientation flags
                bool canvasIsPortrait = u_canvasResolution.y > u_canvasResolution.x;
                float canvasAspect = u_canvasResolution.x / u_canvasResolution.y;

                // Gate texture mapping scale (preserve 35mm stills geometry, including cheat X/Y)
                vec2 finalBorderRes = u_borderResolution;
                if (canvasIsPortrait) { finalBorderRes = vec2(u_borderResolution.y, u_borderResolution.x); }
                float gateAspect = finalBorderRes.x / finalBorderRes.y;
                vec2 gateUvScale = vec2(1.0);
                if (canvasAspect > gateAspect) { gateUvScale.y = gateAspect / canvasAspect; } else { gateUvScale.x = canvasAspect / gateAspect; }
                gateUvScale.x *= u_cheatAspectX;
                gateUvScale.y *= u_cheatAspectY;

                // Image cover scale
                float sourceAspect = u_sourceResolution.x / u_sourceResolution.y;
                vec2 scaleToCoverSource = vec2(1.0);
                if (canvasAspect > sourceAspect) { scaleToCoverSource.y = sourceAspect / canvasAspect; } else { scaleToCoverSource.x = canvasAspect / sourceAspect; }

                // Framing within Zone B (uses provided zoneBDims for 35mm stills geometry)
                float zoneBAspect = u_zoneBDims.x / u_zoneBDims.y;
                float normalizedSourceAspect = max(u_nativeSourceAspect, 1.0);
                float normalizedZoneBAspect = zoneBAspect >= 1.0 ? zoneBAspect : 1.0 / zoneBAspect;
                vec2 framingOffset = vec2(0.0);
                if (normalizedSourceAspect > normalizedZoneBAspect) {
                    float maxOffset = (1.0 - normalizedZoneBAspect / normalizedSourceAspect) * 0.5 * u_framingLimit;
                    if (canvasIsPortrait) { framingOffset.y = (u_framing - 1.0) * maxOffset; }
                    else { framingOffset.x = (u_framing - 1.0) * maxOffset; }
                } else {
                    float maxOffset = (1.0 - normalizedSourceAspect / normalizedZoneBAspect) * 0.5 * u_framingLimit;
                    if (canvasIsPortrait) { framingOffset.x = (u_framing - 1.0) * maxOffset; }
                    else { framingOffset.y = (u_framing - 1.0) * maxOffset; }
                }

                // Base source UVs for B/L/R derived from v_fullUV positions (matches 8mm logic)
                vec2 v_fullUV_B = v_fullUV;
                vec2 covered_uv_B = (v_fullUV_B - 0.5) / scaleToCoverSource + 0.5;
                vec2 sourceUV_B = (((covered_uv_B - vec2(0.5)) / u_imageScale) + vec2(0.5)) + framingOffset;

                // Use the same proven logic as the 8mm engine for consistent behavior
                float normCanvasAspect = canvasIsPortrait ? (u_canvasResolution.y / u_canvasResolution.x) : canvasAspect;
                float normBorderAspect = u_borderResolution.x / u_borderResolution.y;
                vec2 scaleToFitBorder = vec2(1.0);
                if (normCanvasAspect > normBorderAspect) {
                    scaleToFitBorder.y = normBorderAspect / normCanvasAspect;
                } else {
                    scaleToFitBorder.x = normCanvasAspect / normBorderAspect;
                }
                
                vec2 zoneB_uv_size = u_zoneBDims / u_borderResolution;
                
                // Calculate the adjacent frame distance using zoneB long edge
                // Since 35mm additive places frames along SHORT edge, use LONG edge for spacing
                float onScreen_longEdge_size = (zoneB_uv_size.x * u_borderScale) / scaleToFitBorder.x;
                
                // Scale adjacent frame distance by the long-edge cheat (opposite of cine engines)
                float cheatLong = canvasIsPortrait ? u_cheatAspectY : u_cheatAspectX;
                float offset_dist = onScreen_longEdge_size * (u_adjacentFrameDistance / cheatLong);
                
                // For 35mm additive: adjacent frames along SHORT edge (opposite of cine engines)
                vec2 v_fullUV_offset = canvasIsPortrait ? vec2(0.0, offset_dist) : vec2(offset_dist, 0.0);
                vec2 v_fullUV_L_img = v_fullUV - v_fullUV_offset;
                vec2 v_fullUV_R_img = v_fullUV + v_fullUV_offset;

                // Gate UVs use the same offset pattern
                vec2 v_fullUV_L_gate = v_fullUV_L_img;
                vec2 v_fullUV_R_gate = v_fullUV_R_img;
                vec2 gateUV_B = (v_fullUV - 0.5) * gateUvScale / u_borderScale + 0.5;
                vec2 gateUV_L = (v_fullUV_L_gate - 0.5) * gateUvScale / u_borderScale + 0.5;
                vec2 gateUV_R = (v_fullUV_R_gate - 0.5) * gateUvScale / u_borderScale + 0.5;
                if (canvasIsPortrait) { gateUV_B = vec2(gateUV_B.y, 1.0 - gateUV_B.x); gateUV_L = vec2(gateUV_L.y, 1.0 - gateUV_L.x); gateUV_R = vec2(gateUV_R.y, 1.0 - gateUV_R.x); }

                // Source UVs for left/right using the rotated-space horizontal offsets
                vec2 v_fullUV_L = v_fullUV_L_img;
                vec2 v_fullUV_R = v_fullUV_R_img;
                vec2 covered_uv_L = (v_fullUV_L - 0.5) / scaleToCoverSource + 0.5;
                vec2 covered_uv_R = (v_fullUV_R - 0.5) / scaleToCoverSource + 0.5;
                vec2 sourceUV_L = (((covered_uv_L - vec2(0.5)) / u_imageScale) + vec2(0.5)) + framingOffset;
                vec2 sourceUV_R = (((covered_uv_R - vec2(0.5)) / u_imageScale) + vec2(0.5)) + framingOffset;

                // Sample colors
                vec3 color_B = sample_at(u_source, sourceUV_B).rgb;
                vec3 color_L = sample_at(u_source, sourceUV_L).rgb;
                vec3 color_R = sample_at(u_source, sourceUV_R).rgb;

                // Alphas from gate texture
                float alpha_B = 1.0 - texture(u_gateTexture, clamp(gateUV_B, 0.0, 1.0)).a;
                float alpha_L = 1.0 - texture(u_gateTexture, clamp(gateUV_L, 0.0, 1.0)).a;
                float alpha_R = 1.0 - texture(u_gateTexture, clamp(gateUV_R, 0.0, 1.0)).a;

                // Linearize and subtract background (min pixel value)
                vec3 linearBg = ACES_Inv(pow(u_minPixelValue, vec3(2.2)));
                vec3 subtracted_B = ACES_Inv(pow(color_B, vec3(2.2))) - linearBg;
                vec3 subtracted_L = ACES_Inv(pow(color_L, vec3(2.2))) - linearBg;
                vec3 subtracted_R = ACES_Inv(pow(color_R, vec3(2.2))) - linearBg;

                // Premultiply by alphas
                vec3 premultiplied_B = subtracted_B * alpha_B;
                vec3 premultiplied_L = subtracted_L * alpha_L;
                vec3 premultiplied_R = subtracted_R * alpha_R;

                // Add over solid background and then add back sampled black level
                vec3 finalLinear = linearBg + premultiplied_B + premultiplied_L + premultiplied_R;
                vec3 finalSrgb = pow(ACES(finalLinear), vec3(1.0 / 2.2));
                c = vec4(clamp(finalSrgb, 0.0, 1.0), 1.0);
            }`,

// ... The rest of the fsLib object continues here ...```

            grain: `precision highp float; 
            in vec2 v_uv; 
            in vec2 v_fullUV; 
            uniform sampler2D u_base,u_grain,u_dust; 
            uniform bool u_dustEnabled; 
            uniform float u_intensity; 
            uniform float u_grainScale; 
            uniform float u_grainSaturation; 
            uniform float u_reduceShadows;
            uniform float u_shadowSat;
            uniform float u_reduceHighlights;
            uniform float u_highlightSat;
            uniform vec2 u_canvasResolution,u_sourceResolution; 
            uniform float u_imageScale; 
            uniform vec2 u_dustOffset; 
            uniform float u_dustRotation; 
            const float PI=3.14159265359; 
            const vec3 lumCoeff=vec3(0.299,0.587,0.114); 
            out vec4 c; 
            
            void main(){ 
                vec3 b=texture(u_base,v_uv).rgb; 
                float canvasAspect=u_canvasResolution.x/u_canvasResolution.y; 
                float sourceAspect=u_sourceResolution.x/u_sourceResolution.y; 
                vec2 scaleToCoverSource=vec2(1.0); 
                if(canvasAspect>sourceAspect){ 
                    scaleToCoverSource.y=sourceAspect/canvasAspect; 
                } else { 
                    scaleToCoverSource.x=canvasAspect/sourceAspect; 
                } 
                vec2 covered_uv=(v_fullUV-0.5)/scaleToCoverSource+0.5; 
                covered_uv=((covered_uv-0.5)/u_imageScale)+0.5; 
                
                // One tile across long edge when grainScale=1
                float repeatsLong = 1.0 / max(u_grainScale, 1e-5); 
                vec2 repeats = (sourceAspect >= 1.0) ? vec2(repeatsLong, repeatsLong / sourceAspect) : vec2(repeatsLong * sourceAspect, repeatsLong); 
                vec2 gUV = covered_uv * repeats; 
                vec3 gE=(texture(u_grain,gUV).rgb-0.5)*2.0; 
                
                // Create highlight and shadow masks from the base image
                float minRGB = min(b.r, min(b.g, b.b));
                
                // Highlight mask: ((min(r,g,b))-0.2) / (1-0.2)
                float highlightMask = clamp((minRGB - 0.2) / (1.0 - 0.2), 0.0, 1.0);
                
                // Shadow mask: 1-(min(r,g,b))/0.18
                float shadowMask = clamp(1.0 - (minRGB / 0.18), 0.0, 1.0);
                
                // Apply saturation adjustments to grain
                float lum=dot(gE,lumCoeff); 
                vec3 gray=vec3(lum);
                
                // Create separate saturation adjustments for highlights and shadows
                vec3 grainHighlightSat = mix(gray, gE, u_highlightSat);
                vec3 grainShadowSat = mix(gray, gE, u_shadowSat);
                vec3 grainNormalSat = mix(gray, gE, u_grainSaturation);
                
                // Blend between different saturation levels based on masks
                vec3 grainWithSat = grainNormalSat;
                grainWithSat = mix(grainWithSat, grainHighlightSat, highlightMask);
                grainWithSat = mix(grainWithSat, grainShadowSat, shadowMask);
                
                // Apply intensity
                vec3 fO = grainWithSat * u_intensity;
                
                // Create masking for grain reduction
                // Reduce grain in highlights and shadows based on slider values
                float grainMask = 1.0;
                grainMask *= (1.0 - (u_reduceHighlights * highlightMask));
                grainMask *= (1.0 - (u_reduceShadows * shadowMask));
                
                // Apply the mask to the grain effect
                fO *= grainMask;
                
                if(u_dustEnabled){ 
                    vec2 p=vec2(0.5); 
                    float a=(u_dustRotation-1.0)*2.0*PI; 
                    float s=sin(a); 
                    float cs=cos(a); 
                    mat2 rM=mat2(cs,-s,s,cs); 
                    vec2 tUV=rM*(covered_uv+u_dustOffset-p)+p; 
                    vec2 dUV=tUV*repeats; 
                    vec3 dE=texture(u_dust,dUV).rgb; 
                    fO+=dE; 
                } 
                c=vec4(clamp(b+fO,0.0,1.0),1.0); 
            }`,
            solidColor: `precision highp float; in vec2 v_uv; uniform vec3 u_color; out vec4 c; void main() { c = vec4(u_color, 1.0); }`,
            curves: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform sampler2D u_lut; out vec4 c; void main() { vec3 color = texture(u_image, v_uv).rgb; color.r = texture(u_lut, vec2(color.r, 0.5)).r; color.g = texture(u_lut, vec2(color.g, 0.5)).g; color.b = texture(u_lut, vec2(color.b, 0.5)).b; c = vec4(color, 1.0); }`,
            passthrough: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; out vec4 c; void main(){c=texture(u_image,v_uv);}`,
            mulRGB: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform vec3 u_mul; out vec4 c; void main(){ vec4 t = texture(u_image, v_uv); c = vec4(clamp(t.rgb * u_mul, 0.0, 1.0), 1.0); }`,
            separableBlur: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform vec2 u_texelSize; uniform float u_blurRadius; uniform vec2 u_direction; out vec4 c; void main(){float s=u_blurRadius*0.5;float tS2=2.0*s*s;int k=min(70,max(1,int(ceil(s*3.0))));vec4 r=vec4(0.0);float tW=0.0;for(int i=-k;i<=k;i++){float oV=float(i);vec2 o=u_direction*oV*u_texelSize;float d2=oV*oV;float w=exp(-d2/tS2);r+=texture(u_image,v_uv+o)*w;tW+=w;}c=r/tW;}`,
                        gaussianST: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform vec2 u_step; uniform float u_sigma; uniform float u_radius; uniform float u_lod; out vec4 c; void main(){ float invTwoSigmaSqr = 1.0 / (2.0 * u_sigma * u_sigma); vec4 acc = textureLod(u_image, v_uv, 0.0); float sumW = 1.0;
            
            // Adaptive LOD and step size for smooth large radius blurs
            float actualLod = u_lod;
            
            // For very large radii, use a hybrid approach
            if (u_radius > 48.0) {
                actualLod = 0.0; // Disable LOD for precision
            }
            
            // Use optimal sample count based on radius
            float maxSamples = min(96.0, u_radius);
            float stepSize = max(1.0, u_radius / 64.0); // Adaptive step size
            
            for (float i = stepSize; i <= maxSamples; i += stepSize) { 
                if (i >= u_radius) break; 
                float w = exp(-(i*i) * invTwoSigmaSqr); 
                vec2 d = u_step * i; 
                vec4 s = textureLod(u_image, v_uv + d, actualLod) + textureLod(u_image, v_uv - d, actualLod);
                acc += s * w; 
                sumW += 2.0 * w; 
            } 
            acc /= max(sumW, 1e-6); c = acc; }`,
            lumaPremultiply: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform float u_gain; out vec4 c; void main(){ vec4 t = texture(u_image, v_uv); vec3 s = clamp(t.rgb * u_gain, 0.0, 1.0); float a = (s.r + s.g + s.b) / 3.0; c = vec4(s * a, a); }`,
            // Apply threshold gain to image before keying
            applyThresholdGain: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform float u_gain; out vec4 c; void main(){ vec4 t = texture(u_image, v_uv); c = vec4(clamp(t.rgb * u_gain, 0.0, 1.0), t.a); }`,
            // Luma key and premultiply (no gain applied here)
            lumaPremultiplyNoGain: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; out vec4 c; void main(){ vec4 t = texture(u_image, v_uv); float a = (t.r + t.g + t.b) / 3.0; c = vec4(t.rgb * a, a); }`,
            // Premultiply original color by a separate key texture's red channel
            premultiplyWithKey: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform sampler2D u_key; uniform float u_gain; out vec4 c; void main(){ vec3 color = texture(u_image, v_uv).rgb; float key = texture(u_key, v_uv).r; float a = clamp(key * u_gain, 0.0, 1.0); vec3 s = clamp(color * u_gain, 0.0, 1.0); c = vec4(s * a, a); }`,
            // Premultiply with key but no gain applied (gain applied earlier)
            premultiplyWithKeyNoGain: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform sampler2D u_key; out vec4 c; void main(){ vec3 color = texture(u_image, v_uv).rgb; float key = texture(u_key, v_uv).r; c = vec4(color * key, key); }`,
            // Min desaturate and premultiply by key - outputs min(r,g,b) as RGB
            minDesatPremultiplyWithKey: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform sampler2D u_key; out vec4 c; void main(){ vec3 color = texture(u_image, v_uv).rgb; float key = texture(u_key, v_uv).r; float minVal = min(color.r, min(color.g, color.b)); vec3 desatColor = vec3(minVal); c = vec4(desatColor * key, key); }`,
            // Conditional RGB output based on useMinRgb flag - either original RGB or modified min(r,g,b) as RGB
            conditionalRgbPremultiplyWithKey: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform sampler2D u_key; uniform bool u_useMinRgb; uniform bool u_usePremultiply; uniform float u_thresholdGamma; uniform float u_thresholdWhite; out vec4 c; void main(){ vec3 color = texture(u_image, v_uv).rgb; float key = texture(u_key, v_uv).r; vec3 outputRgb; if (u_useMinRgb) { float m = min(color.r, min(color.g, color.b)); float result = pow((m / u_thresholdWhite), (1.0 / u_thresholdGamma)) * u_thresholdWhite; outputRgb = vec3(result); } else { outputRgb = color; } if (u_usePremultiply) { c = vec4(outputRgb * key, key); } else { c = vec4(outputRgb, 1.0); } }`,
            // Threshold visualization shader - shows hard cutoff at 1.0 linear value for preview (debug)
            thresholdVisualize: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; out vec4 c; void main(){ vec4 pixel = texture(u_image, v_uv); const float threshold = 1.0; vec3 result = vec3(0.0); if (pixel.r >= threshold) result.r = 1.0; if (pixel.g >= threshold) result.g = 1.0; if (pixel.b >= threshold) result.b = 1.0; c = vec4(result, 1.0); }`,
            highPass: `precision highp float; in vec2 v_uv; uniform sampler2D u_original,u_blurred; out vec4 c;void main(){c=vec4(texture(u_original,v_uv).rgb-texture(u_blurred,v_uv).rgb+0.5,1.0);}`,
            overlayBlend: `precision highp float; in vec2 v_uv; uniform sampler2D u_base,u_overlay; uniform float u_opacity; out vec4 c;vec3 overlay(vec3 b,vec3 B){return vec3(b.r<0.5?2.0*b.r*B.r:1.0-2.0*(1.0-b.r)*(1.0-B.r),b.g<0.5?2.0*b.g*B.g:1.0-2.0*(1.0-b.g)*(1.0-B.g),b.b<0.5?2.0*b.b*B.b:1.0-2.0*(1.0-b.b)*(1.0-B.b));}void main(){vec3 bC=texture(u_base,v_uv).rgb;c=vec4(mix(bC,overlay(bC,texture(u_overlay,v_uv).rgb),u_opacity),1.0);}`,
            add: `precision highp float; in vec2 v_uv; uniform sampler2D u_base, u_overlay; out vec4 c; void main() { c = texture(u_base, v_uv) + texture(u_overlay, v_uv); }`,
            screen: `precision highp float; in vec2 v_uv; uniform sampler2D u_base, u_overlay; out vec4 c; void main() { vec3 base = clamp(texture(u_base, v_uv).rgb, 0.0, 1.0); vec3 overlay = clamp(texture(u_overlay, v_uv).rgb, 0.0, 1.0); vec3 result = 1.0 - (1.0 - base) * (1.0 - overlay); c = vec4(clamp(result, 0.0, 1.0), 1.0); }`,
            srgbToLinear: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform bool u_enableWhiteComp; uniform vec3 u_whitePointSrgb; out vec4 c; vec3 ACES_Inv(vec3 x) { x = clamp(x, 0.0, 0.9999); return (sqrt(max(vec3(0.0), -10127.0 * x * x + 13702.0 * x + 9.0)) + 59.0 * x - 3.0) / (502.0 - 486.0 * x); } void main() { vec3 srgb = texture(u_image, v_uv).rgb; if (u_enableWhiteComp) { srgb = srgb / max(u_whitePointSrgb, vec3(1e-6)); } vec3 linear = ACES_Inv(pow(srgb, vec3(2.2))); c = vec4(linear, 1.0); }`,
            linearToSrgb: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform sampler2D u_originalSrgb; uniform bool u_enableWhiteComp; uniform vec3 u_whitePointSrgb; out vec4 c; vec3 ACES(vec3 x) { return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0); } void main() { vec3 linearColor = texture(u_image, v_uv).rgb; vec3 srgb = pow(ACES(linearColor), vec3(1.0 / 2.2)); if (u_enableWhiteComp) { vec3 srgbCompensated = srgb * u_whitePointSrgb; vec3 originalPreDivision = texture(u_originalSrgb, v_uv).rgb; srgb = max(originalPreDivision, srgbCompensated); } c = vec4(srgb, 1.0); }`,
            minDesaturate: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform float u_thresholdGamma; uniform float u_thresholdWhite; out vec4 c; void main() { vec3 C = texture(u_image, v_uv).rgb; float m = min(C.r, min(C.g, C.b)); float result = pow((m / u_thresholdWhite), (1.0 / u_thresholdGamma)) * u_thresholdWhite; c = vec4(result, result, result, 1.0); }`,
            minDesaturateKeyer: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; out vec4 c; void main() { vec3 C = texture(u_image, v_uv).rgb; float m = min(C.r, min(C.g, C.b)); c = vec4(m, m, m, 1.0); }`,
            keyAdjust: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform float u_blackpoint; uniform float u_whitepoint; out vec4 c; void main() { float r = texture(u_image, v_uv).r; c = vec4(vec3(clamp((r - u_blackpoint) / (u_whitepoint - u_blackpoint), 0.0, 1.0)), 1.0); }`,
            gamma: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform float u_gamma; out vec4 c; void main() { float val = texture(u_image, v_uv).r; c = vec4(vec3(pow(val, 1.0 / u_gamma)), 1.0); }`,
            shuffleRtoRGB: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; out vec4 c; void main() { float r = texture(u_image, v_uv).r; c = vec4(r, r, r, 1.0); }`,
            subtract: `precision highp float; in vec2 v_uv; uniform sampler2D u_imageA,u_imageB; out vec4 c;void main(){c=vec4(max(texture(u_imageA,v_uv).rgb-texture(u_imageB,v_uv).rgb,vec3(0.0)),1.0);}`,
            tint: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform vec3 u_tint; out vec4 c;void main(){c=vec4(texture(u_image,v_uv).rgb*u_tint,1.0);}`,
            grade: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform float u_gain; out vec4 c;void main(){ vec4 t = texture(u_image,v_uv); c = vec4(t.rgb*u_gain, t.a); }`,
            downsample: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; out vec4 c; void main() { c = texture(u_image, v_uv); }`,
            upsample: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; out vec4 c; void main() { c = texture(u_image, v_uv); }`,
            // Chromatic aberration (pre-bake)
            chromaAb: `precision highp float;
                in vec2 v_uv;
                uniform sampler2D u_image;
                uniform float u_samplesF;
                uniform float u_blur;
                uniform float u_falloff;
                out vec4 c;
                void main(){
                    int u_samples = int(floor(u_samplesF + 0.5));
                    if (u_samples <= 0 || u_blur <= 0.0) {
                        c = texture(u_image, v_uv);
                        return;
                    }
                    vec2 center = vec2(0.5);
                    vec2 delta = v_uv - center;
                    float dist = length(delta);
                    vec2 dir = dist > 1e-6 ? normalize(delta) : vec2(0.0);
                    float invS = 1.0 / float(max(u_samples, 1));
                    vec2 velocity = dir * u_blur * pow(dist, u_falloff);
                    mat3x2 inc = mat3x2(velocity * 1.0 * invS,
                                        velocity * 2.0 * invS,
                                        velocity * 4.0 * invS);
                    mat3x2 offs = inc;
                    vec3 acc = vec3(0.0);
                    const int MAX_SAMPLES = 50;
                    for (int i = 0; i < MAX_SAMPLES; i++) {
                        if (i >= u_samples) break;
                        acc.r += texture(u_image, v_uv + offs[0]).r;
                        acc.g += texture(u_image, v_uv + offs[1]).g;
                        acc.b += texture(u_image, v_uv + offs[2]).b;
                        offs -= inc;
                    }
                    c = vec4(acc / float(max(u_samples, 1)), 1.0);
                }`,
            diffusionAdd: `precision highp float; in vec2 v_uv; uniform sampler2D u_base; uniform sampler2D u_diffusion; uniform float u_strength; out vec4 c; void main() { vec3 base = texture(u_base, v_uv).rgb; vec3 diffusion = texture(u_diffusion, v_uv).rgb; c = vec4(base + diffusion * u_strength, 1.0); }`,
            sampleRegion: `precision highp float; in vec2 v_uv; uniform sampler2D u_image; uniform vec4 u_sourceRegion; out vec4 c; void main() { vec2 regionUV = u_sourceRegion.xy + v_uv * u_sourceRegion.zw; c = texture(u_image, regionUV); }`
         };
// ... The rest of the file continues from here ...



        const progs = Object.fromEntries(Object.entries(fsLib).map(([key, fs]) => [key, createProgram(vertexShaderSource, `#version 300 es\n${fs}`)]));
        const quadBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        
        let fbos = {};
        // Stores the source image dimensions BEFORE any border padding (16:9 or 9:16) in border mode
        // Used to compute aspect-based multiplier for overscan image scaling
        let sourceNativeDimensions = { w: 0, h: 0 };
        let tileFBOs = {};
        let previewFBOs = {};
        let borderBlurFBO = null;
        let borderBlurPingPongFBO = null;
        const fboNames = [
            "triptychComposite", "sprocketApplied", "borderApplied", "precurve", "grainApplied", "postcurve",
            "blurPingPong", "highPassBlur", "highPass", "highPassOverlay", "mtfMaskBlur", "mtfSubtract",
            "mtfSoftnessBlur", "mtfOutput", "postMtfSrgb", "gamma", "coreBlur", "midBlur", "outerBlur", "mtfLinearInput",
            "mtfSrgbOutput", "linearBase", "minDesaturate", "keyAdjust", "coreSubtract", "midSubtract",
            "outerSubtract", "midSubtractGraded", "outerSubtractGraded", "glowAccumulator", "tintedGlow",
            "intensityGlow", "addGlowToBase", "finalTonemapped", "diffusionDownscale", "diffusionBlurred",
            "diffusionUpscale", "diffusionGained", "diffusionBlurredB", "diffusionUpscaleB", "diffusionGainedB", "diffusionCombined",
            "diffusionBlurredD", "diffusionUpscaleD", "diffusionGainedD", "diffusionBlurredE", "diffusionUpscaleE", "diffusionGainedE", 
            "diffusionBlurredF", "diffusionUpscaleF", "diffusionGainedF", "diffusionCombined2", "diffusionMerged"
        ];
        const floatFBONames = new Set([
            "linearBase", "minDesaturate", "keyAdjust", "coreSubtract", "midSubtract", "outerSubtract", 
            "midSubtractGraded", "outerSubtractGraded", "glowAccumulator", "tintedGlow", "intensityGlow", 
            "addGlowToBase", "blurPingPong", "mtfLinearInput", "mtfMaskBlur", "mtfSubtract", 
            "mtfSoftnessBlur", "mtfOutput", "diffusionDownscale", "diffusionBlurred", "diffusionUpscale", 
            "diffusionGained", "diffusionBlurredB", "diffusionUpscaleB", "diffusionGainedB", "diffusionCombined",
            "diffusionBlurredD", "diffusionUpscaleD", "diffusionGainedD", "diffusionBlurredE", "diffusionUpscaleE", "diffusionGainedE",
            "diffusionBlurredF", "diffusionUpscaleF", "diffusionGainedF", "diffusionCombined2", "diffusionMerged"
        ]);

        function createFBO(w, h, useFloat = false) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            const isWebGL2 = gl instanceof WebGL2RenderingContext;
            if (useFloat && supportsFloat) {
                if (isWebGL2) gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.HALF_FLOAT, null);
                else gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.getExtension('OES_texture_half_float').HALF_FLOAT_OES, null);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            }
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            return { fbo: fb, texture: tex, width: w, height: h };
        }
        
        function cleanupFBOs(fboSet) {
            Object.values(fboSet).forEach(f => { if(f){gl.deleteFramebuffer(f.fbo); gl.deleteTexture(f.texture);} });
            return {};
        }

        function resizeFBOs(w, h) {
            fbos = cleanupFBOs(fbos);
            const fboWidth = w;
            const fboHeight = h;
            fboNames.forEach(name => fbos[name] = createFBO(fboWidth, fboHeight, supportsFloat && floatFBONames.has(name)));
        }

        function initTileFBOs(w, h) {
            tileFBOs = cleanupFBOs(tileFBOs);
            fboNames.forEach(name => tileFBOs[name] = createFBO(w, h, supportsFloat && floatFBONames.has(name)));
        }

        function initPreviewFBOs(w, h) {
            previewFBOs = cleanupFBOs(previewFBOs);
            fboNames.forEach(name => previewFBOs[name] = createFBO(w, h, supportsFloat && floatFBONames.has(name)));
        }

        function drawQuadWithRegions(program, uniforms, srcRect, destRect, sourceResolution, viewportSize) {
            gl.useProgram(program);
            const pL = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(pL);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(pL, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2fv(gl.getUniformLocation(program, "u_fullResolution"), sourceResolution);
            gl.uniform2fv(gl.getUniformLocation(program, "u_viewportResolution"), viewportSize || sourceResolution);
            // Always pass the full canvas size to the vertex shader for v_fullUV computations
            gl.uniform2fv(gl.getUniformLocation(program, "u_globalResolution"), [canvas.width, canvas.height]);
            gl.uniform4fv(gl.getUniformLocation(program, "u_sourceRect"), [srcRect.x, srcRect.y, srcRect.w, srcRect.h]);
            gl.uniform4fv(gl.getUniformLocation(program, "u_destRect"), [destRect.x, destRect.y, destRect.w, destRect.h]);
            // u_fullUVRect defaults to srcRect unless overridden in uniforms
            const fullUVRect = uniforms && uniforms.u_fullUVRect ? uniforms.u_fullUVRect : [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
            gl.uniform4fv(gl.getUniformLocation(program, "u_fullUVRect"), fullUVRect);

            let tU = 0;
            for (const [name, value] of Object.entries(uniforms)) {
                const loc = gl.getUniformLocation(program, name);
                if (loc === null) continue;
                if (typeof value === "number") {
                    if (name === 'u_direction') gl.uniform1i(loc, value|0); else gl.uniform1f(loc, value);
                }
                else if (typeof value === "boolean") gl.uniform1i(loc, value ? 1 : 0);
                else if (value instanceof WebGLTexture) {
                    gl.activeTexture(gl.TEXTURE0 + tU); gl.bindTexture(gl.TEXTURE_2D, value); gl.uniform1i(loc, tU++);
                } else if (Array.isArray(value) || value instanceof Float32Array) {
                    const len = value.length || 0;
                    if (len === 2) gl.uniform2fv(loc, value);
                    else if (len === 3) gl.uniform3fv(loc, value);
                    else if (len === 4) gl.uniform4fv(loc, value);
                    else gl.uniform1fv(loc, value);
                }
            }
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function applySeparableBlur(source, targetFBO, radius, srcRect, destRect, fboSet, sourceResolution, viewportSize) {
            if (radius <= 0) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO.fbo);
                drawQuadWithRegions(progs.passthrough, { u_image: source }, srcRect, destRect, sourceResolution, viewportSize);
                return;
            }
            const blurTexelSize = [1 / srcRect.w, 1 / srcRect.h];
            const tileRect = {x: 0, y: 0, w: destRect.w, h: destRect.h};

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.blurPingPong.fbo);
            drawQuadWithRegions(progs.separableBlur, { u_image: source, u_texelSize: blurTexelSize, u_blurRadius: radius, u_direction: [1, 0] }, srcRect, destRect, sourceResolution, viewportSize);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO.fbo);
            drawQuadWithRegions(progs.separableBlur, { u_image: fboSet.blurPingPong.texture, u_texelSize: blurTexelSize, u_blurRadius: radius, u_direction: [0, 1] }, tileRect, destRect, viewportSize, viewportSize);
        }

        function generateCurveLut(points) {
            const lutSize = 256;
            const data = new Uint8Array(lutSize * 4);
            for (let i = 0; i < lutSize; i++) {
                const x = i / 255.0; let y = x;
                let p1 = points[0], p2 = points[points.length - 1];
                for (let j = 0; j < points.length - 1; j++) { if (x >= points[j][0] && x <= points[j + 1][0]) { p1 = points[j]; p2 = points[j + 1]; break; } }
                if (p1[0] !== p2[0]) { y = p1[1] + (x - p1[0]) / (p2[0] - p1[0]) * (p2[1] - p1[1]); } else { y = p1[1]; }
                const val = Math.round(Math.max(0, Math.min(1, y)) * 255);
                data[i * 4] = data[i * 4 + 1] = data[i * 4 + 2] = val; data[i * 4 + 3] = 255;
            }
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lutSize, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return texture;
        }

        async function render() {
            if (!imageTexture || isTilingRenderInProgress || suppressRenders) return;
            clearTimeout(renderDebounceTimeout);

            if (isHolding) {
                // Show base+border+sprocket only, with current overscan/imageScale
                const isLargeImage = (canvas.width > MAX_SAFE_FBO_RES || canvas.height > MAX_SAFE_FBO_RES || isEffectivelyLargeForPreview());
                if (isLargeImage) {
                    renderPreviewResolution();
                } else {
                    await renderFullResolution(true);
                }
                return;
            }
            
            const isInteractive = isDragging || isSimplePreviewing;
            const isLargeImage = (canvas.width > MAX_SAFE_FBO_RES || canvas.height > MAX_SAFE_FBO_RES || isEffectivelyLargeForPreview());

            if (isLargeImage) {
                if (isInteractive) {
                    renderPreviewResolution();
                } else {
                    // Immediately render at preview resolution to show new image, then do tiled render
                    renderPreviewResolution();
                    renderDebounceTimeout = setTimeout(async () => {
                        isTilingRenderInProgress = true;
                        showProgressIndicator();
                        await renderTiled().finally(() => {
                            isTilingRenderInProgress = false;
                            hideProgressIndicator();
                        });
                    }, 150);
                }
            } else {
                await renderFullResolution(isInteractive);
            }
        }
        
        function renderOriginalImage() {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.disable(gl.BLEND);
            const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
            drawQuadWithRegions(progs.passthrough, { u_image: imageTexture }, fullRect, fullRect, [canvas.width, canvas.height]);
        }

        function needsDiffusion() {
            const vals2 = { 
                diffusionStrength: parseFloat(diffusionStrengthSlider.value), 
                diffusionRadius: parseFloat(diffusionRadiusSlider.value),
                diffusionStrengthB: parseFloat(diffusionStrengthBSlider.value), 
                diffusionRadiusB: parseFloat(diffusionRadiusBSlider.value),
                diffusionStrengthC: parseFloat(diffusionStrengthCSlider.value), 
                diffusionRadiusC: parseFloat(diffusionRadiusCSlider.value)
            };
            return halationEnabledToggle.checked && supportsFloat && (
                (vals2.diffusionStrength > 0 && vals2.diffusionRadius > 0) ||
                (vals2.diffusionStrengthB > 0 && vals2.diffusionRadiusB > 0) ||
                (vals2.diffusionStrengthC > 0 && vals2.diffusionRadiusC > 0)
            );
        }

        function needsDiffusion2() {
            if (!diffusionRadiusDSlider || !diffusionStrengthDSlider) return false;
            const vals = { 
                diffusionStrengthD: parseFloat(diffusionStrengthDSlider.value), 
                diffusionRadiusD: parseFloat(diffusionRadiusDSlider.value),
                diffusionStrengthE: parseFloat(diffusionStrengthESlider.value), 
                diffusionRadiusE: parseFloat(diffusionRadiusESlider.value),
                diffusionStrengthF: parseFloat(diffusionStrengthFSlider.value), 
                diffusionRadiusF: parseFloat(diffusionRadiusFSlider.value)
            };
            return halationEnabledToggle.checked && supportsFloat && (
                (vals.diffusionStrengthD > 0 && vals.diffusionRadiusD > 0) ||
                (vals.diffusionStrengthE > 0 && vals.diffusionRadiusE > 0) ||
                (vals.diffusionStrengthF > 0 && vals.diffusionRadiusF > 0)
            );
        }

        function needsAnyDiffusion() {
            return needsDiffusion() || needsDiffusion2();
        }

        function invalidateDiffusionBuffer() {
            if (window.__globalDiffusionBuffer) {
                gl.deleteFramebuffer(window.__globalDiffusionBuffer.fbo);
                gl.deleteTexture(window.__globalDiffusionBuffer.texture);
                window.__globalDiffusionBuffer = null;
            }
        }

        async function preComputeGlobal1KDiffusion() {
            try {
                // Always scale to 1K resolution for diffusion computation
                const DIFFUSION_TARGET_DIM = 1024;
                const maxDim = Math.max(canvas.width, canvas.height);
                const diffusionScale = Math.min(1.0, DIFFUSION_TARGET_DIM / maxDim);
                const diffusionW = Math.max(1, Math.floor(canvas.width * diffusionScale));
                const diffusionH = Math.max(1, Math.floor(canvas.height * diffusionScale));

                // Create temporary FBOs for the entire 1K pipeline
                const tempFBOs = {};
                fboNames.forEach(name => tempFBOs[name] = createFBO(diffusionW, diffusionH, supportsFloat && floatFBONames.has(name)));

                const fullCanvasRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
                const diffusionRect = { x: 0, y: 0, w: diffusionW, h: diffusionH };
                const diffusionResolution = [diffusionW, diffusionH];

                // Set viewport for 1K diffusion computation
                gl.viewport(0, 0, diffusionW, diffusionH);

                // Run the entire pipeline up to addGlowToBase at 1K resolution
                runRenderPipelineUpToDiffusion(fullCanvasRect, diffusionRect, tempFBOs, diffusionResolution);

                // Compute diffusion at 1K resolution and store the result
                const diffusionContribution = runDiffusionOnlyPass(tempFBOs.addGlowToBase.texture, diffusionRect, tempFBOs, diffusionResolution);

                // Create the global diffusion buffer to store the 1K result
                const globalDiffusionBuffer = createFBO(diffusionW, diffusionH, supportsFloat);
                gl.bindFramebuffer(gl.FRAMEBUFFER, globalDiffusionBuffer.fbo);
                
                if (diffusionContribution) {
                    drawQuadWithRegions(progs.passthrough, { u_image: diffusionContribution }, diffusionRect, diffusionRect, diffusionResolution, diffusionResolution);
                } else {
                    gl.clearColor(0,0,0,0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }

                // Clean up temporary FBOs
                Object.values(tempFBOs).forEach(f => { if(f) { gl.deleteFramebuffer(f.fbo); gl.deleteTexture(f.texture); } });
                gl.flush();
                await new Promise(r => requestAnimationFrame(r));

                return { 
                    fbo: globalDiffusionBuffer.fbo, 
                    texture: globalDiffusionBuffer.texture, 
                    width: diffusionW, 
                    height: diffusionH 
                };
            } catch (e) {
                console.warn('Global 1K diffusion computation failed:', e);
                return null;
            }
        }

        async function preComputeDiffusionBuffer() {
            try {
                // Always use 1K resolution for diffusion computation for consistency across all resolutions
                const DIFFUSION_TARGET_DIM = 1024;
                const maxDim = Math.max(canvas.width, canvas.height);
                const diffusionScale = Math.min(1.0, DIFFUSION_TARGET_DIM / maxDim);
                const diffusionW = Math.max(1, Math.floor(canvas.width * diffusionScale));
                const diffusionH = Math.max(1, Math.floor(canvas.height * diffusionScale));

                // Create temporary FBOs for diffusion computation (same schema as normal fbos)
                const tempFBOs = {};
                fboNames.forEach(name => tempFBOs[name] = createFBO(diffusionW, diffusionH, supportsFloat && floatFBONames.has(name)));

                const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
                const diffusionRect = { x: 0, y: 0, w: diffusionW, h: diffusionH };
                const diffusionResolution = [diffusionW, diffusionH];

                // Set viewport for diffusion computation
                gl.viewport(0, 0, diffusionW, diffusionH);

                // Run the pipeline up to the point just before diffusion (addGlowToBase)
                runRenderPipelineUpToDiffusion(fullRect, diffusionRect, tempFBOs, diffusionResolution);

                // Apply diffusion processing at this resolution - returns ONLY diffusion contribution
                const diffusionContribution = runDiffusionOnlyPass(tempFBOs.addGlowToBase.texture, diffusionRect, tempFBOs, diffusionResolution);

                // Create final diffusion buffer to return
                const diffusionBuffer = createFBO(diffusionW, diffusionH, supportsFloat);
                if (diffusionContribution) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, diffusionBuffer.fbo);
                    drawQuadWithRegions(progs.passthrough, { u_image: diffusionContribution }, diffusionRect, diffusionRect, diffusionResolution, diffusionResolution);
                } else {
                    // No diffusion - clear the buffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, diffusionBuffer.fbo);
                    gl.clearColor(0,0,0,0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }

                // Clean up temporary FBOs (but keep the diffusion buffer)
                Object.values(tempFBOs).forEach(f => { if(f) { gl.deleteFramebuffer(f.fbo); gl.deleteTexture(f.texture); } });
                gl.flush();
                // Give the driver a frame to actually reclaim resources
                await new Promise(r => requestAnimationFrame(r));

                // Return both the buffer and its actual dimensions
                return { 
                    fbo: diffusionBuffer.fbo, 
                    texture: diffusionBuffer.texture, 
                    width: diffusionW, 
                    height: diffusionH 
                };
            } catch (e) {
                console.warn('Precomputed diffusion disabled due to error:', e);
                return null;
            }
        }

        function runRenderPipelineUpToDiffusion(srcRect, destRect, fboSet, viewportSize) {
            const tileRect = { x: 0, y: 0, w: destRect.w, h: destRect.h };
            const globalResolution = (globalResolutionOverride ? [globalResolutionOverride[0], globalResolutionOverride[1]] : [canvas.width, canvas.height]);
            const tileResolution = viewportSize;
            
            const vals={imageScale:parseFloat(imageScaleSlider.value), blackLevelBias:parseFloat(blackLevelBiasSlider.value), borderScale:parseFloat(borderScaleSlider.value), sprocketContrast:parseFloat(sprocketContrastSlider.value), cheatAspectX:parseFloat(cheatAspectXSlider.value), cheatAspectY:parseFloat(cheatAspectYSlider.value)};
            const biasedMinPixelValue = [minPixelValue[0] * vals.blackLevelBias, minPixelValue[1] * vals.blackLevelBias, minPixelValue[2] * vals.blackLevelBias];
            // Use 1K-based nF for consistent diffusion scaling across all resolutions
            const nF = 1024.0/3840.0;
            const is8mm = (window.__borderEngine === '8mm');
            const is16mm = (window.__borderEngine === '16mm');
            const is35mm178 = (window.__borderEngine === '35mm-178');
            const is35mm240 = (window.__borderEngine === '35mm-240');
            const is35mm133 = (window.__borderEngine === '35mm-133');
            const is35mmAdd = (window.__borderEngine === '35mm-add');
            const isMediumFormat = (window.__borderEngine === 'medium-format');
            const isSpecialEngine = is8mm || is16mm || is35mm178 || is35mm240 || is35mm133 || is35mmAdd || isMediumFormat;

            // Calculate final image scale with blur compensation
            let finalImageScale = vals.imageScale;
            if (isSpecialEngine && !is35mmAdd && !isMediumFormat) {
                const blurRadius = parseFloat(borderBlurSlider.value);
                const BLUR_TO_SCALE_COMPENSATION = 0.001;
                finalImageScale += blurRadius * BLUR_TO_SCALE_COMPENSATION;
            }

            // Run border composition logic (same as main pipeline)
            if (isSpecialEngine) {
                let zoneBDims;
                if (is8mm) {
                    zoneBDims = [3028.0, 2016.0];
                } else if (is16mm) {
                    zoneBDims = [3499.0, 2115.0];
                } else if (is35mm178) {
                    zoneBDims = [3691.0, 2084.0];
                } else if (is35mm240) {
                    zoneBDims = [3679.0, 1550.0];
                } else if (is35mm133) {
                    zoneBDims = [3028.0, 2016.0];
                } else if (is35mmAdd) {
                    zoneBDims = [2240.0, 1516.0];
                } else if (isMediumFormat) {
                    zoneBDims = [2448.0, 2000.0];
                }
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const programToUse = (is35mmAdd || isMediumFormat) ? progs.borderComposite35add : progs.borderComposite8mm;
                // Compute native aspect (long/short) for correct framing axis
                const nW = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const nH = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                const nativeLongShort = (Math.max(nW, nH) / Math.max(1, Math.min(nW, nH)));
                drawQuadWithRegions(programToUse, {
                    u_source: imageTexture,
                    u_gateTexture: borderTexture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_borderScale: vals.borderScale,
                    u_imageScale: finalImageScale,
                    u_adjacentFrameDistance: is35mmAdd ? (1.06 + parseFloat(framePaddingSlider.value)) : isMediumFormat ? (1.10 + parseFloat(framePaddingSlider.value)) : (parseFloat(adjacentFrameDistanceSlider.value) / 100.0) + parseFloat(framePaddingSlider.value),
                    u_framing: parseFloat(framingSlider.value),
                    u_nativeSourceAspect: nativeLongShort,
                    u_framingLimit: 1.0,
                    u_canvasResolution: globalResolution,
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h],
                    u_borderResolution: [3840, 2160],
                    u_zoneBDims: zoneBDims,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                }, srcRect, destRect, globalResolution, tileResolution);
            } else {
                const disableAC = false;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.triptychComposite.fbo);
                // Compute native aspect and neutral framing limit for triptych
                const nW2 = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const nH2 = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                const nativeLongShort2 = (Math.max(nW2, nH2) / Math.max(1, Math.min(nW2, nH2)));
                drawQuadWithRegions(progs.triptychCompositor, { 
                    u_source: imageTexture, 
                    u_maskA: maskATexture, 
                    u_maskB: maskBTexture, 
                    u_maskC: maskCTexture,
                    u_borderScale: vals.borderScale, 
                    u_imageScale: finalImageScale,
                    u_canvasResolution: globalResolution, 
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h], 
                    u_borderResolution: [3840, 2160], 
                    u_disableAC: disableAC,
                    u_is8mmEngine: is8mm,
                    u_adjacentFrameDistance: parseFloat(adjacentFrameDistanceSlider.value) / 100.0,
                    u_framing: parseFloat(framingSlider.value),
                    u_zoneBDims: [2240.0, 1516.0],
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_nativeSourceAspect: nativeLongShort2,
                    u_framingLimit: 1.0,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                 }, srcRect, destRect, globalResolution, tileResolution);

                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
                drawQuadWithRegions(progs.borderOverlay, {
                    u_base: fboSet.triptychComposite.texture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_fullUVRect: fullUVRect,
                    u_border: borderTexture,
                    u_borderScale: vals.borderScale,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_canvasResolution: globalResolution,
                    u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160]
                }, tileRect, destRect, tileResolution, tileResolution);
            }
            
            let currentResult = fboSet.borderApplied.texture;
            
            // Run halation up to addGlowToBase (before diffusion)
            if (halationEnabledToggle.checked && supportsFloat) {
                runHalationPassUpToDiffusion(currentResult, nF, tileRect, destRect, fboSet, tileResolution);
            }
        }

        function runHalationPassUpToDiffusion(inputTexture, nF, tileRect, destRect, fboSet, tileResolution) {
            const vals2 = { halationIntensity:parseFloat(halationIntensitySlider.value), mtfMask:parseFloat(mtfMaskSlider.value), mtfSoftness:parseFloat(mtfSoftnessSlider.value), blackpoint:parseFloat(blackpointSlider.value), whitepoint:parseFloat(whitepointSlider.value), thresholdGamma:parseFloat(thresholdGammaSlider.value), coreBlur:parseFloat(coreBlurSlider.value), midBlur:parseFloat(midBlurSlider.value), outerBlur:parseFloat(outerBlurSlider.value), midBlurGain:parseFloat(midBlurGainSlider.value), outerBlurGain:parseFloat(outerBlurGainSlider.value), tintR2:parseFloat(tintR2Slider.value), tintG2:parseFloat(tintG2Slider.value), tintB2:parseFloat(tintB2Slider.value) };
            const useRaw = (chromaPreviewActive || isHolding) && rawSrgbTexture;
            const srcSrgb = useRaw ? rawSrgbTexture : originalSrgbTexture;
            
            let mtfInput = inputTexture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfLinearInput.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: inputTexture, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfInput = fboSet.mtfLinearInput.texture; }
            applySeparableBlur(mtfInput, fboSet.mtfMaskBlur, vals2.mtfMask * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: mtfInput, u_imageB: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            applySeparableBlur(fboSet.mtfSubtract.texture, fboSet.mtfSoftnessBlur, vals2.mtfSoftness * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfOutput.fbo); drawQuadWithRegions(progs.add, { u_base: fboSet.mtfSoftnessBlur.texture, u_overlay: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Create post-MTF sRGB texture for white point processing
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.postMtfSrgb.fbo);
            if (mtfLinearToggle.checked) {
                // MTF was in linear space, convert to sRGB
                drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution);
            } else {
                // MTF was in sRGB space, just pass through
                drawQuadWithRegions(progs.passthrough, { u_image: fboSet.mtfOutput.texture }, tileRect, destRect, tileResolution, tileResolution);
            }
            let mtfResultForNextStep = fboSet.mtfOutput.texture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSrgbOutput.fbo); drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfResultForNextStep = fboSet.mtfSrgbOutput.texture; }
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.linearBase.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.minDesaturate.fbo); drawQuadWithRegions(progs.minDesaturate, { u_image: fboSet.linearBase.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.keyAdjust.fbo); drawQuadWithRegions(progs.keyAdjust, { u_image: fboSet.minDesaturate.texture, u_blackpoint: vals2.blackpoint, u_whitepoint: vals2.whitepoint }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.gamma.fbo); drawQuadWithRegions(progs.gamma, { u_image: fboSet.keyAdjust.texture, u_gamma: vals2.thresholdGamma }, tileRect, destRect, tileResolution, tileResolution);
            const glowSubtractor = fboSet.gamma.texture;
            applySeparableBlur(glowSubtractor, fboSet.coreBlur, vals2.coreBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.midBlur, vals2.midBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.outerBlur, vals2.outerBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.coreSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.coreBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.midBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.outerBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.midSubtract.texture, u_gain: vals2.midBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.outerSubtract.texture, u_gain: vals2.outerBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.glowAccumulator.fbo); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.coreSubtract.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.midSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.outerSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.disable(gl.BLEND);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.blurPingPong.fbo); drawQuadWithRegions(progs.shuffleRtoRGB, { u_image: fboSet.glowAccumulator.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.tintedGlow.fbo); drawQuadWithRegions(progs.tint, { u_image: fboSet.blurPingPong.texture, u_tint: [vals2.tintR2, vals2.tintG2, vals2.tintB2] }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.intensityGlow.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.tintedGlow.texture, u_gain: vals2.halationIntensity }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.addGlowToBase.fbo); drawQuadWithRegions(progs.add, { u_base: fboSet.linearBase.texture, u_overlay: fboSet.intensityGlow.texture }, tileRect, destRect, tileResolution, tileResolution);
        }

        function runDiffusionOnlyPass(inputTexture, tileRect, fboSet, tileResolution) {
            const vals2 = { diffusionRadius:parseFloat(diffusionRadiusSlider.value), diffusionStrength:parseFloat(diffusionStrengthSlider.value), diffusionRadiusB:parseFloat(diffusionRadiusBSlider.value), diffusionStrengthB:parseFloat(diffusionStrengthBSlider.value), diffusionRadiusC:parseFloat(diffusionRadiusCSlider.value), diffusionStrengthC:parseFloat(diffusionStrengthCSlider.value), diffusionSpread:parseFloat(diffusionSpreadSlider.value), diffusionGamma:parseFloat(diffusionGammaSlider.value), diffusionIntensity:parseFloat(diffusionIntensitySlider.value), diffusionTintR:parseFloat(diffusionTintRSlider.value), diffusionTintG:parseFloat(diffusionTintGSlider.value), diffusionTintB:parseFloat(diffusionTintBSlider.value), diffusionSubtract:diffusionSubtractToggle.checked };
            // Always use 1K resolution for diffusion computation regardless of working resolution
            // This ensures visual consistency across all resolutions
            const DIFFUSION_TARGET_DIM = 1024;
            const maxDim = Math.max(tileResolution[0], tileResolution[1]);
            const scale = Math.min(1.0, DIFFUSION_TARGET_DIM / maxDim);
            const diffusionW = Math.max(1, Math.floor(tileResolution[0] * scale));
            const diffusionH = Math.max(1, Math.floor(tileResolution[1] * scale));
            
            // Use 1K-based nF for consistent blur scaling regardless of input resolution
            const nF = DIFFUSION_TARGET_DIM / 3840.0;
            
            // Formula to calculate automatic additional blur based on diffusion radius
            const calculateAdditionalBlur = (diffusionRadius) => {
                if (diffusionRadius < 35) return 0;
                if (diffusionRadius < 80) return 1;
                if (diffusionRadius < 149) return Math.max(1, Math.min(6, (diffusionRadius - 80) * 5 / 69 + 1));
                if (diffusionRadius < 170) return Math.max(6, Math.min(7, (diffusionRadius - 149) * 1 / 21 + 6));
                if (diffusionRadius < 200) return Math.max(7, Math.min(12, (diffusionRadius - 170) * 5 / 30 + 7));
                if (diffusionRadius < 250) return Math.max(12, Math.min(18, (diffusionRadius - 200) * 6 / 50 + 12));
                if (diffusionRadius < 300) return Math.max(18, Math.min(22, (diffusionRadius - 250) * 4 / 50 + 18));
                if (diffusionRadius < 350) return Math.max(22, Math.min(25, (diffusionRadius - 300) * 3 / 50 + 22));
                if (diffusionRadius < 400) return Math.max(25, Math.min(20, (diffusionRadius - 350) * -5 / 50 + 25));
                if (diffusionRadius < 600) return 20;
                if (diffusionRadius < 800) return Math.max(20, Math.min(40, (diffusionRadius - 600) * 20 / 200 + 20));
                if (diffusionRadius < 1000) return Math.max(40, Math.min(50, (diffusionRadius - 800) * 10 / 200 + 40));
                return 50;
            };
            
            // Return ONLY the diffusion contribution (not base + diffusion)
            let diffusionContribution = null;
            if ((vals2.diffusionStrength > 0 && vals2.diffusionRadius > 0) || (vals2.diffusionStrengthB > 0 && vals2.diffusionRadiusB > 0) || (vals2.diffusionStrengthC > 0 && vals2.diffusionRadiusC > 0)) {

                // Create temporary FBOs with exact downscaled dimensions
                const tempDownscaleFBO = createFBO(diffusionW, diffusionH, true);
                const tempBlurredFBO = createFBO(diffusionW, diffusionH, true);

                // Downscale to 1K
                const downscaleRect = { x: 0, y: 0, w: diffusionW, h: diffusionH };
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempDownscaleFBO.fbo);
                gl.viewport(0, 0, diffusionW, diffusionH);
                drawQuadWithRegions(
                    progs.downsample,
                    { u_image: inputTexture, u_fullUVRect: [tileRect.x, tileRect.y, tileRect.w, tileRect.h] },
                    tileRect, // source: full tile
                    downscaleRect, // dest: full downscaled target
                    tileResolution, // source resolution: tile size
                    [diffusionW, diffusionH] // viewport: downscaled size
                );

                // Apply threshold gain first, then luma key and premultiply
                const thresholdGain = parseFloat((document.getElementById('diffusionThreshold')||{value:'1'}).value)||1;
                const thresholdAdjustedFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, thresholdAdjustedFBO.fbo);
                drawQuadWithRegions(
                    progs.applyThresholdGain,
                    { u_image: tempDownscaleFBO.texture, u_gain: thresholdGain, u_fullUVRect: [0,0,1,1] },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Luma key and premultiply (no gain applied here since it was applied above)
                const lumaPremulFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, lumaPremulFBO.fbo);
                drawQuadWithRegions(
                    progs.lumaPremultiplyNoGain,
                    { u_image: thresholdAdjustedFBO.texture, u_fullUVRect: [0,0,1,1] },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Build diffusion A and B at downscaled resolution, then combine and upscale once
                const texelSize = [1 / diffusionW, 1 / diffusionH];
                const hasA = (vals2.diffusionStrength > 0.0 && vals2.diffusionRadius > 0.0);
                const hasB = (vals2.diffusionStrengthB > 0.0 && vals2.diffusionRadiusB > 0.0);

                // Diffusion A blur (downscaled)
                let tempPingFBO = null;
                if (hasA) {
                    const sigmaA = Math.max(0.5, vals2.diffusionRadius * vals2.diffusionSpread * nF * scale * 0.2);
                    const radiusA = Math.min(96.0, sigmaA * 6.0);
                    // Use smooth LOD interpolation instead of discrete steps to avoid hard stops
                    const lodAFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaA) - 1));
                    const lodA = Math.floor(lodAFloat);
                    const lodAFrac = lodAFloat - lodA;
                    // Smooth step size interpolation between LOD levels
                    const stepSizeBase = Math.pow(2, lodA);
                    const stepSizeNext = Math.pow(2, Math.min(4, lodA + 1));
                    let smoothStepSize = stepSizeBase + (stepSizeNext - stepSizeBase) * lodAFrac;
                    // Cap step size to prevent grid artifacts at very large radii
                    smoothStepSize = Math.min(smoothStepSize, 8.0);
                    
                    tempPingFBO = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBO.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: lumaPremulFBO.texture, u_step: [smoothStepSize * 0.5/diffusionW, 0.0], u_sigma: sigmaA, u_radius: radiusA, u_lod: lodAFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBO.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBO.texture, u_step: [0.0, smoothStepSize * 0.5/diffusionH], u_sigma: sigmaA, u_radius: radiusA, u_lod: lodAFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    
                    // Apply automatic additional blur A to smooth grid artifacts at high radii
                    const autoAdditionalBlurA = calculateAdditionalBlur(vals2.diffusionRadius * vals2.diffusionSpread);
                    if (autoAdditionalBlurA > 0) {
                        const additionalBlurRadius = autoAdditionalBlurA * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        
                        // Create temporary FBO for additional blur ping-pong
                        const tempAdditionalBlurFBO = createFBO(diffusionW, diffusionH, true);
                        
                        // Horizontal pass
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBO.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempBlurredFBO.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [1, 0] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Vertical pass - write back to tempBlurredFBO
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBO.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempAdditionalBlurFBO.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [0, 1] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Clean up temporary FBO
                        gl.deleteFramebuffer(tempAdditionalBlurFBO.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBO.texture);
                    }
                }

                // Diffusion B blur (downscaled)
                let tempPingFBOB = null;
                let tempBlurredFBOB = null;
                if (hasB) {
                    const sigmaB = Math.max(0.5, vals2.diffusionRadiusB * vals2.diffusionSpread * nF * scale * 0.2);
                    const radiusB = Math.min(96.0, sigmaB * 6.0);
                    // Use smooth LOD interpolation instead of discrete steps to avoid hard stops
                    const lodBFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaB) - 1));
                    const lodB = Math.floor(lodBFloat);
                    const lodBFrac = lodBFloat - lodB;
                    // Smooth step size interpolation between LOD levels
                    const stepSizeBase = Math.pow(2, lodB);
                    const stepSizeNext = Math.pow(2, Math.min(4, lodB + 1));
                    let smoothStepSize = stepSizeBase + (stepSizeNext - stepSizeBase) * lodBFrac;
                    // Cap step size to prevent grid artifacts at very large radii
                    smoothStepSize = Math.min(smoothStepSize, 8.0);
                    tempPingFBOB = createFBO(diffusionW, diffusionH, true);
                    tempBlurredFBOB = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBOB.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: lumaPremulFBO.texture, u_step: [smoothStepSize * 0.5/diffusionW, 0.0], u_sigma: sigmaB, u_radius: radiusB, u_lod: lodBFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOB.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBOB.texture, u_step: [0.0, smoothStepSize * 0.5/diffusionH], u_sigma: sigmaB, u_radius: radiusB, u_lod: lodBFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    
                    // Apply automatic additional blur B to smooth grid artifacts at high radii
                    const autoAdditionalBlurB = calculateAdditionalBlur(vals2.diffusionRadiusB * vals2.diffusionSpread);
                    if (autoAdditionalBlurB > 0) {
                        const additionalBlurRadius = autoAdditionalBlurB * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        
                        // Create temporary FBO for additional blur ping-pong
                        const tempAdditionalBlurFBOB = createFBO(diffusionW, diffusionH, true);
                        
                        // Horizontal pass
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBOB.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempBlurredFBOB.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [1, 0] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Vertical pass - write back to tempBlurredFBOB
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOB.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempAdditionalBlurFBOB.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [0, 1] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Clean up temporary FBO
                        gl.deleteFramebuffer(tempAdditionalBlurFBOB.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBOB.texture);
                    }
                }

                // Combine A, B and C with gains at downscaled resolution
                const tempCombinedFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempCombinedFBO.fbo);
                gl.viewport(0, 0, diffusionW, diffusionH);
                gl.clearColor(0,0,0,0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                if (hasA) {
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBO.texture, u_gain: vals2.diffusionStrength * vals2.diffusionIntensity },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                }
                if (hasB) {
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBOB.texture, u_gain: vals2.diffusionStrengthB * vals2.diffusionIntensity },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                }
                
                // Diffusion C branch (optional) - process BEFORE disabling blend
                let tempPingFBOC = null; let tempBlurredFBOC = null; const hasC = (vals2.diffusionStrengthC > 0.0 && vals2.diffusionRadiusC > 0.0);
                if (hasC) {
                    const sigmaC = Math.max(0.5, vals2.diffusionRadiusC * vals2.diffusionSpread * nF * scale * 0.2);
                    const radiusC = Math.min(96.0, sigmaC * 6.0);
                    // Use smooth LOD interpolation instead of discrete steps to avoid hard stops
                    const lodCFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaC) - 1));
                    const lodC = Math.floor(lodCFloat);
                    const lodCFrac = lodCFloat - lodC;
                    // Smooth step size interpolation between LOD levels
                    const stepSizeBase = Math.pow(2, lodC);
                    const stepSizeNext = Math.pow(2, Math.min(4, lodC + 1));
                    let smoothStepSize = stepSizeBase + (stepSizeNext - stepSizeBase) * lodCFrac;
                    // Cap step size to prevent grid artifacts at very large radii
                    smoothStepSize = Math.min(smoothStepSize, 8.0);
                    tempPingFBOC = createFBO(diffusionW, diffusionH, true);
                    tempBlurredFBOC = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBOC.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: lumaPremulFBO.texture, u_step: [smoothStepSize * 0.5/diffusionW, 0.0], u_sigma: sigmaC, u_radius: radiusC, u_lod: lodCFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOC.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBOC.texture, u_step: [0.0, smoothStepSize * 0.5/diffusionH], u_sigma: sigmaC, u_radius: radiusC, u_lod: lodCFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    
                    // Apply automatic additional blur C to smooth grid artifacts at high radii
                    const autoAdditionalBlurC = calculateAdditionalBlur(vals2.diffusionRadiusC * vals2.diffusionSpread);
                    if (autoAdditionalBlurC > 0) {
                        console.log(`Applying additional blur C: radius=${vals2.diffusionRadiusC}, blur=${autoAdditionalBlurC}`);
                        const additionalBlurRadius = autoAdditionalBlurC * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        
                        // Ensure correct GL state for blur operations
                        gl.viewport(0, 0, diffusionW, diffusionH);
                        gl.disable(gl.BLEND);
                        
                        // Create temporary FBO for additional blur ping-pong
                        const tempAdditionalBlurFBOC = createFBO(diffusionW, diffusionH, true);
                        
                        // Horizontal pass
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBOC.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempBlurredFBOC.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [1, 0] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Vertical pass - write back to tempBlurredFBOC
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOC.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempAdditionalBlurFBOC.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [0, 1] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Clean up temporary FBO
                        gl.deleteFramebuffer(tempAdditionalBlurFBOC.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBOC.texture);
                        
                        // Restore blend state for diffusion C addition
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.ONE, gl.ONE);
                    }
                    
                    // Add Diffusion C to the combined buffer while blend is still enabled
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempCombinedFBO.fbo);
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBOC.texture, u_gain: vals2.diffusionStrengthC * vals2.diffusionIntensity },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                }
                gl.disable(gl.BLEND);

                // Optional subtract source (luma premultiplied) from combined diffusion at downscaled resolution
                let sourceForTinting = tempCombinedFBO.texture;
                let tempSubtractedFBO = null;
                if (vals2.diffusionSubtract) {
                    // Create temporary FBO for subtracted diffusion at downscaled resolution
                    tempSubtractedFBO = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempSubtractedFBO.fbo);
                    drawQuadWithRegions(
                        progs.subtract,
                        { u_imageA: tempCombinedFBO.texture, u_imageB: lumaPremulFBO.texture },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                    sourceForTinting = tempSubtractedFBO.texture;
                }

                // Apply gamma function to the combined diffusion RGB (before tinting)
                let gammaSourceTexture = sourceForTinting;
                let tempGammaFBO = null;
                if (vals2.diffusionGamma !== 1.0) {
                    tempGammaFBO = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempGammaFBO.fbo);
                    drawQuadWithRegions(
                        progs.gamma,
                        { u_image: sourceForTinting, u_gamma: vals2.diffusionGamma },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                    gammaSourceTexture = tempGammaFBO.texture;
                }

                // Apply RGB tint to combined diffusion after gamma
                const tempTintedFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempTintedFBO.fbo);
                const diffusionTintRGB = [vals2.diffusionTintR, vals2.diffusionTintG, vals2.diffusionTintB];
                console.log(`Diffusion RGB tint values: R=${vals2.diffusionTintR}, G=${vals2.diffusionTintG}, B=${vals2.diffusionTintB}`);
                drawQuadWithRegions(
                    progs.tint,
                    { u_image: gammaSourceTexture, u_tint: diffusionTintRGB },
                    downscaleRect,
                    downscaleRect,
                    [diffusionW, diffusionH],
                    [diffusionW, diffusionH]
                );

                // Upscale the gamma-corrected and tinted diffusion
                gl.viewport(0, 0, tileResolution[0], tileResolution[1]);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.diffusionUpscale.fbo);
                drawQuadWithRegions(
                    progs.upsample,
                    { u_image: tempTintedFBO.texture, u_fullUVRect: [0, 0, 1, 1] },
                    downscaleRect, // source: full downscaled
                    tileRect, // dest: full tile
                    [diffusionW, diffusionH], // source resolution: downscaled size
                    tileResolution // viewport: tile size
                );

                // Return ONLY the diffusion contribution (not added to base)
                diffusionContribution = fboSet.diffusionUpscale.texture;

                // Cleanup temporary FBOs
                gl.deleteFramebuffer(tempDownscaleFBO.fbo);
                gl.deleteTexture(tempDownscaleFBO.texture);
                if (tempPingFBO) { gl.deleteFramebuffer(tempPingFBO.fbo); gl.deleteTexture(tempPingFBO.texture); }
                gl.deleteFramebuffer(tempBlurredFBO.fbo);
                gl.deleteTexture(tempBlurredFBO.texture);
                if (tempPingFBOB) { gl.deleteFramebuffer(tempPingFBOB.fbo); gl.deleteTexture(tempPingFBOB.texture); }
                if (tempBlurredFBOB) { gl.deleteFramebuffer(tempBlurredFBOB.fbo); gl.deleteTexture(tempBlurredFBOB.texture); }
                if (tempPingFBOC) { gl.deleteFramebuffer(tempPingFBOC.fbo); gl.deleteTexture(tempPingFBOC.texture); }
                if (tempBlurredFBOC) { gl.deleteFramebuffer(tempBlurredFBOC.fbo); gl.deleteTexture(tempBlurredFBOC.texture); }
                gl.deleteFramebuffer(tempCombinedFBO.fbo);
                gl.deleteTexture(tempCombinedFBO.texture);
                gl.deleteFramebuffer(tempTintedFBO.fbo);
                gl.deleteTexture(tempTintedFBO.texture);
                if (tempGammaFBO) { gl.deleteFramebuffer(tempGammaFBO.fbo); gl.deleteTexture(tempGammaFBO.texture); }
                gl.deleteFramebuffer(thresholdAdjustedFBO.fbo);
                gl.deleteTexture(thresholdAdjustedFBO.texture);
                gl.deleteFramebuffer(lumaPremulFBO.fbo);
                gl.deleteTexture(lumaPremulFBO.texture);
                if (tempSubtractedFBO) { gl.deleteFramebuffer(tempSubtractedFBO.fbo); gl.deleteTexture(tempSubtractedFBO.texture); }
            }

            // Process Diffusion DEF system if enabled
            let diffusionContribution2 = null;
            if (needsDiffusion2()) {
                const vals3 = { 
                    diffusionStrengthD: parseFloat(diffusionStrengthDSlider.value), 
                    diffusionRadiusD: parseFloat(diffusionRadiusDSlider.value),
                    diffusionStrengthE: parseFloat(diffusionStrengthESlider.value), 
                    diffusionRadiusE: parseFloat(diffusionRadiusESlider.value),
                    diffusionStrengthF: parseFloat(diffusionStrengthFSlider.value), 
                    diffusionRadiusF: parseFloat(diffusionRadiusFSlider.value),
                    diffusionTint2R: parseFloat(diffusionTint2RSlider.value),
                    diffusionTint2G: parseFloat(diffusionTint2GSlider.value),
                    diffusionTint2B: parseFloat(diffusionTint2BSlider.value),
                    diffusionSpread2: parseFloat(diffusionSpread2Slider.value),
                    diffusionGamma2: parseFloat(diffusionGamma2Slider.value),
                    diffusionIntensity2: parseFloat(diffusionIntensity2Slider.value),
                    diffusionThreshold2: parseFloat(diffusionThreshold2Slider.value),
                    diffusionSubtract2: diffusionSubtract2Toggle.checked
                };

                // Create temporary FBOs for DEF processing
                const tempDownscaleFBO2 = createFBO(diffusionW, diffusionH, true);
                const tempBlurredFBOD = createFBO(diffusionW, diffusionH, true);
                const tempBlurredFBOE = createFBO(diffusionW, diffusionH, true);
                const tempBlurredFBOF = createFBO(diffusionW, diffusionH, true);

                // Downscale to 1K (same as ABC)
                const downscaleRect = { x: 0, y: 0, w: diffusionW, h: diffusionH };
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempDownscaleFBO2.fbo);
                gl.viewport(0, 0, diffusionW, diffusionH);
                drawQuadWithRegions(
                    progs.downsample,
                    { u_image: inputTexture, u_fullUVRect: [tileRect.x, tileRect.y, tileRect.w, tileRect.h] },
                    tileRect,
                    downscaleRect,
                    tileResolution,
                    [diffusionW, diffusionH]
                );

                // Apply threshold gain first for DEF system
                const thresholdGain2 = vals3.diffusionThreshold2;
                const thresholdAdjustedFBO2 = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, thresholdAdjustedFBO2.fbo);
                drawQuadWithRegions(
                    progs.applyThresholdGain,
                    { u_image: tempDownscaleFBO2.texture, u_gain: thresholdGain2, u_fullUVRect: [0,0,1,1] },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Get threshold gamma and white values
                const thresholdGamma2 = parseFloat(thresholdGamma2Slider.value);
                const thresholdWhite2 = parseFloat(thresholdWhite2Slider.value);

                // Apply min(r,g,b) keyer for DEF system (on threshold-adjusted image)
                const minDesatKeyerFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, minDesatKeyerFBO.fbo);
                drawQuadWithRegions(progs.minDesaturate, { u_image: thresholdAdjustedFBO2.texture, u_thresholdGamma: thresholdGamma2, u_thresholdWhite: thresholdWhite2 }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);

                // Output RGB (either original or min(r,g,b)) and conditionally premultiply by the key
                const useMinRgb = document.getElementById('diffusionMinRgbToggle') ? document.getElementById('diffusionMinRgbToggle').checked : true;
                const usePremultiply = diffusionPremultiplyToggle.checked;
                const keyPremulFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, keyPremulFBO.fbo);
                drawQuadWithRegions(
                    progs.conditionalRgbPremultiplyWithKey,
                    { u_image: thresholdAdjustedFBO2.texture, u_key: minDesatKeyerFBO.texture, u_useMinRgb: useMinRgb, u_usePremultiply: usePremultiply, u_thresholdGamma: thresholdGamma2, u_thresholdWhite: thresholdWhite2, u_fullUVRect: [0,0,1,1] },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Process D, E, F blurs separately
                const texelSize = [1 / diffusionW, 1 / diffusionH];
                const hasD = (vals3.diffusionStrengthD > 0.0 && vals3.diffusionRadiusD > 0.0);
                const hasE = (vals3.diffusionStrengthE > 0.0 && vals3.diffusionRadiusE > 0.0);
                const hasF = (vals3.diffusionStrengthF > 0.0 && vals3.diffusionRadiusF > 0.0);

                // Diffusion D processing (match ABC LOD + step logic)
                let tempPingFBOD = null;
                if (hasD) {
                    const sigmaD = Math.max(0.5, vals3.diffusionRadiusD * vals3.diffusionSpread2 * nF * scale * 0.2);
                    const radiusD = Math.min(96.0, sigmaD * 6.0);
                    // Smooth LOD interpolation and adaptive step size
                    const lodDFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaD) - 1));
                    const lodD = Math.floor(lodDFloat);
                    const lodDFrac = lodDFloat - lodD;
                    const stepSizeBaseD = Math.pow(2, lodD);
                    const stepSizeNextD = Math.pow(2, Math.min(4, lodD + 1));
                    let smoothStepSizeD = stepSizeBaseD + (stepSizeNextD - stepSizeBaseD) * lodDFrac;
                    smoothStepSizeD = Math.min(smoothStepSizeD, 8.0);
                    tempPingFBOD = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBOD.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: keyPremulFBO.texture, u_step: [smoothStepSizeD * 0.5/diffusionW, 0.0], u_sigma: sigmaD, u_radius: radiusD, u_lod: lodDFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOD.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBOD.texture, u_step: [0.0, smoothStepSizeD * 0.5/diffusionH], u_sigma: sigmaD, u_radius: radiusD, u_lod: lodDFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );

                    // Automatic additional blur D (align behavior with ABC)
                    const autoAdditionalBlurD = calculateAdditionalBlur(vals3.diffusionRadiusD * vals3.diffusionSpread2);
                    if (autoAdditionalBlurD > 0) {
                        const additionalBlurRadius = autoAdditionalBlurD * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        const tempAdditionalBlurFBOD = createFBO(diffusionW, diffusionH, true);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBOD.fbo);
                        drawQuadWithRegions(progs.separableBlur, { u_image: tempBlurredFBOD.texture, u_texelSize: texelSize, u_blurRadius: additionalBlurRadius, u_direction: [1, 0] }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOD.fbo);
                        drawQuadWithRegions(progs.separableBlur, { u_image: tempAdditionalBlurFBOD.texture, u_texelSize: texelSize, u_blurRadius: additionalBlurRadius, u_direction: [0, 1] }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        gl.deleteFramebuffer(tempAdditionalBlurFBOD.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBOD.texture);
                    }
                }

                // Diffusion E processing (match ABC LOD + step logic)
                let tempPingFBOE = null;
                if (hasE) {
                    const sigmaE = Math.max(0.5, vals3.diffusionRadiusE * vals3.diffusionSpread2 * nF * scale * 0.2);
                    const radiusE = Math.min(96.0, sigmaE * 6.0);
                    const lodEFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaE) - 1));
                    const lodE = Math.floor(lodEFloat);
                    const lodEFrac = lodEFloat - lodE;
                    const stepSizeBaseE = Math.pow(2, lodE);
                    const stepSizeNextE = Math.pow(2, Math.min(4, lodE + 1));
                    let smoothStepSizeE = stepSizeBaseE + (stepSizeNextE - stepSizeBaseE) * lodEFrac;
                    smoothStepSizeE = Math.min(smoothStepSizeE, 8.0);
                    tempPingFBOE = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBOE.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: keyPremulFBO.texture, u_step: [smoothStepSizeE * 0.5/diffusionW, 0.0], u_sigma: sigmaE, u_radius: radiusE, u_lod: lodEFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOE.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBOE.texture, u_step: [0.0, smoothStepSizeE * 0.5/diffusionH], u_sigma: sigmaE, u_radius: radiusE, u_lod: lodEFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );

                    const autoAdditionalBlurE = calculateAdditionalBlur(vals3.diffusionRadiusE * vals3.diffusionSpread2);
                    if (autoAdditionalBlurE > 0) {
                        const additionalBlurRadius = autoAdditionalBlurE * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        const tempAdditionalBlurFBOE = createFBO(diffusionW, diffusionH, true);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBOE.fbo);
                        drawQuadWithRegions(progs.separableBlur, { u_image: tempBlurredFBOE.texture, u_texelSize: texelSize, u_blurRadius: additionalBlurRadius, u_direction: [1, 0] }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOE.fbo);
                        drawQuadWithRegions(progs.separableBlur, { u_image: tempAdditionalBlurFBOE.texture, u_texelSize: texelSize, u_blurRadius: additionalBlurRadius, u_direction: [0, 1] }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        gl.deleteFramebuffer(tempAdditionalBlurFBOE.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBOE.texture);
                    }
                }

                // Diffusion F processing (match ABC LOD + step logic)
                let tempPingFBOF = null;
                if (hasF) {
                    const sigmaF = Math.max(0.5, vals3.diffusionRadiusF * vals3.diffusionSpread2 * nF * scale * 0.2);
                    const radiusF = Math.min(96.0, sigmaF * 6.0);
                    const lodFFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaF) - 1));
                    const lodF = Math.floor(lodFFloat);
                    const lodFFrac = lodFFloat - lodF;
                    const stepSizeBaseF = Math.pow(2, lodF);
                    const stepSizeNextF = Math.pow(2, Math.min(4, lodF + 1));
                    let smoothStepSizeF = stepSizeBaseF + (stepSizeNextF - stepSizeBaseF) * lodFFrac;
                    smoothStepSizeF = Math.min(smoothStepSizeF, 8.0);
                    tempPingFBOF = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBOF.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: keyPremulFBO.texture, u_step: [smoothStepSizeF * 0.5/diffusionW, 0.0], u_sigma: sigmaF, u_radius: radiusF, u_lod: lodFFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOF.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBOF.texture, u_step: [0.0, smoothStepSizeF * 0.5/diffusionH], u_sigma: sigmaF, u_radius: radiusF, u_lod: lodFFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );

                    const autoAdditionalBlurF = calculateAdditionalBlur(vals3.diffusionRadiusF * vals3.diffusionSpread2);
                    if (autoAdditionalBlurF > 0) {
                        const additionalBlurRadius = autoAdditionalBlurF * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        const tempAdditionalBlurFBOF = createFBO(diffusionW, diffusionH, true);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBOF.fbo);
                        drawQuadWithRegions(progs.separableBlur, { u_image: tempBlurredFBOF.texture, u_texelSize: texelSize, u_blurRadius: additionalBlurRadius, u_direction: [1, 0] }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOF.fbo);
                        drawQuadWithRegions(progs.separableBlur, { u_image: tempAdditionalBlurFBOF.texture, u_texelSize: texelSize, u_blurRadius: additionalBlurRadius, u_direction: [0, 1] }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        gl.deleteFramebuffer(tempAdditionalBlurFBOF.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBOF.texture);
                    }
                }

                // Combine D, E, F (no individual tints)
                const tempCombinedFBO2 = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempCombinedFBO2.fbo);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Add D with strength
                if (hasD) {
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBOD.texture, u_gain: vals3.diffusionStrengthD },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                }

                // Add E with strength
                if (hasE) {
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBOE.texture, u_gain: vals3.diffusionStrengthE },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                }

                // Add F with strength
                if (hasF) {
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBOF.texture, u_gain: vals3.diffusionStrengthF },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                }

                gl.disable(gl.BLEND);

                // Optional subtract source for DEF system
                let sourceForTinting2 = tempCombinedFBO2.texture;
                let tempSubtractedFBO2 = null;
                if (vals3.diffusionSubtract2) {
                    tempSubtractedFBO2 = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempSubtractedFBO2.fbo);
                    drawQuadWithRegions(
                        progs.subtract,
                        { u_imageA: tempCombinedFBO2.texture, u_imageB: keyPremulFBO.texture },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    sourceForTinting2 = tempSubtractedFBO2.texture;
                }

                // Apply gamma to DEF diffusion
                let gammaSourceTexture2 = sourceForTinting2;
                let tempGammaFBO2 = null;
                if (vals3.diffusionGamma2 !== 1.0) {
                    tempGammaFBO2 = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempGammaFBO2.fbo);
                    drawQuadWithRegions(
                        progs.gamma,
                        { u_image: sourceForTinting2, u_gamma: vals3.diffusionGamma2 },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gammaSourceTexture2 = tempGammaFBO2.texture;
                }

                // Apply master RGB tint to DEF diffusion after gamma
                const tempTintedFBO2 = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempTintedFBO2.fbo);
                drawQuadWithRegions(
                    progs.tint,
                    { u_image: gammaSourceTexture2, u_tint: [vals3.diffusionTint2R, vals3.diffusionTint2G, vals3.diffusionTint2B] },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Apply intensity to DEF diffusion
                const tempIntensityFBO2 = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempIntensityFBO2.fbo);
                drawQuadWithRegions(
                    progs.grade,
                    { u_image: tempTintedFBO2.texture, u_gain: vals3.diffusionIntensity2 },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Merge ABC and DEF diffusion contributions
                const tempMergedFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempMergedFBO.fbo);
                if (diffusionContribution) {
                    // If ABC exists, add DEF to it
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.ONE, gl.ONE);
                    drawQuadWithRegions(progs.passthrough, { u_image: diffusionContribution }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                    drawQuadWithRegions(progs.passthrough, { u_image: tempIntensityFBO2.texture }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                    gl.disable(gl.BLEND);
                    diffusionContribution = tempMergedFBO.texture;
                } else {
                    // If no ABC, just use DEF
                    drawQuadWithRegions(progs.passthrough, { u_image: tempIntensityFBO2.texture }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                    diffusionContribution = tempMergedFBO.texture;
                }

                // Cleanup DEF temporary FBOs
                gl.deleteFramebuffer(tempDownscaleFBO2.fbo); gl.deleteTexture(tempDownscaleFBO2.texture);
                gl.deleteFramebuffer(thresholdAdjustedFBO2.fbo); gl.deleteTexture(thresholdAdjustedFBO2.texture);
                gl.deleteFramebuffer(minDesatKeyerFBO.fbo); gl.deleteTexture(minDesatKeyerFBO.texture);
                gl.deleteFramebuffer(keyPremulFBO.fbo); gl.deleteTexture(keyPremulFBO.texture);
                if (tempPingFBOD) { gl.deleteFramebuffer(tempPingFBOD.fbo); gl.deleteTexture(tempPingFBOD.texture); }
                if (tempPingFBOE) { gl.deleteFramebuffer(tempPingFBOE.fbo); gl.deleteTexture(tempPingFBOE.texture); }
                if (tempPingFBOF) { gl.deleteFramebuffer(tempPingFBOF.fbo); gl.deleteTexture(tempPingFBOF.texture); }
                gl.deleteFramebuffer(tempBlurredFBOD.fbo); gl.deleteTexture(tempBlurredFBOD.texture);
                gl.deleteFramebuffer(tempBlurredFBOE.fbo); gl.deleteTexture(tempBlurredFBOE.texture);
                gl.deleteFramebuffer(tempBlurredFBOF.fbo); gl.deleteTexture(tempBlurredFBOF.texture);
                gl.deleteFramebuffer(tempCombinedFBO2.fbo); gl.deleteTexture(tempCombinedFBO2.texture);
                gl.deleteFramebuffer(tempTintedFBO2.fbo); gl.deleteTexture(tempTintedFBO2.texture);
                gl.deleteFramebuffer(tempIntensityFBO2.fbo); gl.deleteTexture(tempIntensityFBO2.texture);
                if (tempGammaFBO2) { gl.deleteFramebuffer(tempGammaFBO2.fbo); gl.deleteTexture(tempGammaFBO2.texture); }
                if (tempSubtractedFBO2) { gl.deleteFramebuffer(tempSubtractedFBO2.fbo); gl.deleteTexture(tempSubtractedFBO2.texture); }
                // Don't delete tempMergedFBO as it contains the final result
            }

            return diffusionContribution;
        }

        async function renderTiled() {
            const accumulatorFBO = createFBO(canvas.width, canvas.height, false);
            const tilesX = Math.ceil(canvas.width / TILE_SIZE);
            const tilesY = Math.ceil(canvas.height / TILE_SIZE);

            const nF = Math.max(canvas.width, canvas.height) / 3840.0;
            const maxBlurRadius = nF * Math.max(parseFloat(mtfMaskSlider.value), parseFloat(mtfSoftnessSlider.value), parseFloat(coreBlurSlider.value), parseFloat(midBlurSlider.value), parseFloat(outerBlurSlider.value), parseFloat(highPassRadiusSlider.value));
            const MAX_OVERLAP = 512;
            const overlap = Math.min(MAX_OVERLAP, Math.ceil(maxBlurRadius * BLUR_OVERLAP_FACTOR));

            // Pre-compute diffusion at 1K for entire canvas if needed
            let globalDiffusionBuffer = null;
            if (needsAnyDiffusion()) {
                globalDiffusionBuffer = await preComputeGlobal1KDiffusion();
            }

            outer: for (let y = 0; y < tilesY; y++) {
                for (let x = 0; x < tilesX; x++) {
                    if (suppressRenders) { break outer; }
                    const tileX = x * TILE_SIZE;
                    const tileY = y * TILE_SIZE;
                    const tileW = Math.min(TILE_SIZE, canvas.width - tileX);
                    const tileH = Math.min(TILE_SIZE, canvas.height - tileY);
                    
                    const srcX = Math.max(0, tileX - overlap);
                    const srcY = Math.max(0, tileY - overlap);
                    const srcW = Math.min(canvas.width - srcX, tileW + (tileX > 0 ? overlap : 0) + ((tileX + tileW < canvas.width) ? overlap : 0));
                    const srcH = Math.min(canvas.height - srcY, tileH + (tileY > 0 ? overlap : 0) + ((tileY + tileH < canvas.height) ? overlap : 0));
                    
                    initTileFBOs(srcW, srcH);
                    
                    const srcRect = { x: srcX, y: srcY, w: srcW, h: srcH };
                    const destRect = { x: 0, y: 0, w: srcW, h: srcH };
                    
                    gl.viewport(0, 0, srcW, srcH);
                    
                    // Use pipeline with pre-baked 1K diffusion sampling
                    runRenderPipelineWithGlobalDiffusion(srcRect, destRect, false, tileFBOs, [srcW, srcH], globalDiffusionBuffer);
                    
                    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, tileFBOs.sprocketApplied.fbo);
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, accumulatorFBO.fbo);
                    
                    const blitSrcX = tileX > 0 ? overlap : 0;
                    const blitSrcY = tileY > 0 ? overlap : 0;
                    
                    gl.blitFramebuffer(
                        blitSrcX, blitSrcY, blitSrcX + tileW, blitSrcY + tileH,
                        tileX, tileY, tileX + tileW, tileY + tileH,
                        gl.COLOR_BUFFER_BIT, gl.NEAREST
                    );
                    
                    tileFBOs = cleanupFBOs(tileFBOs);
                    
                    await new Promise(resolve => requestAnimationFrame(resolve));
                }
            }
            
            // Clean up global diffusion buffer
            if (globalDiffusionBuffer) {
                gl.deleteFramebuffer(globalDiffusionBuffer.fbo);
                gl.deleteTexture(globalDiffusionBuffer.texture);
                gl.flush();
                await new Promise(resolve => requestAnimationFrame(resolve));
            }
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.disable(gl.BLEND);
            const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
            const crop = getAnimatedCropRect(canvas.width, canvas.height, false);
            const destX = Math.floor((canvas.width - crop.w) / 2);
            const destY = Math.floor((canvas.height - crop.h) / 2);
            const destRect = { x: destX, y: destY, w: crop.w, h: crop.h };
            drawQuadWithRegions(progs.passthrough, { u_image: accumulatorFBO.texture }, crop, destRect, [canvas.width, canvas.height]);

            gl.deleteFramebuffer(accumulatorFBO.fbo);
            gl.deleteTexture(accumulatorFBO.texture);
        }
        
        async function renderFullResolution(isSimple) {
            const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
            const fullResolution = [canvas.width, canvas.height];
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            if (returnMinBtn.classList.contains('active')) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.disable(gl.BLEND);
                drawQuadWithRegions(progs.solidColor, { u_color: minPixelValue }, fullRect, fullRect, fullResolution);
                return;
            }
            if (returnMaxBtn && returnMaxBtn.classList.contains('active')) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.disable(gl.BLEND);
                drawQuadWithRegions(progs.solidColor, { u_color: maxPixelValue }, fullRect, fullRect, fullResolution);
                return;
            }
            if (returnMaxSourceBtn && returnMaxSourceBtn.classList.contains('active') && maxPixelSampleCanvas) {
                // Display the 512px sampled image directly to canvas
                const ctx2d = canvas.getContext('2d');
                ctx2d.clearRect(0, 0, canvas.width, canvas.height);
                // Scale the 512px sample to fit the canvas while maintaining aspect ratio
                const scaleX = canvas.width / 512;
                const scaleY = canvas.height / 512;
                const scale = Math.min(scaleX, scaleY);
                const drawWidth = 512 * scale;
                const drawHeight = 512 * scale;
                const offsetX = (canvas.width - drawWidth) / 2;
                const offsetY = (canvas.height - drawHeight) / 2;
                ctx2d.imageSmoothingEnabled = false; // Keep nearest neighbor for display too
                ctx2d.drawImage(maxPixelSampleCanvas, offsetX, offsetY, drawWidth, drawHeight);
                return;
            }
            
            // Use global 1K diffusion approach for consistency
            let globalDiffusionBuffer = null;
            if (needsDiffusion() && !isSimple) {
                globalDiffusionBuffer = await preComputeGlobal1KDiffusion();
            }
            
            if (globalDiffusionBuffer) {
                runRenderPipelineWithGlobalDiffusion(fullRect, fullRect, isSimple, fbos, fullResolution, globalDiffusionBuffer);
                // Clean up diffusion buffer
                gl.deleteFramebuffer(globalDiffusionBuffer.fbo);
                gl.deleteTexture(globalDiffusionBuffer.texture);
            } else {
                runRenderPipeline(fullRect, fullRect, isSimple, fbos, fullResolution);
            }
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.disable(gl.BLEND);
            const crop = getAnimatedCropRect(canvas.width, canvas.height, false);
            const destX = Math.floor((canvas.width - crop.w) / 2);
            const destY = Math.floor((canvas.height - crop.h) / 2);
            const destRect = { x: destX, y: destY, w: crop.w, h: crop.h };
            drawQuadWithRegions(progs.passthrough, {u_image: fbos.sprocketApplied.texture }, crop, destRect, [fbos.sprocketApplied.width, fbos.sprocketApplied.height]);
        }

        // --- CPU-based tile assembly for export ---
        function readTileImageData(fbo, blitSrcX, blitSrcY, tileW, tileH) {
            const size = tileW * tileH * 4;
            const pixels = new Uint8Array(size);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.readPixels(blitSrcX, blitSrcY, tileW, tileH, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            const imageData = new ImageData(tileW, tileH);
            const dst = imageData.data;
            const rowBytes = tileW * 4;
            for (let ty = 0; ty < tileH; ty++) {
                const srcRow = (tileH - 1 - ty);
                const srcOffset = srcRow * rowBytes;
                const dstOffset = ty * rowBytes;
                dst.set(pixels.subarray(srcOffset, srcOffset + rowBytes), dstOffset);
            }
            return imageData;
        }

        async function exportTiledToCPUAndSave(targetMaxDim, filename) {
            const debugStart = performance.now();
            // Determine export dimensions from original image + target max
            const oW = originalImageDimensions.w || canvas.width;
            const oH = originalImageDimensions.h || canvas.height;
            // Compute scaled document and crop to meet target
            const layout = computeExportDocAndCrop(oW, oH, targetMaxDim);
            const exportW = layout.docW, exportH = layout.docH;
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportW; exportCanvas.height = exportH;
            const ctx = exportCanvas.getContext('2d');

            // Override global resolution for shaders and overscan calculators
            globalResolutionOverride = [exportW, exportH];
            virtualCanvasSize = { w: exportW, h: exportH };
            calculateOverscanScales();

            // Precompute a single 1K diffusion buffer for entire export if needed
            let globalDiffusionBuffer = null;
            if (needsAnyDiffusion()) {
                globalDiffusionBuffer = await preComputeGlobal1KDiffusion();
            }

            const tileSize = (bandedCPUToggle && bandedCPUToggle.checked) ? 512 : TILE_SIZE;
            const tilesX = Math.ceil(exportW / tileSize);
            const tilesY = Math.ceil(exportH / tileSize);

            const nF = Math.max(exportW, exportH) / 3840.0;
            const maxBlurRadius = nF * Math.max(
                parseFloat(mtfMaskSlider.value),
                parseFloat(mtfSoftnessSlider.value),
                parseFloat(coreBlurSlider.value),
                parseFloat(midBlurSlider.value),
                parseFloat(outerBlurSlider.value),
                parseFloat(highPassRadiusSlider.value)
            );
            const MAX_OVERLAP = 512;
            const overlap = Math.min(MAX_OVERLAP, Math.ceil(maxBlurRadius * BLUR_OVERLAP_FACTOR));

            for (let y = 0; y < tilesY; y++) {
                for (let x = 0; x < tilesX; x++) {
                    const tileX = x * tileSize;
                    const tileY = y * tileSize;
                    const tileW = Math.min(tileSize, exportW - tileX);
                    const tileH = Math.min(tileSize, exportH - tileY);

                    const srcX = Math.max(0, tileX - overlap);
                    const srcY = Math.max(0, tileY - overlap);
                    const srcW = Math.min(exportW - srcX, tileW + (tileX > 0 ? overlap : 0) + ((tileX + tileW < exportW) ? overlap : 0));
                    const srcH = Math.min(exportH - srcY, tileH + (tileY > 0 ? overlap : 0) + ((tileY + tileH < exportH) ? overlap : 0));

                    initTileFBOs(srcW, srcH);
                    const srcRect = { x: srcX, y: srcY, w: srcW, h: srcH };
                    const destRect = { x: 0, y: 0, w: srcW, h: srcH };
                    gl.viewport(0, 0, srcW, srcH);

                    runRenderPipelineWithGlobalDiffusion(srcRect, destRect, false, tileFBOs, [srcW, srcH], globalDiffusionBuffer);

                    const blitSrcX = tileX > 0 ? overlap : 0;
                    const blitSrcY = tileY > 0 ? overlap : 0;
                    const tileImageData = readTileImageData(tileFBOs.sprocketApplied.fbo, blitSrcX, blitSrcY, tileW, tileH);
                    const destYTop = exportH - tileY - tileH;
                    ctx.putImageData(tileImageData, tileX, destYTop);

                    tileFBOs = cleanupFBOs(tileFBOs);
                    await new Promise(r => requestAnimationFrame(r));
                }
            }

            // Clean up diffusion buffer
            if (globalDiffusionBuffer) {
                gl.deleteFramebuffer(globalDiffusionBuffer.fbo);
                gl.deleteTexture(globalDiffusionBuffer.texture);
            }

            // If cropping is requested, crop the assembled doc to final aspect before saving
            let finalCanvas = exportCanvas;
            if (currentShapeIsBorder() && (window.__docAspectMode || '16:9') !== '16:9') {
                const crop = layout.crop;
                const cropped = document.createElement('canvas');
                cropped.width = crop.w; cropped.height = crop.h;
                const cctx = cropped.getContext('2d');
                cctx.drawImage(exportCanvas, crop.x, crop.y, crop.w, crop.h, 0, 0, crop.w, crop.h);
                finalCanvas = cropped;
            }

            // Save result
            if (typeof Capacitor !== 'undefined' && Capacitor.isNativePlatform()) {
                try {
                    const base64Data = finalCanvas.toDataURL('image/png').replace(/^data:image\/png;base64,/, '');
                    const { Filesystem, Media } = Capacitor.Plugins;
                    const savedFile = await Filesystem.writeFile({ path: filename, data: base64Data, directory: 'CACHE' });
                    await Media.savePhoto({ path: savedFile.uri, album: { name: 'Halation', create: true } });
                    await Filesystem.deleteFile({ path: filename, directory: 'CACHE' });
                    if (!isBatchExportMode) alert('Image saved to Halation album!');
                } catch (e) {
                    console.error('CPU export save error:', e);
                    if (!isBatchExportMode) alert(`Could not save image: ${e.message || 'Unknown'}`);
                }
            } else {
                if (finalCanvas.convertToBlob) {
                    const blob = await finalCanvas.convertToBlob({ type: 'image/png' });
                    const link = document.createElement('a');
                    link.download = filename;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    setTimeout(()=>URL.revokeObjectURL(link.href), 1000);
                } else {
                    const dataUrl = finalCanvas.toDataURL('image/png');
                    const link = document.createElement('a'); link.download = filename; link.href = dataUrl; link.click();
                }
            }

            // Clear overrides
            globalResolutionOverride = null;
            virtualCanvasSize = null;
            calculateOverscanScales();

            // Debug timing
            const ms = (performance.now() - debugStart).toFixed(0);
            const mode = (bandedCPUToggle && bandedCPUToggle.checked) ? 'banded' : 'normal';
            console.log(`[DEBUG] CPU export done ${exportW}x${exportH}, tiles=${tilesX}x${tilesY}, tileSize=${tileSize}, mode=${mode}, total=${ms}ms`);
        }

        function renderPreviewResolution() {
            // For preview, use a reasonable scale that maintains quality while being performant
            let targetResolution = 2048;
            
            if (isHolding) {
                // When holding, use the actual working resolution from the slider to match the rendered image
                const maxResSlider = document.getElementById('maxResSlider');
                if (maxResSlider) {
                    const rawSlider = maxResSlider.value;
                    const isOriginalMax = parseInt(rawSlider, 10) >= ORIGINAL_SLIDER_VALUE;
                    
                    if (isOriginalMax) {
                        targetResolution = Math.max(canvas.width, canvas.height); // Use actual canvas size for "original"
                    } else {
                        // Apply the aspect ratio multiplier to the slider value for hold preview
                        const aspectMultiplier = getAspectRatioMultiplier();
                        targetResolution = Math.round(parseInt(rawSlider, 10) * aspectMultiplier);
                    }
                }
            }
            
            const scale = Math.min(1.0, targetResolution / Math.max(canvas.width, canvas.height));
            const previewW = Math.floor(canvas.width * scale);
            const previewH = Math.floor(canvas.height * scale);
            const previewSrcRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
            const previewDestRect = { x: 0, y: 0, w: previewW, h: previewH };
            const previewResolution = [previewW, previewH];

            // Use dedicated preview-sized FBOs to avoid any mismatch
            initPreviewFBOs(previewW, previewH);

            gl.viewport(0, 0, previewW, previewH);
            runRenderPipeline(previewSrcRect, previewDestRect, true, previewFBOs, previewResolution);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.disable(gl.BLEND);
            const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
            // Compute crop in both preview and full-canvas spaces so the on-canvas size matches full render
            const cropPrev = getAnimatedCropRect(previewW, previewH, true);
            const cropFull = getAnimatedCropRect(canvas.width, canvas.height, false);

            // Center the full-size crop area in the canvas
            const destX = Math.floor((canvas.width - cropFull.w) / 2);
            const destY = Math.floor((canvas.height - cropFull.h) / 2);
            const destRect = { x: destX, y: destY, w: cropFull.w, h: cropFull.h };
            // Sample from preview texture's crop and scale up to the full-canvas crop area
            drawQuadWithRegions(progs.passthrough, { u_image: previewFBOs.sprocketApplied.texture }, cropPrev, destRect, previewResolution, [canvas.width, canvas.height]);
        }
        function runRenderPipelineWithGlobalDiffusion(srcRect, destRect, isSimple, fboSet, viewportSize, globalDiffusionBuffer) {
            const tileRect = { x: 0, y: 0, w: destRect.w, h: destRect.h };
            const globalResolution = (globalResolutionOverride ? [globalResolutionOverride[0], globalResolutionOverride[1]] : [canvas.width, canvas.height]);
            const tileResolution = viewportSize;
            const useRaw = (chromaPreviewActive || isHolding) && rawImageTexture && rawSrgbTexture;
            const srcTex = useRaw ? rawImageTexture : imageTexture;
            const srcSrgb = useRaw ? rawSrgbTexture : originalSrgbTexture;
            
            const vals={imageScale:parseFloat(imageScaleSlider.value), blackLevelBias:parseFloat(blackLevelBiasSlider.value), borderScale:parseFloat(borderScaleSlider.value), sprocketContrast:parseFloat(sprocketContrastSlider.value), cheatAspectX:parseFloat(cheatAspectXSlider.value), cheatAspectY:parseFloat(cheatAspectYSlider.value)};
            const biasedMinPixelValue = [minPixelValue[0] * vals.blackLevelBias, minPixelValue[1] * vals.blackLevelBias, minPixelValue[2] * vals.blackLevelBias];
            const nF = Math.max(canvas.width,canvas.height)/3840.0;
            const is8mm = (window.__borderEngine === '8mm');
            const is16mm = (window.__borderEngine === '16mm');
            const is35mm178 = (window.__borderEngine === '35mm-178');
            const is35mm240 = (window.__borderEngine === '35mm-240');
            const is35mm133 = (window.__borderEngine === '35mm-133');
            const is35mmAdd = (window.__borderEngine === '35mm-add');
            const isMediumFormat = (window.__borderEngine === 'medium-format');
            const isSpecialEngine = is8mm || is16mm || is35mm178 || is35mm240 || is35mm133 || is35mmAdd || isMediumFormat;

            // Calculate final image scale with blur compensation
            let finalImageScale = vals.imageScale;
            if (isSpecialEngine && !is35mmAdd && !isMediumFormat) {
                const blurRadius = parseFloat(borderBlurSlider.value);
                const BLUR_TO_SCALE_COMPENSATION = 0.001;
                finalImageScale += blurRadius * BLUR_TO_SCALE_COMPENSATION;
            }

            // Run border composition (same as standard pipeline)
            if (isSpecialEngine) {
                let zoneBDims;
                if (is8mm) {
                    zoneBDims = [3028.0, 2016.0];
                } else if (is16mm) {
                    zoneBDims = [3499.0, 2115.0];
                } else if (is35mm178) {
                    zoneBDims = [3691.0, 2084.0];
                } else if (is35mm240) {
                    zoneBDims = [3679.0, 1550.0];
                } else if (is35mm133) {
                    zoneBDims = [3028.0, 2016.0];
                } else if (is35mmAdd) {
                    zoneBDims = [2240.0, 1516.0];
                } else if (isMediumFormat) {
                    zoneBDims = [2448.0, 2000.0];
                }
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const programToUse = (is35mmAdd || isMediumFormat) ? progs.borderComposite35add : progs.borderComposite8mm;
                const nW3 = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const nH3 = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                const nativeLongShort3 = (Math.max(nW3, nH3) / Math.max(1, Math.min(nW3, nH3)));
                drawQuadWithRegions(programToUse, {
                    u_source: srcTex,
                    u_gateTexture: borderTexture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_borderScale: vals.borderScale,
                    u_imageScale: finalImageScale,
                    u_adjacentFrameDistance: is35mmAdd ? (1.06 + parseFloat(framePaddingSlider.value)) : isMediumFormat ? (1.10 + parseFloat(framePaddingSlider.value)) : (parseFloat(adjacentFrameDistanceSlider.value) / 100.0) + parseFloat(framePaddingSlider.value),
                    u_framing: parseFloat(framingSlider.value),
                    u_nativeSourceAspect: nativeLongShort3,
                    u_framingLimit: 1.0,
                    u_canvasResolution: globalResolution,
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h],
                    u_borderResolution: [3840, 2160],
                    u_zoneBDims: zoneBDims,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                }, srcRect, destRect, globalResolution, tileResolution);
            } else {
                const disableAC = false;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.triptychComposite.fbo);
                const nW4 = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const nH4 = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                const nativeLongShort4 = (Math.max(nW4, nH4) / Math.max(1, Math.min(nW4, nH4)));
                drawQuadWithRegions(progs.triptychCompositor, { 
                    u_source: srcTex, 
                    u_maskA: maskATexture, 
                    u_maskB: maskBTexture, 
                    u_maskC: maskCTexture,
                    u_borderScale: vals.borderScale, 
                    u_imageScale: finalImageScale,
                    u_canvasResolution: globalResolution, 
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h], 
                    u_borderResolution: [3840, 2160], 
                    u_disableAC: disableAC,
                    u_is8mmEngine: is8mm,
                    u_adjacentFrameDistance: parseFloat(adjacentFrameDistanceSlider.value) / 100.0,
                    u_framing: parseFloat(framingSlider.value),
                    u_zoneBDims: [2240.0, 1516.0],
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_nativeSourceAspect: nativeLongShort4,
                    u_framingLimit: 1.0,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                }, srcRect, destRect, globalResolution, tileResolution);

                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
                drawQuadWithRegions(progs.borderOverlay, {
                    u_base: fboSet.triptychComposite.texture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_fullUVRect: fullUVRect,
                    u_border: borderTexture,
                    u_borderScale: vals.borderScale,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_canvasResolution: globalResolution,
                    u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160]
                }, tileRect, destRect, tileResolution, tileResolution);
            }
            
            let currentResult = fboSet.borderApplied.texture;
            
            // Optionally suppress overlays (used during engine swaps)
            if (window.__suppressOverlays) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
                drawQuadWithRegions(progs.passthrough, { u_image: currentResult }, tileRect, destRect, tileResolution, tileResolution);
                return;
            }

            if (isPreviewingBorder) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
                const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
                let sprocketSizeScale = 1.0;
                let sprocketTranslation = 1.0;
                
                if (is16mm) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket16mmScale') && document.getElementById('sprocket16mmScale').value) || '1') + 0.23;
                    sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1') + 0.02;
                } else if (is35mm178) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm178Scale') && document.getElementById('sprocket35mm178Scale').value) || '1') + sprocketScaleOffsets['35mm-178'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm178Translation') && document.getElementById('sprocket35mm178Translation').value) || '1');
                } else if (is35mm240) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm240Scale') && document.getElementById('sprocket35mm240Scale').value) || '1') + sprocketScaleOffsets['35mm-240'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm240Translation') && document.getElementById('sprocket35mm240Translation').value) || '1');
                } else if (is35mm133) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm133Scale') && document.getElementById('sprocket35mm133Scale').value) || '1') + sprocketScaleOffsets['35mm-133'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm133Translation') && document.getElementById('sprocket35mm133Translation').value) || '1');
                } else {
                    sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1');
                }
                drawQuadWithRegions(progs.sprocketOverlay, { u_base: currentResult, u_overlay: sprocketTexture, u_borderScale: vals.borderScale, u_sprocketScale: sprocketTranslation, u_sprocketSizeScale: sprocketSizeScale, u_canvasResolution: globalResolution, u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160], u_sprocketContrast: vals.sprocketContrast, u_fullUVRect: fullUVRect }, tileRect, destRect, tileResolution, tileResolution);
                return;
            }

            if (!isSimple) {
                if (halationEnabledToggle.checked && supportsFloat) {
                    // Sample from pre-baked global 1K diffusion instead of computing per-tile
                    if (globalDiffusionBuffer) {
                        runHalationPassWithGlobalDiffusion(currentResult, nF, tileRect, destRect, fboSet, tileResolution, globalDiffusionBuffer, srcRect);
                    } else {
                        runHalationPassWithoutDiffusion(currentResult, nF, tileRect, destRect, fboSet, tileResolution);
                    }
                    currentResult = fboSet.finalTonemapped.texture;
                }
                if (textureEnabledToggle.checked) {
                    runTexturePass(currentResult, nF, tileRect, destRect, fboSet, tileResolution, globalResolution, [srcRect.x, srcRect.y, srcRect.w, srcRect.h]);
                    currentResult = fboSet.postcurve.texture;
                }
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
            const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
            let sprocketSizeScale = 1.0;
            let sprocketTranslation = 1.0;
            
            if (is16mm) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket16mmScale') && document.getElementById('sprocket16mmScale').value) || '1') + 0.23;
                sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1') + 0.02;
            } else if (is35mm178) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm178Scale') && document.getElementById('sprocket35mm178Scale').value) || '1') + sprocketScaleOffsets['35mm-178'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm178Translation') && document.getElementById('sprocket35mm178Translation').value) || '1');
            } else if (is35mm240) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm240Scale') && document.getElementById('sprocket35mm240Scale').value) || '1') + sprocketScaleOffsets['35mm-240'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm240Translation') && document.getElementById('sprocket35mm240Translation').value) || '1');
            } else if (is35mm133) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm133Scale') && document.getElementById('sprocket35mm133Scale').value) || '1') + sprocketScaleOffsets['35mm-133'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm133Translation') && document.getElementById('sprocket35mm133Translation').value) || '1');
            } else {
                sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1');
            }
            drawQuadWithRegions(progs.sprocketOverlay, { u_base: currentResult, u_overlay: sprocketTexture, u_borderScale: vals.borderScale, u_sprocketScale: sprocketTranslation, u_sprocketSizeScale: sprocketSizeScale, u_canvasResolution: globalResolution, u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160], u_sprocketContrast: vals.sprocketContrast, u_extendEdges: isSpecialEngine, u_fullUVRect: fullUVRect }, tileRect, destRect, tileResolution, tileResolution);
        }

        // This function is now deprecated - replaced with runHalationPassWith1KDiffusion
        function runRenderPipelineWithPrecomputedDiffusion_DEPRECATED(srcRect, destRect, isSimple, fboSet, viewportSize, precomputedDiffusion, tileX, tileY, tileW, tileH) {
            const tileRect = { x: 0, y: 0, w: destRect.w, h: destRect.h };
            const globalResolution = [canvas.width, canvas.height];
            const tileResolution = viewportSize;
            
            const vals={imageScale:parseFloat(imageScaleSlider.value), blackLevelBias:parseFloat(blackLevelBiasSlider.value), borderScale:parseFloat(borderScaleSlider.value), sprocketContrast:parseFloat(sprocketContrastSlider.value), cheatAspectX:parseFloat(cheatAspectXSlider.value), cheatAspectY:parseFloat(cheatAspectYSlider.value)};
            const biasedMinPixelValue = [minPixelValue[0] * vals.blackLevelBias, minPixelValue[1] * vals.blackLevelBias, minPixelValue[2] * vals.blackLevelBias];
            const nF = Math.max(canvas.width,canvas.height)/3840.0;
            const is8mm = (window.__borderEngine === '8mm');
            const is16mm = (window.__borderEngine === '16mm');
            const is35mm178 = (window.__borderEngine === '35mm-178');
            const is35mm240 = (window.__borderEngine === '35mm-240');
            const is35mm133 = (window.__borderEngine === '35mm-133');
            const is35mmAdd = (window.__borderEngine === '35mm-add');
            const isMediumFormat = (window.__borderEngine === 'medium-format');
            const isSpecialEngine = is8mm || is16mm || is35mm178 || is35mm240 || is35mm133 || is35mmAdd || isMediumFormat;

            // Calculate final image scale with blur compensation.
            let finalImageScale = vals.imageScale;
            if (isSpecialEngine && !is35mmAdd && !isMediumFormat) {
                const blurRadius = parseFloat(borderBlurSlider.value);
                const BLUR_TO_SCALE_COMPENSATION = 0.001;
                finalImageScale += blurRadius * BLUR_TO_SCALE_COMPENSATION;
            }

            if (isSpecialEngine) {
                let zoneBDims;
                if (is8mm) {
                    zoneBDims = [3028.0, 2016.0];
                } else if (is16mm) {
                    zoneBDims = [3499.0, 2115.0];
                } else if (is35mm178) {
                    zoneBDims = [3691.0, 2084.0];
                } else if (is35mm240) {
                    zoneBDims = [3679.0, 1550.0];
                } else if (is35mm133) {
                    zoneBDims = [3028.0, 2016.0];
                } else if (is35mmAdd) {
                    zoneBDims = [2240.0, 1516.0];
                } else if (isMediumFormat) {
                    zoneBDims = [2448.0, 2000.0];
                }
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const programToUse = (is35mmAdd || isMediumFormat) ? progs.borderComposite35add : progs.borderComposite8mm;
                const nW7 = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const nH7 = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                const nativeLongShort7 = (Math.max(nW7, nH7) / Math.max(1, Math.min(nW7, nH7)));
                drawQuadWithRegions(programToUse, {
                    u_source: imageTexture,
                    u_gateTexture: borderTexture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_borderScale: vals.borderScale,
                    u_imageScale: finalImageScale,
                    u_adjacentFrameDistance: is35mmAdd ? (1.06 + parseFloat(framePaddingSlider.value)) : isMediumFormat ? (1.10 + parseFloat(framePaddingSlider.value)) : (parseFloat(adjacentFrameDistanceSlider.value) / 100.0) + parseFloat(framePaddingSlider.value),
                    u_framing: parseFloat(framingSlider.value),
                    u_nativeSourceAspect: nativeLongShort7,
                    u_framingLimit: 1.0,
                    u_canvasResolution: globalResolution,
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h],
                    u_borderResolution: [3840, 2160],
                    u_zoneBDims: zoneBDims,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                }, srcRect, destRect, globalResolution, tileResolution);
            } else {
                const disableAC = false;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.triptychComposite.fbo);
                const nW8 = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const nH8 = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                const nativeLongShort8 = (Math.max(nW8, nH8) / Math.max(1, Math.min(nW8, nH8)));
                drawQuadWithRegions(progs.triptychCompositor, { 
                    u_source: imageTexture, 
                    u_maskA: maskATexture, 
                    u_maskB: maskBTexture, 
                    u_maskC: maskCTexture,
                    u_borderScale: vals.borderScale, 
                    u_imageScale: finalImageScale,
                    u_canvasResolution: globalResolution, 
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h], 
                    u_borderResolution: [3840, 2160], 
                    u_disableAC: disableAC,
                    u_is8mmEngine: is8mm,
                    u_adjacentFrameDistance: parseFloat(adjacentFrameDistanceSlider.value) / 100.0,
                    u_framing: parseFloat(framingSlider.value),
                    u_zoneBDims: [2240.0, 1516.0],
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_nativeSourceAspect: nativeLongShort8,
                    u_framingLimit: 1.0,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                 }, srcRect, destRect, globalResolution, tileResolution);

                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
                drawQuadWithRegions(progs.borderOverlay, {
                    u_base: fboSet.triptychComposite.texture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_fullUVRect: fullUVRect,
                    u_border: borderTexture,
                    u_borderScale: vals.borderScale,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_canvasResolution: globalResolution,
                    u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160]
                }, tileRect, destRect, tileResolution, tileResolution);
            }
            
            let currentResult = fboSet.borderApplied.texture;
            
            // Optionally suppress overlays (used during engine swaps)
            if (window.__suppressOverlays) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
                drawQuadWithRegions(progs.passthrough, { u_image: currentResult }, tileRect, destRect, tileResolution, tileResolution);
                return;
            }

            if (isPreviewingBorder) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
                const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
                let sprocketSizeScale = 1.0;
                let sprocketTranslation = 1.0;
                
                if (is16mm) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket16mmScale') && document.getElementById('sprocket16mmScale').value) || '1') + 0.23;
                    sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1') + 0.02;
                } else if (is35mm178) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm178Scale') && document.getElementById('sprocket35mm178Scale').value) || '1') + sprocketScaleOffsets['35mm-178'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm178Translation') && document.getElementById('sprocket35mm178Translation').value) || '1');
                } else if (is35mm240) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm240Scale') && document.getElementById('sprocket35mm240Scale').value) || '1') + sprocketScaleOffsets['35mm-240'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm240Translation') && document.getElementById('sprocket35mm240Translation').value) || '1');
                } else if (is35mm133) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm133Scale') && document.getElementById('sprocket35mm133Scale').value) || '1') + sprocketScaleOffsets['35mm-133'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm133Translation') && document.getElementById('sprocket35mm133Translation').value) || '1');
                } else {
                    sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1');
                }
                drawQuadWithRegions(progs.sprocketOverlay, { u_base: currentResult, u_overlay: sprocketTexture, u_borderScale: vals.borderScale, u_sprocketScale: sprocketTranslation, u_sprocketSizeScale: sprocketSizeScale, u_canvasResolution: globalResolution, u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160], u_sprocketContrast: vals.sprocketContrast, u_fullUVRect: fullUVRect }, tileRect, destRect, tileResolution, tileResolution);
                return;
            }

            if (!isSimple) {
                if (halationEnabledToggle.checked && supportsFloat) {
                    if (precomputedDiffusion) {
                        // Use pre-computed diffusion approach
                        runHalationPassWithPrecomputedDiffusion(currentResult, nF, tileRect, destRect, fboSet, tileResolution, precomputedDiffusion, srcRect);
                    } else {
                        // Use regular halation pass (for non-tiled rendering or when diffusion is disabled)
                        runHalationPass(currentResult, nF, tileRect, destRect, fboSet, tileResolution);
                    }
                    currentResult = fboSet.finalTonemapped.texture;
                }
                if (textureEnabledToggle.checked) {
                    runTexturePass(currentResult, nF, tileRect, destRect, fboSet, tileResolution, globalResolution, [srcRect.x, srcRect.y, srcRect.w, srcRect.h]);
                    currentResult = fboSet.postcurve.texture;
                }
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
            const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
            let sprocketSizeScale = 1.0;
            let sprocketTranslation = 1.0;
            
            if (is16mm) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket16mmScale') && document.getElementById('sprocket16mmScale').value) || '1') + 0.23;
                sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1') + 0.02;
            } else if (is35mm178) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm178Scale') && document.getElementById('sprocket35mm178Scale').value) || '1') + sprocketScaleOffsets['35mm-178'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm178Translation') && document.getElementById('sprocket35mm178Translation').value) || '1');
            } else if (is35mm240) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm240Scale') && document.getElementById('sprocket35mm240Scale').value) || '1') + sprocketScaleOffsets['35mm-240'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm240Translation') && document.getElementById('sprocket35mm240Translation').value) || '1');
            } else if (is35mm133) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm133Scale') && document.getElementById('sprocket35mm133Scale').value) || '1') + sprocketScaleOffsets['35mm-133'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm133Translation') && document.getElementById('sprocket35mm133Translation').value) || '1');
            } else {
                sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1');
            }
            drawQuadWithRegions(progs.sprocketOverlay, { u_base: currentResult, u_overlay: sprocketTexture, u_borderScale: vals.borderScale, u_sprocketScale: sprocketTranslation, u_sprocketSizeScale: sprocketSizeScale, u_canvasResolution: globalResolution, u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160], u_sprocketContrast: vals.sprocketContrast, u_extendEdges: isSpecialEngine, u_fullUVRect: fullUVRect }, tileRect, destRect, tileResolution, tileResolution);
        }

        function runRenderPipeline(srcRect, destRect, isSimple, fboSet, viewportSize) {
            const tileRect = { x: 0, y: 0, w: destRect.w, h: destRect.h };
            const globalResolution = (globalResolutionOverride ? [globalResolutionOverride[0], globalResolutionOverride[1]] : [canvas.width, canvas.height]);
            const tileResolution = viewportSize;
            const useRaw = (chromaPreviewActive || isHolding) && rawImageTexture && rawSrgbTexture;
            const srcTex = useRaw ? rawImageTexture : imageTexture;
            const srcSrgb = useRaw ? rawSrgbTexture : originalSrgbTexture;
            
            const vals={imageScale:parseFloat(imageScaleSlider.value), blackLevelBias:parseFloat(blackLevelBiasSlider.value), borderScale:parseFloat(borderScaleSlider.value), sprocketContrast:parseFloat(sprocketContrastSlider.value), cheatAspectX:parseFloat(cheatAspectXSlider.value), cheatAspectY:parseFloat(cheatAspectYSlider.value)};
            const biasedMinPixelValue = [minPixelValue[0] * vals.blackLevelBias, minPixelValue[1] * vals.blackLevelBias, minPixelValue[2] * vals.blackLevelBias];
            const nF = Math.max(canvas.width,canvas.height)/3840.0;
            const is8mm = (window.__borderEngine === '8mm');
            const is16mm = (window.__borderEngine === '16mm');
            const is35mm178 = (window.__borderEngine === '35mm-178');
            const is35mm240 = (window.__borderEngine === '35mm-240');
            const is35mm133 = (window.__borderEngine === '35mm-133');
            const is35mmAdd = (window.__borderEngine === '35mm-add');
            const isMediumFormat = (window.__borderEngine === 'medium-format');
            const isSpecialEngine = is8mm || is16mm || is35mm178 || is35mm240 || is35mm133 || is35mmAdd || isMediumFormat;

            // <<< FIX: Calculate final image scale with blur compensation.
            let finalImageScale = vals.imageScale;
            if (isSpecialEngine && !is35mmAdd && !isMediumFormat) {
                const blurRadius = parseFloat(borderBlurSlider.value);
                const BLUR_TO_SCALE_COMPENSATION = 0.001; // This factor can be tweaked.
                finalImageScale += blurRadius * BLUR_TO_SCALE_COMPENSATION;
            }

            if (isSpecialEngine) {
                // Single-Pass Path for 8mm, 16mm, and 35mm cine using the compensated image scale
                let zoneBDims;
                // Use canonical Zone B dimensions (do NOT scale by cheat aspects here); shader applies orientation-aware scaling for spacing
                if (is8mm) {
                    zoneBDims = [3028.0, 2016.0]; // 8mm zone dimensions
                } else if (is16mm) {
                    zoneBDims = [3499.0, 2115.0]; // 16mm zone dimensions (3662-163, 2140-25)
                } else if (is35mm178) {
                    zoneBDims = [3691.0, 2084.0]; // 35mm_178: (3761-70, 2122-38)
                } else if (is35mm240) {
                    zoneBDims = [3679.0, 1550.0]; // 35mm_240: (3754-75, 1856-306)
                } else if (is35mm133) {
                    zoneBDims = [3028.0, 2016.0]; // 35mm_133: identical to 8mm (3434-406, 2087-71)
                } else if (is35mmAdd) {
                    zoneBDims = [2240.0, 1516.0]; // 35mm stills Zone B dims
                } else if (isMediumFormat) {
                    zoneBDims = [2448.0, 2000.0]; // Medium Format Zone B dims (3150-702, 2070-70)
                }
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const programToUse = (is35mmAdd || isMediumFormat) ? progs.borderComposite35add : progs.borderComposite8mm;
                drawQuadWithRegions(programToUse, {
                    u_source: srcTex,
                    u_gateTexture: borderTexture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_borderScale: vals.borderScale,
                    u_imageScale: finalImageScale, // Use the compensated value
                    // Pass raw adjacent frame distance value - shader will apply appropriate cheat aspect scaling
                    u_adjacentFrameDistance: is35mmAdd ? (1.06 + parseFloat(framePaddingSlider.value)) : isMediumFormat ? (1.10 + parseFloat(framePaddingSlider.value)) : (parseFloat(adjacentFrameDistanceSlider.value) / 100.0) + parseFloat(framePaddingSlider.value),
                    u_framing: parseFloat(framingSlider.value),
                    u_canvasResolution: globalResolution,
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h],
                    u_borderResolution: [3840, 2160],
                    u_zoneBDims: zoneBDims,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                }, srcRect, destRect, globalResolution, tileResolution);
            } else {
                // Existing 35mm Path using the old triptych compositor
                const disableAC = false;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.triptychComposite.fbo);
                const nW9 = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const nH9 = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                const nativeLongShort9 = (Math.max(nW9, nH9) / Math.max(1, Math.min(nW9, nH9)));
                drawQuadWithRegions(progs.triptychCompositor, { 
                    u_source: srcTex, 
                    u_maskA: maskATexture, 
                    u_maskB: maskBTexture, 
                    u_maskC: maskCTexture,
                    u_borderScale: vals.borderScale, 
                    u_imageScale: finalImageScale, // Use the (uncompensated) value
                    u_canvasResolution: globalResolution, 
                    u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h], 
                    u_borderResolution: [3840, 2160], 
                    u_disableAC: disableAC,
                    u_is8mmEngine: is8mm,
                    u_adjacentFrameDistance: parseFloat(adjacentFrameDistanceSlider.value) / 100.0,
                    u_framing: parseFloat(framingSlider.value),
                    u_zoneBDims: [2240.0, 1516.0], // 35mm stills Zone B dimensions (800+2240, 322+1516)
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_nativeSourceAspect: nativeLongShort9,
                    u_framingLimit: 1.0,
                    u_fullUVRect: [srcRect.x, srcRect.y, srcRect.w, srcRect.h]
                 }, srcRect, destRect, globalResolution, tileResolution);

                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.borderApplied.fbo);
                const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
                drawQuadWithRegions(progs.borderOverlay, {
                    u_base: fboSet.triptychComposite.texture,
                    u_minPixelValue: biasedMinPixelValue,
                    u_fullUVRect: fullUVRect,
                    u_border: borderTexture,
                    u_borderScale: vals.borderScale,
                    u_cheatAspectX: vals.cheatAspectX,
                    u_cheatAspectY: vals.cheatAspectY,
                    u_canvasResolution: globalResolution,
                    u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160]
                }, tileRect, destRect, tileResolution, tileResolution);
            }
            
            let currentResult = fboSet.borderApplied.texture;
            
            // Optionally suppress overlays (used during engine swaps)
            if (window.__suppressOverlays) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
                drawQuadWithRegions(progs.passthrough, { u_image: currentResult }, tileRect, destRect, tileResolution, tileResolution);
                return;
            }

            if (isPreviewingBorder) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
                const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
                let sprocketSizeScale = 1.0;
                let sprocketTranslation = 1.0;
                
                if (is16mm) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket16mmScale') && document.getElementById('sprocket16mmScale').value) || '1') + 0.23;
                    sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1') + 0.02;
                } else if (is35mm178) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm178Scale') && document.getElementById('sprocket35mm178Scale').value) || '1') + sprocketScaleOffsets['35mm-178'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm178Translation') && document.getElementById('sprocket35mm178Translation').value) || '1');
                } else if (is35mm240) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm240Scale') && document.getElementById('sprocket35mm240Scale').value) || '1') + sprocketScaleOffsets['35mm-240'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm240Translation') && document.getElementById('sprocket35mm240Translation').value) || '1');
                } else if (is35mm133) {
                    sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm133Scale') && document.getElementById('sprocket35mm133Scale').value) || '1') + sprocketScaleOffsets['35mm-133'];
                    sprocketTranslation = parseFloat((document.getElementById('sprocket35mm133Translation') && document.getElementById('sprocket35mm133Translation').value) || '1');
                } else {
                    sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1');
                }
                drawQuadWithRegions(progs.sprocketOverlay, { u_base: currentResult, u_overlay: sprocketTexture, u_borderScale: vals.borderScale, u_sprocketScale: sprocketTranslation, u_sprocketSizeScale: sprocketSizeScale, u_canvasResolution: globalResolution, u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160], u_sprocketContrast: vals.sprocketContrast, u_fullUVRect: fullUVRect }, tileRect, destRect, tileResolution, tileResolution);
                return;
            }

            if (!isSimple) {
                if (halationEnabledToggle.checked && supportsFloat) {
                    // Always use consistent 1K-based diffusion computation
                    if (needsAnyDiffusion()) {
                        runHalationPassWith1KDiffusion(currentResult, nF, tileRect, destRect, fboSet, tileResolution);
                    } else {
                        runHalationPassWithoutDiffusion(currentResult, nF, tileRect, destRect, fboSet, tileResolution);
                    }
                    currentResult = fboSet.finalTonemapped.texture;
                }
                if (textureEnabledToggle.checked) {
                    runTexturePass(currentResult, nF, tileRect, destRect, fboSet, tileResolution, globalResolution, [srcRect.x, srcRect.y, srcRect.w, srcRect.h]);
                    currentResult = fboSet.postcurve.texture;
                }
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.sprocketApplied.fbo);
            const fullUVRect = [srcRect.x, srcRect.y, srcRect.w, srcRect.h];
            let sprocketSizeScale = 1.0;
            let sprocketTranslation = 1.0;
            
            if (is16mm) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket16mmScale') && document.getElementById('sprocket16mmScale').value) || '1') + 0.23;
                sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1') + 0.02;
            } else if (is35mm178) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm178Scale') && document.getElementById('sprocket35mm178Scale').value) || '1') + sprocketScaleOffsets['35mm-178'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm178Translation') && document.getElementById('sprocket35mm178Translation').value) || '1');
            } else if (is35mm240) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm240Scale') && document.getElementById('sprocket35mm240Scale').value) || '1') + sprocketScaleOffsets['35mm-240'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm240Translation') && document.getElementById('sprocket35mm240Translation').value) || '1');
            } else if (is35mm133) {
                sprocketSizeScale = parseFloat((document.getElementById('sprocket35mm133Scale') && document.getElementById('sprocket35mm133Scale').value) || '1') + sprocketScaleOffsets['35mm-133'];
                sprocketTranslation = parseFloat((document.getElementById('sprocket35mm133Translation') && document.getElementById('sprocket35mm133Translation').value) || '1');
            } else {
                sprocketTranslation = parseFloat((sprocketScaleSlider && sprocketScaleSlider.value) || '1');
            }
            drawQuadWithRegions(progs.sprocketOverlay, { u_base: currentResult, u_overlay: sprocketTexture, u_borderScale: vals.borderScale, u_sprocketScale: sprocketTranslation, u_sprocketSizeScale: sprocketSizeScale, u_canvasResolution: globalResolution, u_borderResolution: is35mm133 ? [3840, 2160] : [3840, 2160], u_sprocketContrast: vals.sprocketContrast, u_extendEdges: isSpecialEngine, u_fullUVRect: fullUVRect }, tileRect, destRect, tileResolution, tileResolution);
        }
        function runHalationPass(inputTexture, nF, tileRect, destRect, fboSet, tileResolution) {
            const vals2 = { halationIntensity:parseFloat(halationIntensitySlider.value), mtfMask:parseFloat(mtfMaskSlider.value), mtfSoftness:parseFloat(mtfSoftnessSlider.value), blackpoint:parseFloat(blackpointSlider.value), whitepoint:parseFloat(whitepointSlider.value), thresholdGamma:parseFloat(thresholdGammaSlider.value), coreBlur:parseFloat(coreBlurSlider.value), midBlur:parseFloat(midBlurSlider.value), outerBlur:parseFloat(outerBlurSlider.value), midBlurGain:parseFloat(midBlurGainSlider.value), outerBlurGain:parseFloat(outerBlurGainSlider.value), tintR2:parseFloat(tintR2Slider.value), tintG2:parseFloat(tintG2Slider.value), tintB2:parseFloat(tintB2Slider.value), diffusionRadius:parseFloat(diffusionRadiusSlider.value), diffusionStrength:parseFloat(diffusionStrengthSlider.value), diffusionRadiusB:parseFloat(diffusionRadiusBSlider.value), diffusionStrengthB:parseFloat(diffusionStrengthBSlider.value), diffusionRadiusC:parseFloat(diffusionRadiusCSlider.value), diffusionStrengthC:parseFloat(diffusionStrengthCSlider.value), diffusionIntensity:parseFloat(diffusionIntensitySlider.value), diffusionTintR:parseFloat(diffusionTintRSlider.value), diffusionTintG:parseFloat(diffusionTintGSlider.value), diffusionTintB:parseFloat(diffusionTintBSlider.value), diffusionSubtract:diffusionSubtractToggle.checked };
            const useRaw = (chromaPreviewActive || isHolding) && rawSrgbTexture;
            const srcSrgb = useRaw ? rawSrgbTexture : originalSrgbTexture;
            
            // Formula to calculate automatic additional blur based on diffusion radius
            const calculateAdditionalBlur = (diffusionRadius) => {
                if (diffusionRadius < 35) return 0;
                if (diffusionRadius < 80) return 1;
                if (diffusionRadius < 149) return Math.max(1, Math.min(6, (diffusionRadius - 80) * 5 / 69 + 1));
                if (diffusionRadius < 170) return Math.max(6, Math.min(7, (diffusionRadius - 149) * 1 / 21 + 6));
                if (diffusionRadius < 200) return Math.max(7, Math.min(12, (diffusionRadius - 170) * 5 / 30 + 7));
                if (diffusionRadius < 250) return Math.max(12, Math.min(18, (diffusionRadius - 200) * 6 / 50 + 12));
                if (diffusionRadius < 300) return Math.max(18, Math.min(22, (diffusionRadius - 250) * 4 / 50 + 18));
                if (diffusionRadius < 350) return Math.max(22, Math.min(25, (diffusionRadius - 300) * 3 / 50 + 22));
                if (diffusionRadius < 400) return Math.max(25, Math.min(20, (diffusionRadius - 350) * -5 / 50 + 25));
                if (diffusionRadius < 600) return 20;
                if (diffusionRadius < 800) return Math.max(20, Math.min(40, (diffusionRadius - 600) * 20 / 200 + 20));
                if (diffusionRadius < 1000) return Math.max(40, Math.min(50, (diffusionRadius - 800) * 10 / 200 + 40));
                return 50;
            };
            
            let mtfInput = inputTexture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfLinearInput.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: inputTexture, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfInput = fboSet.mtfLinearInput.texture; }
            applySeparableBlur(mtfInput, fboSet.mtfMaskBlur, vals2.mtfMask * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: mtfInput, u_imageB: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            applySeparableBlur(fboSet.mtfSubtract.texture, fboSet.mtfSoftnessBlur, vals2.mtfSoftness * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfOutput.fbo); drawQuadWithRegions(progs.add, { u_base: fboSet.mtfSoftnessBlur.texture, u_overlay: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Create post-MTF sRGB texture for white point processing
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.postMtfSrgb.fbo);
            if (mtfLinearToggle.checked) {
                // MTF was in linear space, convert to sRGB
                drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution);
            } else {
                // MTF was in sRGB space, just pass through
                drawQuadWithRegions(progs.passthrough, { u_image: fboSet.mtfOutput.texture }, tileRect, destRect, tileResolution, tileResolution);
            }
            let mtfResultForNextStep = fboSet.mtfOutput.texture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSrgbOutput.fbo); drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfResultForNextStep = fboSet.mtfSrgbOutput.texture; }
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.linearBase.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.minDesaturate.fbo); drawQuadWithRegions(progs.minDesaturate, { u_image: fboSet.linearBase.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.keyAdjust.fbo); drawQuadWithRegions(progs.keyAdjust, { u_image: fboSet.minDesaturate.texture, u_blackpoint: vals2.blackpoint, u_whitepoint: vals2.whitepoint }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.gamma.fbo); drawQuadWithRegions(progs.gamma, { u_image: fboSet.keyAdjust.texture, u_gamma: vals2.thresholdGamma }, tileRect, destRect, tileResolution, tileResolution);
            const glowSubtractor = fboSet.gamma.texture;
            applySeparableBlur(glowSubtractor, fboSet.coreBlur, vals2.coreBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.midBlur, vals2.midBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.outerBlur, vals2.outerBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.coreSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.coreBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.midBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.outerBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.midSubtract.texture, u_gain: vals2.midBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.outerSubtract.texture, u_gain: vals2.outerBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.glowAccumulator.fbo); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.coreSubtract.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.midSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.outerSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.disable(gl.BLEND);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.blurPingPong.fbo); drawQuadWithRegions(progs.shuffleRtoRGB, { u_image: fboSet.glowAccumulator.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.tintedGlow.fbo); drawQuadWithRegions(progs.tint, { u_image: fboSet.blurPingPong.texture, u_tint: [vals2.tintR2, vals2.tintG2, vals2.tintB2] }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.intensityGlow.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.tintedGlow.texture, u_gain: vals2.halationIntensity }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.addGlowToBase.fbo); drawQuadWithRegions(progs.add, { u_base: fboSet.linearBase.texture, u_overlay: fboSet.intensityGlow.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Apply diffusion effect if enabled
            let diffusionResult = fboSet.addGlowToBase.texture;
            if ((vals2.diffusionStrength > 0 && vals2.diffusionRadius > 0) || (vals2.diffusionStrengthB > 0 && vals2.diffusionRadiusB > 0) || (vals2.diffusionStrengthC > 0 && vals2.diffusionRadiusC > 0)) {
                // Calculate 1K resolution for downscaling
                const maxDim = Math.max(tileResolution[0], tileResolution[1]);
                const scale = Math.min(1.0, 1024 / maxDim);
                const diffusionW = Math.max(1, Math.floor(tileResolution[0] * scale));
                const diffusionH = Math.max(1, Math.floor(tileResolution[1] * scale));

                // Create temporary FBOs with exact downscaled dimensions
                const tempDownscaleFBO = createFBO(diffusionW, diffusionH, true);
                const tempBlurredFBO = createFBO(diffusionW, diffusionH, true);

                // Downscale to 1K
                const downscaleRect = { x: 0, y: 0, w: diffusionW, h: diffusionH };
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempDownscaleFBO.fbo);
                gl.viewport(0, 0, diffusionW, diffusionH);
                drawQuadWithRegions(
                    progs.downsample,
                    { u_image: fboSet.addGlowToBase.texture, u_fullUVRect: [tileRect.x, tileRect.y, tileRect.w, tileRect.h] },
                    tileRect, // source: full tile
                    downscaleRect, // dest: full downscaled target
                    tileResolution, // source resolution: tile size
                    [diffusionW, diffusionH] // viewport: downscaled size
                );

                // Apply threshold gain first, then luma key and premultiply
                const thresholdGain = parseFloat((document.getElementById('diffusionThreshold')||{value:'1'}).value)||1;
                const thresholdAdjustedFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, thresholdAdjustedFBO.fbo);
                drawQuadWithRegions(
                    progs.applyThresholdGain,
                    { u_image: tempDownscaleFBO.texture, u_gain: thresholdGain, u_fullUVRect: [0,0,1,1] },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Luma key and premultiply (no gain applied here since it was applied above)
                const lumaPremulFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, lumaPremulFBO.fbo);
                drawQuadWithRegions(
                    progs.lumaPremultiplyNoGain,
                    { u_image: thresholdAdjustedFBO.texture, u_fullUVRect: [0,0,1,1] },
                    downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                );

                // Build diffusion A and B at downscaled resolution, then combine and upscale once
                const texelSize = [1 / diffusionW, 1 / diffusionH];
                // Build a Gaussian kernel on CPU to send to shader
                function buildGaussianKernel(radius){
                    const sigma = Math.max(0.0001, radius * 0.5);
                    const kernelSize = 15; // must match KERNEL_SIZE
                    const half = Math.floor(kernelSize/2);
                    const k = new Float32Array(kernelSize);
                    let sum = 0;
                    for(let i=0;i<kernelSize;i++){
                        const x = i - half;
                        const w = Math.exp(-(x*x)/(2.0*sigma*sigma));
                        k[i] = w; sum += w;
                    }
                    for(let i=0;i<kernelSize;i++){ k[i] /= sum; }
                    return k;
                }
                const hasA = (vals2.diffusionStrength > 0.0 && vals2.diffusionRadius > 0.0);
                const hasB = (vals2.diffusionStrengthB > 0.0 && vals2.diffusionRadiusB > 0.0);

                // Diffusion A blur (downscaled)
                let tempPingFBO = null;
                if (hasA) {
                    // Map radius to sigma and radius steps like ShaderToy example
                    const sigmaA = Math.max(0.5, vals2.diffusionRadius * nF * scale * 0.2);
                    const radiusA = Math.min(96.0, sigmaA * 6.0); // larger support for very large radii
                    // Use smooth LOD interpolation instead of discrete steps to avoid hard stops
                    const lodAFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaA) - 1));
                    const lodA = Math.floor(lodAFloat);
                    const lodAFrac = lodAFloat - lodA;
                    // Smooth step size interpolation between LOD levels
                    const stepSizeBase = Math.pow(2, lodA);
                    const stepSizeNext = Math.pow(2, Math.min(4, lodA + 1));
                    let smoothStepSize = stepSizeBase + (stepSizeNext - stepSizeBase) * lodAFrac;
                    // Cap step size to prevent grid artifacts at very large radii
                    smoothStepSize = Math.min(smoothStepSize, 8.0);
                    tempPingFBO = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBO.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: lumaPremulFBO.texture, u_step: [smoothStepSize * 0.5/diffusionW, 0.0], u_sigma: sigmaA, u_radius: radiusA, u_lod: lodAFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBO.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBO.texture, u_step: [0.0, smoothStepSize * 0.5/diffusionH], u_sigma: sigmaA, u_radius: radiusA, u_lod: lodAFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                }

                // Diffusion B blur (downscaled)
                let tempPingFBOB = null;
                let tempBlurredFBOB = null;
                if (hasB) {
                    const sigmaB = Math.max(0.5, vals2.diffusionRadiusB * vals2.diffusionSpread * nF * scale * 0.2);
                    const radiusB = Math.min(96.0, sigmaB * 6.0);
                    // Use smooth LOD interpolation instead of discrete steps to avoid hard stops
                    const lodBFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaB) - 1));
                    const lodB = Math.floor(lodBFloat);
                    const lodBFrac = lodBFloat - lodB;
                    // Smooth step size interpolation between LOD levels
                    const stepSizeBase = Math.pow(2, lodB);
                    const stepSizeNext = Math.pow(2, Math.min(4, lodB + 1));
                    let smoothStepSize = stepSizeBase + (stepSizeNext - stepSizeBase) * lodBFrac;
                    // Cap step size to prevent grid artifacts at very large radii
                    smoothStepSize = Math.min(smoothStepSize, 8.0);
                    tempPingFBOB = createFBO(diffusionW, diffusionH, true);
                    tempBlurredFBOB = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBOB.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: lumaPremulFBO.texture, u_step: [smoothStepSize * 0.5/diffusionW, 0.0], u_sigma: sigmaB, u_radius: radiusB, u_lod: lodBFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOB.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBOB.texture, u_step: [0.0, smoothStepSize * 0.5/diffusionH], u_sigma: sigmaB, u_radius: radiusB, u_lod: lodBFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    
                    // Apply automatic additional blur B to smooth grid artifacts at high radii
                    const autoAdditionalBlurB = calculateAdditionalBlur(vals2.diffusionRadiusB * vals2.diffusionSpread);
                    if (autoAdditionalBlurB > 0) {
                        const additionalBlurRadius = autoAdditionalBlurB * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        
                        // Create temporary FBO for additional blur ping-pong
                        const tempAdditionalBlurFBOB = createFBO(diffusionW, diffusionH, true);
                        
                        // Horizontal pass
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBOB.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempBlurredFBOB.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [1, 0] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Vertical pass - write back to tempBlurredFBOB
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOB.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempAdditionalBlurFBOB.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [0, 1] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Clean up temporary FBO
                        gl.deleteFramebuffer(tempAdditionalBlurFBOB.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBOB.texture);
                    }
                }

                // Combine A, B and C with gains at downscaled resolution
                const tempCombinedFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempCombinedFBO.fbo);
                gl.viewport(0, 0, diffusionW, diffusionH);
                gl.clearColor(0,0,0,0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                if (hasA) {
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBO.texture, u_gain: vals2.diffusionStrength * vals2.diffusionIntensity },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                }
                if (hasB) {
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBOB.texture, u_gain: vals2.diffusionStrengthB * vals2.diffusionIntensity },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                }
                
                // Diffusion C branch (optional) - process BEFORE disabling blend
                let tempPingFBOC = null; let tempBlurredFBOC = null; const hasC = (vals2.diffusionStrengthC > 0.0 && vals2.diffusionRadiusC > 0.0);
                if (hasC) {
                    const sigmaC = Math.max(0.5, vals2.diffusionRadiusC * vals2.diffusionSpread * nF * scale * 0.2);
                    const radiusC = Math.min(96.0, sigmaC * 6.0);
                    // Use smooth LOD interpolation instead of discrete steps to avoid hard stops
                    const lodCFloat = Math.max(0.0, Math.min(4.0, Math.log2(sigmaC) - 1));
                    const lodC = Math.floor(lodCFloat);
                    const lodCFrac = lodCFloat - lodC;
                    // Smooth step size interpolation between LOD levels
                    const stepSizeBase = Math.pow(2, lodC);
                    const stepSizeNext = Math.pow(2, Math.min(4, lodC + 1));
                    let smoothStepSize = stepSizeBase + (stepSizeNext - stepSizeBase) * lodCFrac;
                    // Cap step size to prevent grid artifacts at very large radii
                    smoothStepSize = Math.min(smoothStepSize, 8.0);
                    tempPingFBOC = createFBO(diffusionW, diffusionH, true);
                    tempBlurredFBOC = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempPingFBOC.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: lumaPremulFBO.texture, u_step: [smoothStepSize * 0.5/diffusionW, 0.0], u_sigma: sigmaC, u_radius: radiusC, u_lod: lodCFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOC.fbo);
                    drawQuadWithRegions(
                        progs.gaussianST,
                        { u_image: tempPingFBOC.texture, u_step: [0.0, smoothStepSize * 0.5/diffusionH], u_sigma: sigmaC, u_radius: radiusC, u_lod: lodCFloat, u_fullUVRect: [0,0,1,1] },
                        downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]
                    );
                    
                    // Apply automatic additional blur C to smooth grid artifacts at high radii
                    const autoAdditionalBlurC = calculateAdditionalBlur(vals2.diffusionRadiusC * vals2.diffusionSpread);
                    if (autoAdditionalBlurC > 0) {
                        console.log(`Applying additional blur C: radius=${vals2.diffusionRadiusC}, blur=${autoAdditionalBlurC}`);
                        const additionalBlurRadius = autoAdditionalBlurC * nF * scale;
                        const texelSize = [1 / diffusionW, 1 / diffusionH];
                        
                        // Ensure correct GL state for blur operations
                        gl.viewport(0, 0, diffusionW, diffusionH);
                        gl.disable(gl.BLEND);
                        
                        // Create temporary FBO for additional blur ping-pong
                        const tempAdditionalBlurFBOC = createFBO(diffusionW, diffusionH, true);
                        
                        // Horizontal pass
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempAdditionalBlurFBOC.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempBlurredFBOC.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [1, 0] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Vertical pass - write back to tempBlurredFBOC
                        gl.bindFramebuffer(gl.FRAMEBUFFER, tempBlurredFBOC.fbo);
                        drawQuadWithRegions(progs.separableBlur, { 
                            u_image: tempAdditionalBlurFBOC.texture, 
                            u_texelSize: texelSize, 
                            u_blurRadius: additionalBlurRadius, 
                            u_direction: [0, 1] 
                        }, downscaleRect, downscaleRect, [diffusionW, diffusionH], [diffusionW, diffusionH]);
                        
                        // Clean up temporary FBO
                        gl.deleteFramebuffer(tempAdditionalBlurFBOC.fbo);
                        gl.deleteTexture(tempAdditionalBlurFBOC.texture);
                        
                        // Restore blend state for diffusion C addition
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.ONE, gl.ONE);
                    }
                    
                    // Add Diffusion C to the combined buffer while blend is still enabled
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempCombinedFBO.fbo);
                    drawQuadWithRegions(
                        progs.grade,
                        { u_image: tempBlurredFBOC.texture, u_gain: vals2.diffusionStrengthC * vals2.diffusionIntensity },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                }
                gl.disable(gl.BLEND);

                // Optional subtract source (luma premultiplied) from combined diffusion at downscaled resolution
                let sourceForTinting = tempCombinedFBO.texture;
                let tempSubtractedFBO = null;
                if (vals2.diffusionSubtract) {
                    // Create temporary FBO for subtracted diffusion at downscaled resolution
                    tempSubtractedFBO = createFBO(diffusionW, diffusionH, true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, tempSubtractedFBO.fbo);
                    drawQuadWithRegions(
                        progs.subtract,
                        { u_imageA: tempCombinedFBO.texture, u_imageB: lumaPremulFBO.texture },
                        downscaleRect,
                        downscaleRect,
                        [diffusionW, diffusionH],
                        [diffusionW, diffusionH]
                    );
                    sourceForTinting = tempSubtractedFBO.texture;
                }

                // Apply RGB tint to combined diffusion before upscaling
                const tempTintedFBO = createFBO(diffusionW, diffusionH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempTintedFBO.fbo);
                const diffusionTintRGB = [vals2.diffusionTintR, vals2.diffusionTintG, vals2.diffusionTintB];
                drawQuadWithRegions(
                    progs.tint,
                    { u_image: sourceForTinting, u_tint: diffusionTintRGB },
                    downscaleRect,
                    downscaleRect,
                    [diffusionW, diffusionH],
                    [diffusionW, diffusionH]
                );

                // Upscale the tinted diffusion
                gl.viewport(0, 0, tileResolution[0], tileResolution[1]);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.diffusionUpscale.fbo);
                drawQuadWithRegions(
                    progs.upsample,
                    { u_image: tempTintedFBO.texture, u_fullUVRect: [0, 0, 1, 1] },
                    downscaleRect, // source: full downscaled
                    tileRect, // dest: full tile
                    [diffusionW, diffusionH], // source resolution: downscaled size
                    tileResolution // viewport: tile size
                );

                // Add to original with plus
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.diffusionGained.fbo);
                drawQuadWithRegions(
                    progs.add,
                    { u_base: fboSet.addGlowToBase.texture, u_overlay: fboSet.diffusionUpscale.texture },
                    tileRect,
                    tileRect,
                    tileResolution,
                    tileResolution
                );

                diffusionResult = fboSet.diffusionGained.texture;

                // Cleanup temporary FBOs
                gl.deleteFramebuffer(tempDownscaleFBO.fbo);
                gl.deleteTexture(tempDownscaleFBO.texture);
                if (tempPingFBO) { gl.deleteFramebuffer(tempPingFBO.fbo); gl.deleteTexture(tempPingFBO.texture); }
                gl.deleteFramebuffer(tempBlurredFBO.fbo);
                gl.deleteTexture(tempBlurredFBO.texture);
                if (tempPingFBOB) { gl.deleteFramebuffer(tempPingFBOB.fbo); gl.deleteTexture(tempPingFBOB.texture); }
                if (tempBlurredFBOB) { gl.deleteFramebuffer(tempBlurredFBOB.fbo); gl.deleteTexture(tempBlurredFBOB.texture); }
                if (tempPingFBOC) { gl.deleteFramebuffer(tempPingFBOC.fbo); gl.deleteTexture(tempPingFBOC.texture); }
                if (tempBlurredFBOC) { gl.deleteFramebuffer(tempBlurredFBOC.fbo); gl.deleteTexture(tempBlurredFBOC.texture); }
                gl.deleteFramebuffer(tempCombinedFBO.fbo);
                gl.deleteTexture(tempCombinedFBO.texture);
                gl.deleteFramebuffer(tempTintedFBO.fbo);
                gl.deleteTexture(tempTintedFBO.texture);
                if (tempSubtractedFBO) { gl.deleteFramebuffer(tempSubtractedFBO.fbo); gl.deleteTexture(tempSubtractedFBO.texture); }
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.finalTonemapped.fbo); drawQuadWithRegions(progs.linearToSrgb, { u_image: diffusionResult, u_originalSrgb: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
        }

        function runHalationPassWithoutDiffusion(inputTexture, nF, tileRect, destRect, fboSet, tileResolution) {
            const vals2 = { halationIntensity:parseFloat(halationIntensitySlider.value), mtfMask:parseFloat(mtfMaskSlider.value), mtfSoftness:parseFloat(mtfSoftnessSlider.value), blackpoint:parseFloat(blackpointSlider.value), whitepoint:parseFloat(whitepointSlider.value), thresholdGamma:parseFloat(thresholdGammaSlider.value), coreBlur:parseFloat(coreBlurSlider.value), midBlur:parseFloat(midBlurSlider.value), outerBlur:parseFloat(outerBlurSlider.value), midBlurGain:parseFloat(midBlurGainSlider.value), outerBlurGain:parseFloat(outerBlurGainSlider.value), tintR2:parseFloat(tintR2Slider.value), tintG2:parseFloat(tintG2Slider.value), tintB2:parseFloat(tintB2Slider.value) };
            
            // Run the standard halation pass without diffusion
            let mtfInput = inputTexture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfLinearInput.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: inputTexture, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfInput = fboSet.mtfLinearInput.texture; }
            applySeparableBlur(mtfInput, fboSet.mtfMaskBlur, vals2.mtfMask * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: mtfInput, u_imageB: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            applySeparableBlur(fboSet.mtfSubtract.texture, fboSet.mtfSoftnessBlur, vals2.mtfSoftness * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfOutput.fbo); drawQuadWithRegions(progs.add, { u_base: fboSet.mtfSoftnessBlur.texture, u_overlay: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Create post-MTF sRGB texture for white point processing
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.postMtfSrgb.fbo);
            if (mtfLinearToggle.checked) {
                // MTF was in linear space, convert to sRGB
                drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution);
            } else {
                // MTF was in sRGB space, just pass through
                drawQuadWithRegions(progs.passthrough, { u_image: fboSet.mtfOutput.texture }, tileRect, destRect, tileResolution, tileResolution);
            }
            let mtfResultForNextStep = fboSet.mtfOutput.texture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSrgbOutput.fbo); drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfResultForNextStep = fboSet.mtfSrgbOutput.texture; }
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.linearBase.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.minDesaturate.fbo); drawQuadWithRegions(progs.minDesaturate, { u_image: fboSet.linearBase.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.keyAdjust.fbo); drawQuadWithRegions(progs.keyAdjust, { u_image: fboSet.minDesaturate.texture, u_blackpoint: vals2.blackpoint, u_whitepoint: vals2.whitepoint }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.gamma.fbo); drawQuadWithRegions(progs.gamma, { u_image: fboSet.keyAdjust.texture, u_gamma: vals2.thresholdGamma }, tileRect, destRect, tileResolution, tileResolution);
            const glowSubtractor = fboSet.gamma.texture;
            applySeparableBlur(glowSubtractor, fboSet.coreBlur, vals2.coreBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.midBlur, vals2.midBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.outerBlur, vals2.outerBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.coreSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.coreBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.midBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.outerBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.midSubtract.texture, u_gain: vals2.midBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.outerSubtract.texture, u_gain: vals2.outerBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.glowAccumulator.fbo); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.coreSubtract.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.midSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.outerSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.disable(gl.BLEND);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.blurPingPong.fbo); drawQuadWithRegions(progs.shuffleRtoRGB, { u_image: fboSet.glowAccumulator.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.tintedGlow.fbo); drawQuadWithRegions(progs.tint, { u_image: fboSet.blurPingPong.texture, u_tint: [vals2.tintR2, vals2.tintG2, vals2.tintB2] }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.intensityGlow.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.tintedGlow.texture, u_gain: vals2.halationIntensity }, tileRect, destRect, tileResolution, tileResolution);
            const useScreenBlend = halationScreenToggle.checked;
            console.log('Screen blend mode:', useScreenBlend ? 'SCREEN' : 'ADD'); // Debug log
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.addGlowToBase.fbo); 
            drawQuadWithRegions(useScreenBlend ? progs.screen : progs.add, { u_base: fboSet.linearBase.texture, u_overlay: fboSet.intensityGlow.texture }, tileRect, destRect, tileResolution, tileResolution);

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.finalTonemapped.fbo); 
            drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.addGlowToBase.texture, u_originalSrgb: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
        }

        function runHalationPassWithGlobalDiffusion(inputTexture, nF, tileRect, destRect, fboSet, tileResolution, globalDiffusionBuffer, srcRect) {
            const vals2 = { halationIntensity:parseFloat(halationIntensitySlider.value), mtfMask:parseFloat(mtfMaskSlider.value), mtfSoftness:parseFloat(mtfSoftnessSlider.value), blackpoint:parseFloat(blackpointSlider.value), whitepoint:parseFloat(whitepointSlider.value), thresholdGamma:parseFloat(thresholdGammaSlider.value), coreBlur:parseFloat(coreBlurSlider.value), midBlur:parseFloat(midBlurSlider.value), outerBlur:parseFloat(outerBlurSlider.value), midBlurGain:parseFloat(midBlurGainSlider.value), outerBlurGain:parseFloat(outerBlurGainSlider.value), tintR2:parseFloat(tintR2Slider.value), tintG2:parseFloat(tintG2Slider.value), tintB2:parseFloat(tintB2Slider.value) };
            
            // Run the standard halation pass up to addGlowToBase (without diffusion)
            let mtfInput = inputTexture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfLinearInput.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: inputTexture, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfInput = fboSet.mtfLinearInput.texture; }
            applySeparableBlur(mtfInput, fboSet.mtfMaskBlur, vals2.mtfMask * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: mtfInput, u_imageB: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            applySeparableBlur(fboSet.mtfSubtract.texture, fboSet.mtfSoftnessBlur, vals2.mtfSoftness * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfOutput.fbo); drawQuadWithRegions(progs.add, { u_base: fboSet.mtfSoftnessBlur.texture, u_overlay: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Create post-MTF sRGB texture for white point processing
            const useRawSrgb2 = (chromaPreviewActive || isHolding) && rawSrgbTexture;
            const srcSrgb2 = useRawSrgb2 ? rawSrgbTexture : originalSrgbTexture;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.postMtfSrgb.fbo);
            if (mtfLinearToggle.checked) {
                // MTF was in linear space, convert to sRGB
                drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb2, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution);
            } else {
                // MTF was in sRGB space, just pass through
                drawQuadWithRegions(progs.passthrough, { u_image: fboSet.mtfOutput.texture }, tileRect, destRect, tileResolution, tileResolution);
            }
            let mtfResultForNextStep = fboSet.mtfOutput.texture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSrgbOutput.fbo); drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: srcSrgb2, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfResultForNextStep = fboSet.mtfSrgbOutput.texture; }
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.linearBase.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.minDesaturate.fbo); drawQuadWithRegions(progs.minDesaturate, { u_image: fboSet.linearBase.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.keyAdjust.fbo); drawQuadWithRegions(progs.keyAdjust, { u_image: fboSet.minDesaturate.texture, u_blackpoint: vals2.blackpoint, u_whitepoint: vals2.whitepoint }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.gamma.fbo); drawQuadWithRegions(progs.gamma, { u_image: fboSet.keyAdjust.texture, u_gamma: vals2.thresholdGamma }, tileRect, destRect, tileResolution, tileResolution);
            const glowSubtractor = fboSet.gamma.texture;
            applySeparableBlur(glowSubtractor, fboSet.coreBlur, vals2.coreBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.midBlur, vals2.midBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.outerBlur, vals2.outerBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.coreSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.coreBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.midBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.outerBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.midSubtract.texture, u_gain: vals2.midBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.outerSubtract.texture, u_gain: vals2.outerBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.glowAccumulator.fbo); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.coreSubtract.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.midSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.outerSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.disable(gl.BLEND);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.blurPingPong.fbo); drawQuadWithRegions(progs.shuffleRtoRGB, { u_image: fboSet.glowAccumulator.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.tintedGlow.fbo); drawQuadWithRegions(progs.tint, { u_image: fboSet.blurPingPong.texture, u_tint: [vals2.tintR2, vals2.tintG2, vals2.tintB2] }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.intensityGlow.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.tintedGlow.texture, u_gain: vals2.halationIntensity }, tileRect, destRect, tileResolution, tileResolution);
            const useScreenBlend2 = halationScreenToggle.checked;
            console.log('Screen blend mode (global diffusion):', useScreenBlend2 ? 'SCREEN' : 'ADD'); // Debug log
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.addGlowToBase.fbo); 
            drawQuadWithRegions(useScreenBlend2 ? progs.screen : progs.add, { u_base: fboSet.linearBase.texture, u_overlay: fboSet.intensityGlow.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Sample the corresponding region from the pre-baked 1K global diffusion buffer
            const diffusionUVX = srcRect.x / canvas.width;
            const diffusionUVY = srcRect.y / canvas.height;
            const diffusionUVW = srcRect.w / canvas.width;
            const diffusionUVH = srcRect.h / canvas.height;
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.diffusionUpscale.fbo);
            drawQuadWithRegions(progs.sampleRegion, { 
                u_image: globalDiffusionBuffer.texture,
                u_sourceRegion: [diffusionUVX, diffusionUVY, diffusionUVW, diffusionUVH]
            }, tileRect, destRect, tileResolution, tileResolution);
            
            // Add the sampled diffusion to the base
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.diffusionGained.fbo);
            drawQuadWithRegions(progs.add, { 
                u_base: fboSet.addGlowToBase.texture, 
                u_overlay: fboSet.diffusionUpscale.texture
            }, tileRect, destRect, tileResolution, tileResolution);

            const diffusionResult = fboSet.diffusionGained.texture;

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.finalTonemapped.fbo); 
            drawQuadWithRegions(progs.linearToSrgb, { u_image: diffusionResult, u_originalSrgb: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
        }

        function runHalationPassWith1KDiffusion(inputTexture, nF, tileRect, destRect, fboSet, tileResolution) {
            const vals2 = { halationIntensity:parseFloat(halationIntensitySlider.value), mtfMask:parseFloat(mtfMaskSlider.value), mtfSoftness:parseFloat(mtfSoftnessSlider.value), blackpoint:parseFloat(blackpointSlider.value), whitepoint:parseFloat(whitepointSlider.value), thresholdGamma:parseFloat(thresholdGammaSlider.value), coreBlur:parseFloat(coreBlurSlider.value), midBlur:parseFloat(midBlurSlider.value), outerBlur:parseFloat(outerBlurSlider.value), midBlurGain:parseFloat(midBlurGainSlider.value), outerBlurGain:parseFloat(outerBlurGainSlider.value), tintR2:parseFloat(tintR2Slider.value), tintG2:parseFloat(tintG2Slider.value), tintB2:parseFloat(tintB2Slider.value) };
            
            // Run the standard halation pass up to addGlowToBase (without diffusion)
            let mtfInput = inputTexture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfLinearInput.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: inputTexture, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfInput = fboSet.mtfLinearInput.texture; }
            applySeparableBlur(mtfInput, fboSet.mtfMaskBlur, vals2.mtfMask * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: mtfInput, u_imageB: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            applySeparableBlur(fboSet.mtfSubtract.texture, fboSet.mtfSoftnessBlur, vals2.mtfSoftness * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfOutput.fbo); drawQuadWithRegions(progs.add, { u_base: fboSet.mtfSoftnessBlur.texture, u_overlay: fboSet.mtfMaskBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Create post-MTF sRGB texture for white point processing
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.postMtfSrgb.fbo);
            if (mtfLinearToggle.checked) {
                // MTF was in linear space, convert to sRGB
                drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: originalSrgbTexture, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution);
            } else {
                // MTF was in sRGB space, just pass through
                drawQuadWithRegions(progs.passthrough, { u_image: fboSet.mtfOutput.texture }, tileRect, destRect, tileResolution, tileResolution);
            }
            let mtfResultForNextStep = fboSet.mtfOutput.texture;
            if (mtfLinearToggle.checked) { gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.mtfSrgbOutput.fbo); drawQuadWithRegions(progs.linearToSrgb, { u_image: fboSet.mtfOutput.texture, u_originalSrgb: originalSrgbTexture, u_enableWhiteComp: false, u_whitePointSrgb: [1.0, 1.0, 1.0] }, tileRect, destRect, tileResolution, tileResolution); mtfResultForNextStep = fboSet.mtfSrgbOutput.texture; }
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.linearBase.fbo); drawQuadWithRegions(progs.srgbToLinear, { u_image: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.minDesaturate.fbo); drawQuadWithRegions(progs.minDesaturate, { u_image: fboSet.linearBase.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.keyAdjust.fbo); drawQuadWithRegions(progs.keyAdjust, { u_image: fboSet.minDesaturate.texture, u_blackpoint: vals2.blackpoint, u_whitepoint: vals2.whitepoint }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.gamma.fbo); drawQuadWithRegions(progs.gamma, { u_image: fboSet.keyAdjust.texture, u_gamma: vals2.thresholdGamma }, tileRect, destRect, tileResolution, tileResolution);
            const glowSubtractor = fboSet.gamma.texture;
            applySeparableBlur(glowSubtractor, fboSet.coreBlur, vals2.coreBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.midBlur, vals2.midBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            applySeparableBlur(glowSubtractor, fboSet.outerBlur, vals2.outerBlur * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.coreSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.coreBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.midBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtract.fbo); drawQuadWithRegions(progs.subtract, { u_imageA: fboSet.outerBlur.texture, u_imageB: glowSubtractor }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.midSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.midSubtract.texture, u_gain: vals2.midBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.outerSubtractGraded.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.outerSubtract.texture, u_gain: vals2.outerBlurGain }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.glowAccumulator.fbo); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.coreSubtract.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.midSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            drawQuadWithRegions(progs.passthrough, { u_image: fboSet.outerSubtractGraded.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.disable(gl.BLEND);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.blurPingPong.fbo); drawQuadWithRegions(progs.shuffleRtoRGB, { u_image: fboSet.glowAccumulator.texture }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.tintedGlow.fbo); drawQuadWithRegions(progs.tint, { u_image: fboSet.blurPingPong.texture, u_tint: [vals2.tintR2, vals2.tintG2, vals2.tintB2] }, tileRect, destRect, tileResolution, tileResolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.intensityGlow.fbo); drawQuadWithRegions(progs.grade, { u_image: fboSet.tintedGlow.texture, u_gain: vals2.halationIntensity }, tileRect, destRect, tileResolution, tileResolution);
            const useScreenBlend3 = halationScreenToggle.checked;
            console.log('Screen blend mode (1K diffusion):', useScreenBlend3 ? 'SCREEN' : 'ADD'); // Debug log
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.addGlowToBase.fbo); 
            drawQuadWithRegions(useScreenBlend3 ? progs.screen : progs.add, { u_base: fboSet.linearBase.texture, u_overlay: fboSet.intensityGlow.texture }, tileRect, destRect, tileResolution, tileResolution);
            
            // Apply 1K-based diffusion computation directly
            const diffusionContribution = runDiffusionOnlyPass(fboSet.addGlowToBase.texture, tileRect, fboSet, tileResolution);
            
            let diffusionResult = fboSet.addGlowToBase.texture;
            if (diffusionContribution) {
                // Add the diffusion contribution to the base
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.diffusionGained.fbo);
                drawQuadWithRegions(progs.add, { 
                    u_base: fboSet.addGlowToBase.texture, 
                    u_overlay: diffusionContribution
                }, tileRect, destRect, tileResolution, tileResolution);
                diffusionResult = fboSet.diffusionGained.texture;
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.finalTonemapped.fbo); 
            drawQuadWithRegions(progs.linearToSrgb, { u_image: diffusionResult, u_originalSrgb: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
        }

        function runTexturePass(inputTexture, nF, tileRect, destRect, fboSet, tileResolution, globalResolution, fullUVRect) {
            const vals = { highPassRadius: parseFloat(highPassRadiusSlider.value), highPassOpacity: parseFloat(highPassOpacitySlider.value), grainIntensity: parseFloat(grainIntensitySlider.value), grainScale: parseFloat(grainScaleSlider.value), grainSaturation: parseFloat(grainSaturationSlider.value), grainReduceShadows: parseFloat(grainReduceShadowsSlider.value), grainShadowSat: parseFloat(grainShadowSatSlider.value), grainReduceHighlights: parseFloat(grainReduceHighlightsSlider.value), grainHighlightSat: parseFloat(grainHighlightSatSlider.value), dustMoveX: parseFloat(dustMoveXSlider.value), dustMoveY: parseFloat(dustMoveYSlider.value), dustRotate: parseFloat(dustRotateSlider.value) };
            let currentResult = inputTexture;
            if (vals.highPassRadius > 0 && vals.highPassOpacity > 0) {
                applySeparableBlur(currentResult, fboSet.highPassBlur, vals.highPassRadius * nF, tileRect, destRect, fboSet, tileResolution, tileResolution);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.highPass.fbo); drawQuadWithRegions(progs.highPass, { u_original: currentResult, u_blurred: fboSet.highPassBlur.texture }, tileRect, destRect, tileResolution, tileResolution);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.highPassOverlay.fbo); drawQuadWithRegions(progs.overlayBlend, { u_base: currentResult, u_overlay: fboSet.highPass.texture, u_opacity: vals.highPassOpacity }, tileRect, destRect, tileResolution, tileResolution);
                currentResult = fboSet.highPassOverlay.texture;
            }
            if (grainTexture && vals.grainIntensity > 0) {
                const preCurveLut = generateCurveLut([[0,0], [0.2, 0.137], [0.517, 0.384], [0.8, 0.713], [1,1]]);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.precurve.fbo); drawQuadWithRegions(progs.curves, { u_image: currentResult, u_lut: preCurveLut }, tileRect, destRect, tileResolution, tileResolution); gl.deleteTexture(preCurveLut);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.grainApplied.fbo); drawQuadWithRegions(progs.grain, { u_base: fboSet.precurve.texture, u_grain: grainTexture, u_dust: dustTexture, u_dustEnabled: dustEnabledToggle.checked, u_intensity: vals.grainIntensity, u_grainScale: vals.grainScale, u_grainSaturation: vals.grainSaturation, u_reduceShadows: vals.grainReduceShadows, u_shadowSat: vals.grainShadowSat, u_reduceHighlights: vals.grainReduceHighlights, u_highlightSat: vals.grainHighlightSat, u_canvasResolution: globalResolution, u_sourceResolution: [originalImageDimensions.w, originalImageDimensions.h], u_imageScale: parseFloat(imageScaleSlider.value), u_dustOffset: [vals.dustMoveX, -vals.dustMoveY], u_dustRotation: vals.dustRotate, u_fullUVRect: fullUVRect || [tileRect.x, tileRect.y, tileRect.w, tileRect.h] }, tileRect, destRect, tileResolution, tileResolution);
                const postCurveLut = generateCurveLut([[0,0], [0.137, 0.2], [0.384, 0.517], [0.713, 0.8], [1,1]]);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.postcurve.fbo); drawQuadWithRegions(progs.curves, { u_image: fboSet.grainApplied.texture, u_lut: postCurveLut }, tileRect, destRect, tileResolution, tileResolution); gl.deleteTexture(postCurveLut);
            } else {
                 gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.postcurve.fbo);
                 drawQuadWithRegions(progs.passthrough, { u_image: currentResult }, tileRect, destRect, tileResolution, tileResolution);
            }
        }
        
        function updateSliderLabels() {
            halationIntensityValLabel.textContent = parseFloat(halationIntensitySlider.value).toFixed(2);
            if (whiteCompValLabel) whiteCompValLabel.textContent = parseFloat(whiteCompSlider.value).toFixed(2);
            if (whiteCompLimitValLabel) whiteCompLimitValLabel.textContent = parseFloat(whiteCompLimitSlider.value).toFixed(2);
            mtfMaskValLabel.textContent = parseFloat(mtfMaskSlider.value).toFixed(1); mtfSoftnessValLabel.textContent = parseFloat(mtfSoftnessSlider.value).toFixed(1); blackpointValLabel.textContent = parseFloat(blackpointSlider.value).toFixed(2); whitepointValLabel.textContent = parseFloat(whitepointSlider.value).toFixed(2); thresholdGammaValLabel.textContent = parseFloat(thresholdGammaSlider.value).toFixed(2); coreBlurValLabel.textContent = parseFloat(coreBlurSlider.value).toFixed(1); midBlurValLabel.textContent = parseFloat(midBlurSlider.value).toFixed(1); outerBlurValLabel.textContent = parseFloat(outerBlurSlider.value).toFixed(1); midBlurGainValLabel.textContent = parseFloat(midBlurGainSlider.value).toFixed(2); outerBlurGainValLabel.textContent = parseFloat(outerBlurGainSlider.value).toFixed(2); tintR2ValLabel.textContent = parseFloat(tintR2Slider.value).toFixed(2); tintG2ValLabel.textContent = parseFloat(tintG2Slider.value).toFixed(2); tintB2ValLabel.textContent = parseFloat(tintB2Slider.value).toFixed(2); diffusionRadiusValLabel.textContent = parseFloat(diffusionRadiusSlider.value).toFixed(1); diffusionStrengthValLabel.textContent = parseFloat(diffusionStrengthSlider.value).toFixed(2); diffusionRadiusBValLabel.textContent = parseFloat(diffusionRadiusBSlider.value).toFixed(1); diffusionStrengthBValLabel.textContent = parseFloat(diffusionStrengthBSlider.value).toFixed(2); diffusionRadiusCValLabel.textContent = parseFloat(diffusionRadiusCSlider.value).toFixed(1); diffusionStrengthCValLabel.textContent = parseFloat(diffusionStrengthCSlider.value).toFixed(2); diffusionSpreadValLabel.textContent = parseFloat(diffusionSpreadSlider.value).toFixed(2); diffusionGammaValLabel.textContent = parseFloat(diffusionGammaSlider.value).toFixed(2); diffusionIntensityValLabel.textContent = parseFloat(diffusionIntensitySlider.value).toFixed(2);
            
            // Update DEF diffusion labels
            if (diffusionRadiusDValLabel) diffusionRadiusDValLabel.textContent = parseFloat(diffusionRadiusDSlider.value).toFixed(1);
            if (diffusionStrengthDValLabel) diffusionStrengthDValLabel.textContent = parseFloat(diffusionStrengthDSlider.value).toFixed(2);
            if (diffusionRadiusEValLabel) diffusionRadiusEValLabel.textContent = parseFloat(diffusionRadiusESlider.value).toFixed(1);
            if (diffusionStrengthEValLabel) diffusionStrengthEValLabel.textContent = parseFloat(diffusionStrengthESlider.value).toFixed(2);
            if (diffusionRadiusFValLabel) diffusionRadiusFValLabel.textContent = parseFloat(diffusionRadiusFSlider.value).toFixed(1);
            if (diffusionStrengthFValLabel) diffusionStrengthFValLabel.textContent = parseFloat(diffusionStrengthFSlider.value).toFixed(2);
            if (diffusionTint2RValLabel) diffusionTint2RValLabel.textContent = parseFloat(diffusionTint2RSlider.value).toFixed(2);
            if (diffusionTint2GValLabel) diffusionTint2GValLabel.textContent = parseFloat(diffusionTint2GSlider.value).toFixed(2);
            if (diffusionTint2BValLabel) diffusionTint2BValLabel.textContent = parseFloat(diffusionTint2BSlider.value).toFixed(2);
            if (diffusionSpread2ValLabel) diffusionSpread2ValLabel.textContent = parseFloat(diffusionSpread2Slider.value).toFixed(2);
            if (diffusionGamma2ValLabel) diffusionGamma2ValLabel.textContent = parseFloat(diffusionGamma2Slider.value).toFixed(2);
            if (diffusionIntensity2ValLabel) diffusionIntensity2ValLabel.textContent = parseFloat(diffusionIntensity2Slider.value).toFixed(2);
            if (diffusionThreshold2ValLabel) diffusionThreshold2ValLabel.textContent = parseFloat(diffusionThreshold2Slider.value).toFixed(2);
            if (thresholdGamma2ValLabel) thresholdGamma2ValLabel.textContent = parseFloat(thresholdGamma2Slider.value).toFixed(2);
            if (thresholdWhite2ValLabel) thresholdWhite2ValLabel.textContent = parseFloat(thresholdWhite2Slider.value).toFixed(2);
            grainIntensityValLabel.textContent=parseFloat(grainIntensitySlider.value).toFixed(2); highPassRadiusValLabel.textContent=parseFloat(highPassRadiusSlider.value).toFixed(1); highPassOpacityValLabel.textContent=parseFloat(highPassOpacitySlider.value).toFixed(2); grainScaleValLabel.textContent=parseFloat(grainScaleSlider.value).toFixed(2); dustMoveXValLabel.textContent=parseFloat(dustMoveXSlider.value).toFixed(2); dustMoveYValLabel.textContent=parseFloat(dustMoveYSlider.value).toFixed(2); dustRotateValLabel.textContent=parseFloat(dustRotateSlider.value).toFixed(2); grainSaturationValLabel.textContent=parseFloat(grainSaturationSlider.value).toFixed(2); grainReduceShadowsValLabel.textContent=parseFloat(grainReduceShadowsSlider.value).toFixed(2); grainShadowSatValLabel.textContent=parseFloat(grainShadowSatSlider.value).toFixed(2); grainReduceHighlightsValLabel.textContent=parseFloat(grainReduceHighlightsSlider.value).toFixed(2); grainHighlightSatValLabel.textContent=parseFloat(grainHighlightSatSlider.value).toFixed(2); borderScaleValLabel.textContent=parseFloat(borderScaleSlider.value).toFixed(2); imageScaleValLabel.textContent=parseFloat(imageScaleSlider.value).toFixed(2); cheatAspectXValLabel.textContent=parseFloat(cheatAspectXSlider.value).toFixed(2); cheatAspectYValLabel.textContent=parseFloat(cheatAspectYSlider.value).toFixed(2); blackLevelBiasValLabel.textContent=parseFloat(blackLevelBiasSlider.value).toFixed(2); overscanValLabel.textContent = parseFloat(overscanSlider.value).toFixed(2); framingValLabel.textContent = parseFloat(framingSlider.value).toFixed(2); sprocketContrastValLabel.textContent = parseFloat(sprocketContrastSlider.value).toFixed(2); if (sprocketScaleValLabel && sprocketScaleSlider) sprocketScaleValLabel.textContent = parseFloat(sprocketScaleSlider.value).toFixed(2);
                    if (adjacentFrameDistanceValLabel) adjacentFrameDistanceValLabel.textContent = parseFloat(adjacentFrameDistanceSlider.value).toFixed(0);
        if (framePaddingValLabel) framePaddingValLabel.textContent = parseFloat(framePaddingSlider.value).toFixed(2);
        if (borderBlurValLabel) borderBlurValLabel.textContent = parseFloat(borderBlurSlider.value).toFixed(1);
            if (diffusionThresholdValLabel && diffusionThresholdSlider) diffusionThresholdValLabel.textContent = parseFloat(diffusionThresholdSlider.value).toFixed(2);
            const sprocket16mmScaleValLabel = document.getElementById('sprocket16mmScaleVal');
            const sprocket16mmScaleSlider = document.getElementById('sprocket16mmScale');
            if (sprocket16mmScaleValLabel && sprocket16mmScaleSlider) sprocket16mmScaleValLabel.textContent = parseFloat(sprocket16mmScaleSlider.value).toFixed(2);
            // 35mm 1.78 sliders
            const sprocket35mm178ScaleValLabel = document.getElementById('sprocket35mm178ScaleVal');
            const sprocket35mm178ScaleSlider = document.getElementById('sprocket35mm178Scale');
            if (sprocket35mm178ScaleValLabel && sprocket35mm178ScaleSlider) sprocket35mm178ScaleValLabel.textContent = parseFloat(sprocket35mm178ScaleSlider.value).toFixed(2);
            const sprocket35mm178TranslationValLabel = document.getElementById('sprocket35mm178TranslationVal');
            const sprocket35mm178TranslationSlider = document.getElementById('sprocket35mm178Translation');
            if (sprocket35mm178TranslationValLabel && sprocket35mm178TranslationSlider) sprocket35mm178TranslationValLabel.textContent = parseFloat(sprocket35mm178TranslationSlider.value).toFixed(2);
            
            // 35mm 2.40 sliders
            const sprocket35mm240ScaleValLabel = document.getElementById('sprocket35mm240ScaleVal');
            const sprocket35mm240ScaleSlider = document.getElementById('sprocket35mm240Scale');
            if (sprocket35mm240ScaleValLabel && sprocket35mm240ScaleSlider) sprocket35mm240ScaleValLabel.textContent = parseFloat(sprocket35mm240ScaleSlider.value).toFixed(2);
            const sprocket35mm240TranslationValLabel = document.getElementById('sprocket35mm240TranslationVal');
            const sprocket35mm240TranslationSlider = document.getElementById('sprocket35mm240Translation');
            if (sprocket35mm240TranslationValLabel && sprocket35mm240TranslationSlider) sprocket35mm240TranslationValLabel.textContent = parseFloat(sprocket35mm240TranslationSlider.value).toFixed(2);
            
            // 35mm 1.33 sliders
            const sprocket35mm133ScaleValLabel = document.getElementById('sprocket35mm133ScaleVal');
            const sprocket35mm133ScaleSlider = document.getElementById('sprocket35mm133Scale');
            if (sprocket35mm133ScaleValLabel && sprocket35mm133ScaleSlider) sprocket35mm133ScaleValLabel.textContent = parseFloat(sprocket35mm133ScaleSlider.value).toFixed(2);
            const sprocket35mm133TranslationValLabel = document.getElementById('sprocket35mm133TranslationVal');
            const sprocket35mm133TranslationSlider = document.getElementById('sprocket35mm133Translation');
            if (sprocket35mm133TranslationValLabel && sprocket35mm133TranslationSlider) sprocket35mm133TranslationValLabel.textContent = parseFloat(sprocket35mm133TranslationSlider.value).toFixed(2);
            // Chroma Ab labels
            const chromaSamplesValLabel = document.getElementById('chromaSamplesVal');
            const chromaSamplesSlider = document.getElementById('chromaSamples');
            if (chromaSamplesValLabel && chromaSamplesSlider) chromaSamplesValLabel.textContent = (parseInt(chromaSamplesSlider.value, 10) || 0).toString();
            const chromaBlurValLabel = document.getElementById('chromaBlurVal');
            const chromaBlurSlider = document.getElementById('chromaBlur');
            if (chromaBlurValLabel && chromaBlurSlider) chromaBlurValLabel.textContent = (parseFloat(chromaBlurSlider.value) || 0).toFixed(3);
            const chromaFalloffValLabel = document.getElementById('chromaFalloffVal');
            const chromaFalloffSlider = document.getElementById('chromaFalloff');
            if (chromaFalloffValLabel && chromaFalloffSlider) chromaFalloffValLabel.textContent = (parseFloat(chromaFalloffSlider.value) || 0).toFixed(2);
        }
        
        function createTexture(img, isTiling, premultiplyAlpha = false) { const tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,tex); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); if (premultiplyAlpha) { gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true); } gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img); if (premultiplyAlpha) { gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false); } gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); const isWebGL2Ctx=(typeof WebGL2RenderingContext!=='undefined' && gl instanceof WebGL2RenderingContext); const w=(img.naturalWidth||img.width||0)|0; const h=(img.naturalHeight||img.height||0)|0; const isPOT=(w>0 && (w&(w-1))===0) && (h>0 && (h&(h-1))===0); const wrap=(isTiling && (isWebGL2Ctx || isPOT))?gl.REPEAT:gl.CLAMP_TO_EDGE; gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,wrap); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,wrap); return tex; }

        function calculateAndStoreMinPixelValue(img) {
            const size = 256;
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = size; tempCanvas.height = size;
            const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, size, size);
            const data = ctx.getImageData(0, 0, size, size).data;
            const pixels = [];
            for (let i = 0; i < data.length; i += 4) { pixels.push({ r: data[i], g: data[i+1], b: data[i+2], lum: 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2] }); }
            pixels.sort((a, b) => a.lum - b.lum);
            const darkPixel = pixels[Math.floor(pixels.length * 0.01)] || { r: 0, g: 0, b: 0 };
            minPixelValue = [ darkPixel.r / 255.0, darkPixel.g / 255.0, darkPixel.b / 255.0 ];
        }

        // High-resolution max pixel sampling with nearest neighbor filtering
        function calculateAndStoreMaxPixelValue(img) {
            const size = 512;
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = size; tempCanvas.height = size;
            const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
            // Set nearest neighbor filtering to preserve fine detail
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, size, size);
            // Store the canvas for display purposes
            maxPixelSampleCanvas = tempCanvas;
            const data = ctx.getImageData(0, 0, size, size).data;
            const pixels = [];
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                pixels.push({ r, g, b, avgBrightness: (r + g + b) / 3 });
            }
            pixels.sort((a, b) => a.avgBrightness - b.avgBrightness);
            // Average of the 10 whitest pixels (highest RGB average) for more robust white point detection
            const brightestCount = Math.min(10, pixels.length); // Exactly 10 pixels (or all if less than 10)
            const startIndex = pixels.length - brightestCount;
            const brightestPixels = pixels.slice(startIndex);
            
            // Calculate average of the brightest 10 pixels
            let totalR = 0, totalG = 0, totalB = 0;
            for (let i = 0; i < brightestPixels.length; i++) {
                totalR += brightestPixels[i].r;
                totalG += brightestPixels[i].g;
                totalB += brightestPixels[i].b;
            }
            const avgR = totalR / brightestCount;
            const avgG = totalG / brightestCount;
            const avgB = totalB / brightestCount;
            
            // Store the raw sampled color for real-time interpolation
            maxPixelValue = [ avgR / 255.0, avgG / 255.0, avgB / 255.0 ];
            
            // Check if white point compensation should be enabled based on limit threshold
            const avgBrightness = (maxPixelValue[0] + maxPixelValue[1] + maxPixelValue[2]) / 3;
            const limitThreshold = whiteCompLimitSlider ? parseFloat(whiteCompLimitSlider.value) : 0.8;
            shouldEnableWhiteComp = avgBrightness >= limitThreshold;
            
            const acesInv = (x) => {
                x = Math.max(0.0, Math.min(0.9999, x));
                const a = -10127.0*x*x + 13702.0*x + 9.0;
                const b = Math.sqrt(Math.max(0.0, a));
                return (b + 59.0*x - 3.0) / (502.0 - 486.0*x);
            };
            const toLinear = (s) => acesInv(Math.pow(Math.max(0.0, Math.min(1.0, s)), 2.2));
            maxPixelLinear = [ toLinear(maxPixelValue[0]), toLinear(maxPixelValue[1]), toLinear(maxPixelValue[2]) ];
        }

        // Recompute min/max from a WebGL texture (used after pre-bake)
        function recomputeMinMaxFromProcessedTexture(tex, w, h) {
            try {
                // Min (use 256 sample)
                const sizeMin = 256;
                const fboMin = createFBO(sizeMin, sizeMin, false);
                const srcRectMin = { x: 0, y: 0, w: w, h: h };
                const dstRectMin = { x: 0, y: 0, w: sizeMin, h: sizeMin };
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboMin.fbo);
                gl.viewport(0, 0, sizeMin, sizeMin);
                drawQuadWithRegions(progs.passthrough, { u_image: tex }, srcRectMin, dstRectMin, [w, h], [sizeMin, sizeMin]);
                const pixelsMin = new Uint8Array(sizeMin * sizeMin * 4);
                gl.readPixels(0, 0, sizeMin, sizeMin, gl.RGBA, gl.UNSIGNED_BYTE, pixelsMin);
                const listMin = [];
                for (let i = 0; i < pixelsMin.length; i += 4) {
                    const r = pixelsMin[i], g = pixelsMin[i+1], b = pixelsMin[i+2];
                    const lum = 0.299*r + 0.587*g + 0.114*b;
                    listMin.push({ r, g, b, lum });
                }
                listMin.sort((a, b) => a.lum - b.lum);
                const idx = Math.floor(listMin.length * 0.01);
                const dark = listMin[Math.max(0, Math.min(listMin.length - 1, idx))] || { r:0, g:0, b:0 };
                minPixelValue = [ dark.r / 255.0, dark.g / 255.0, dark.b / 255.0 ];
                gl.deleteFramebuffer(fboMin.fbo);
                gl.deleteTexture(fboMin.texture);

                // Max (use 512 sample, average of brightest 10 by avg brightness)
                const sizeMax = 512;
                const fboMax = createFBO(sizeMax, sizeMax, false);
                const dstRectMax = { x: 0, y: 0, w: sizeMax, h: sizeMax };
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboMax.fbo);
                gl.viewport(0, 0, sizeMax, sizeMax);
                drawQuadWithRegions(progs.passthrough, { u_image: tex }, srcRectMin, dstRectMax, [w, h], [sizeMax, sizeMax]);
                const pixelsMax = new Uint8Array(sizeMax * sizeMax * 4);
                gl.readPixels(0, 0, sizeMax, sizeMax, gl.RGBA, gl.UNSIGNED_BYTE, pixelsMax);
                const listMax = [];
                for (let i = 0; i < pixelsMax.length; i += 4) {
                    const r = pixelsMax[i], g = pixelsMax[i+1], b = pixelsMax[i+2];
                    listMax.push({ r, g, b, avgBrightness: (r + g + b) / 3 });
                }
                listMax.sort((a, b) => a.avgBrightness - b.avgBrightness);
                const brightestCount = Math.min(10, listMax.length);
                const startIndex = Math.max(0, listMax.length - brightestCount);
                let totalR = 0, totalG = 0, totalB = 0;
                for (let i = startIndex; i < listMax.length; i++) {
                    totalR += listMax[i].r;
                    totalG += listMax[i].g;
                    totalB += listMax[i].b;
                }
                const avgR = totalR / brightestCount;
                const avgG = totalG / brightestCount;
                const avgB = totalB / brightestCount;
                maxPixelValue = [ avgR / 255.0, avgG / 255.0, avgB / 255.0 ];

                const acesInv = (x) => {
                    x = Math.max(0.0, Math.min(0.9999, x));
                    const a = -10127.0*x*x + 13702.0*x + 9.0;
                    const b = Math.sqrt(Math.max(0.0, a));
                    return (b + 59.0*x - 3.0) / (502.0 - 486.0*x);
                };
                const toLinear = (s) => acesInv(Math.pow(Math.max(0.0, Math.min(1.0, s)), 2.2));
                maxPixelLinear = [ toLinear(maxPixelValue[0]), toLinear(maxPixelValue[1]), toLinear(maxPixelValue[2]) ];

                // Update white point auto-enable
                const limitThreshold = whiteCompLimitSlider ? parseFloat(whiteCompLimitSlider.value) : 0.8;
                const avgBrightness = (maxPixelValue[0] + maxPixelValue[1] + maxPixelValue[2]) / 3;
                shouldEnableWhiteComp = avgBrightness >= limitThreshold;

                gl.deleteFramebuffer(fboMax.fbo);
                gl.deleteTexture(fboMax.texture);
            } catch (e) {
                console.warn('Recompute min/max from processed texture failed:', e);
            } finally {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }

        // Recompute min/max from RAW sRGB texture (used to keep border black level and white point free of CA)
        function recomputeMinMaxFromRawTexture(tex, w, h) {
            try {
                // Min
                const sizeMin = 256;
                const fboMin = createFBO(sizeMin, sizeMin, false);
                const srcRectMin = { x: 0, y: 0, w: w, h: h };
                const dstRectMin = { x: 0, y: 0, w: sizeMin, h: sizeMin };
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboMin.fbo);
                gl.viewport(0, 0, sizeMin, sizeMin);
                drawQuadWithRegions(progs.passthrough, { u_image: tex }, srcRectMin, dstRectMin, [w, h], [sizeMin, sizeMin]);
                const pixelsMin = new Uint8Array(sizeMin * sizeMin * 4);
                gl.readPixels(0, 0, sizeMin, sizeMin, gl.RGBA, gl.UNSIGNED_BYTE, pixelsMin);
                const listMin = [];
                for (let i = 0; i < pixelsMin.length; i += 4) {
                    const r = pixelsMin[i], g = pixelsMin[i+1], b = pixelsMin[i+2];
                    const lum = 0.299*r + 0.587*g + 0.114*b;
                    listMin.push({ r, g, b, lum });
                }
                listMin.sort((a, b) => a.lum - b.lum);
                const idx = Math.floor(listMin.length * 0.01);
                const dark = listMin[Math.max(0, Math.min(listMin.length - 1, idx))] || { r:0, g:0, b:0 };
                minPixelValue = [ dark.r / 255.0, dark.g / 255.0, dark.b / 255.0 ];
                gl.deleteFramebuffer(fboMin.fbo);
                gl.deleteTexture(fboMin.texture);

                // Max
                const sizeMax = 512;
                const fboMax = createFBO(sizeMax, sizeMax, false);
                const dstRectMax = { x: 0, y: 0, w: sizeMax, h: sizeMax };
                gl.bindFramebuffer(gl.FRAMEBUFFER, fboMax.fbo);
                gl.viewport(0, 0, sizeMax, sizeMax);
                drawQuadWithRegions(progs.passthrough, { u_image: tex }, srcRectMin, dstRectMax, [w, h], [sizeMax, sizeMax]);
                const pixelsMax = new Uint8Array(sizeMax * sizeMax * 4);
                gl.readPixels(0, 0, sizeMax, sizeMax, gl.RGBA, gl.UNSIGNED_BYTE, pixelsMax);
                const listMax = [];
                for (let i = 0; i < pixelsMax.length; i += 4) {
                    const r = pixelsMax[i], g = pixelsMax[i+1], b = pixelsMax[i+2];
                    listMax.push({ r, g, b, avgBrightness: (r + g + b) / 3 });
                }
                listMax.sort((a, b) => a.avgBrightness - b.avgBrightness);
                const brightestCount = Math.min(10, listMax.length);
                const startIndex = Math.max(0, listMax.length - brightestCount);
                let totalR = 0, totalG = 0, totalB = 0;
                for (let i = startIndex; i < listMax.length; i++) {
                    totalR += listMax[i].r;
                    totalG += listMax[i].g;
                    totalB += listMax[i].b;
                }
                const avgR = totalR / brightestCount;
                const avgG = totalG / brightestCount;
                const avgB = totalB / brightestCount;
                maxPixelValue = [ avgR / 255.0, avgG / 255.0, avgB / 255.0 ];

                const acesInv = (x) => {
                    x = Math.max(0.0, Math.min(0.9999, x));
                    const a = -10127.0*x*x + 13702.0*x + 9.0;
                    const b = Math.sqrt(Math.max(0.0, a));
                    return (b + 59.0*x - 3.0) / (502.0 - 486.0*x);
                };
                const toLinear = (s) => acesInv(Math.pow(Math.max(0.0, Math.min(1.0, s)), 2.2));
                maxPixelLinear = [ toLinear(maxPixelValue[0]), toLinear(maxPixelValue[1]), toLinear(maxPixelValue[2]) ];

                const limitThreshold = whiteCompLimitSlider ? parseFloat(whiteCompLimitSlider.value) : 0.8;
                const avgBrightness = (maxPixelValue[0] + maxPixelValue[1] + maxPixelValue[2]) / 3;
                shouldEnableWhiteComp = avgBrightness >= limitThreshold;

                gl.deleteFramebuffer(fboMax.fbo);
                gl.deleteTexture(fboMax.texture);
            } catch (e) {
                console.warn('Recompute min/max from raw texture failed:', e);
            } finally {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }

        // Helper function to get the interpolated white point value
        function getWhitePointValue() {
            if (!maxPixelValue || !whiteCompSlider) return [1.0, 1.0, 1.0];
            
            const compSlider = parseFloat(whiteCompSlider.value);
            // Interpolate between pure white (1,1,1) and sampled color
            return [
                (1.0 - compSlider) + maxPixelValue[0] * compSlider,
                (1.0 - compSlider) + maxPixelValue[1] * compSlider,
                (1.0 - compSlider) + maxPixelValue[2] * compSlider
            ];
        }

        // Helper function to check if white point compensation should be applied
        function isWhiteCompEnabled() {
            if (!whiteCompSlider) return false;
            
            const compSlider = parseFloat(whiteCompSlider.value);
            if (compSlider <= 0.0) return false;
            
            // Check limit threshold in real-time
            if (maxPixelValue && whiteCompLimitSlider) {
                const avgBrightness = (maxPixelValue[0] + maxPixelValue[1] + maxPixelValue[2]) / 3;
                const limitThreshold = parseFloat(whiteCompLimitSlider.value);
                const enabled = avgBrightness >= limitThreshold;
                
                // Debug logging (remove this later)
            if (window.__debugWhiteComp) {
                    console.log(`White Comp Debug: compSlider=${compSlider.toFixed(3)}, avgBrightness=${avgBrightness.toFixed(3)}, limit=${limitThreshold.toFixed(3)}, enabled=${enabled}`);
                }
                
                return enabled;
            }
            
            return shouldEnableWhiteComp; // Fallback to cached value
        }

        function updateCheatAspectLimits() {
            const cheatAspectXSlider = document.getElementById('cheatAspectX');
            const cheatAspectYSlider = document.getElementById('cheatAspectY');
            if (!cheatAspectXSlider || !cheatAspectYSlider) return;
            
            // Apply to all border engines, even without image loaded
            const canvasIsPortrait = canvas && imageTexture ? (canvas.height > canvas.width) : false;
            
            if (canvasIsPortrait) {
                // In portrait mode: limit cheat X to 1-1.25, cheat Y to 0.75-1.25
                cheatAspectXSlider.min = "1.0";
                cheatAspectXSlider.max = "1.25";
                cheatAspectYSlider.min = "0.75";
                cheatAspectYSlider.max = "1.25";
            } else {
                // In landscape mode: limit cheat X to 0.75-1.25, cheat Y to 1-1.25
                cheatAspectXSlider.min = "0.75";
                cheatAspectXSlider.max = "1.25";
                cheatAspectYSlider.min = "1.0";
                cheatAspectYSlider.max = "1.25";
            }
            
            // Ensure current values are within new limits
            const currentX = parseFloat(cheatAspectXSlider.value);
            const currentY = parseFloat(cheatAspectYSlider.value);
            
            if (currentX < parseFloat(cheatAspectXSlider.min)) {
                cheatAspectXSlider.value = cheatAspectXSlider.min;
            } else if (currentX > parseFloat(cheatAspectXSlider.max)) {
                cheatAspectXSlider.value = cheatAspectXSlider.max;
            }
            
            if (currentY < parseFloat(cheatAspectYSlider.min)) {
                cheatAspectYSlider.value = cheatAspectYSlider.min;
            } else if (currentY > parseFloat(cheatAspectYSlider.max)) {
                cheatAspectYSlider.value = cheatAspectYSlider.max;
            }
            
            updateSliderLabels();
        }
        function calculateOverscanScales() {
            if (!imageTexture) return;
            
            // Update cheat aspect limits based on orientation
            updateCheatAspectLimits();
            
            // Update framing slider visibility based on overscan value
            const currentOverscanValue = parseFloat(overscanSlider.value);
            if (currentOverscanValue < 0.1) {
                framingSliderItem.style.display = 'none';
                framingSlider.value = '1.0';
            } else {
                framingSliderItem.style.display = 'block';
            }
            
            // Enable debug mode for overscan calculations (set to true to see detailed logging)
            window.__debugOverscan = false;
            
            // Debug logging to track function calls
            if (window.__debugOverscan) {
                console.log(`=== calculateOverscanScales() called ===`);
                console.log(`Debug: Current slider values at start - borderScaleSlider.value=${borderScaleSlider.value}, imageScaleSlider.value=${imageScaleSlider.value}`);
            }
            // Default (35mm stills)
            let zoneBX = 800.0; // not directly used; use width/height
            let zoneBY = 322.0;
            let zoneBW = 2240.0;
            let zoneBH = 1516.0;
            let borderWidth = 3840.0;
            let borderHeight = 2160.0;
            
            // 8mm override (coords provided): X 406..3434, Y 71..2087
            if (window.__borderEngine === '8mm') {
                zoneBX = 406.0; zoneBY = 71.0; zoneBW = 3434.0 - 406.0; zoneBH = 2087.0 - 71.0;
            }
            // 16mm override (coords provided): X 163..3662, Y 25..2140
            if (window.__borderEngine === '16mm') {
                zoneBX = 163.0; zoneBY = 25.0; zoneBW = 3662.0 - 163.0; zoneBH = 2140.0 - 25.0;
            }
            // 35mm 1.78 engine - updated coordinates
            if (window.__borderEngine === '35mm-178') {
                zoneBX = 70.0; zoneBY = 38.0; zoneBW = 3761.0 - 70.0; zoneBH = 2122.0 - 38.0;
            }
            // 35mm 2.40 engine - updated coordinates
            if (window.__borderEngine === '35mm-240') {
                zoneBX = 75.0; zoneBY = 306.0; zoneBW = 3754.0 - 75.0; zoneBH = 1856.0 - 306.0;
            }
            // 35mm 1.33 engine - identical to 8mm engine (works flawlessly)
            if (window.__borderEngine === '35mm-133') {
                zoneBX = 406.0; zoneBY = 71.0; zoneBW = 3434.0 - 406.0; zoneBH = 2087.0 - 71.0;
                borderWidth = 3840.0;
                borderHeight = 2160.0;
            }
            // 35mm additive uses the SAME geometry as 35mm stills (default values above)
            if (window.__borderEngine === '35mm-add') {
                // no changes to zoneBX/BW/BH, preserve exact geometry
            }
            // Medium Format engine - custom coordinates (X 702-3150, Y 70-2070)
            if (window.__borderEngine === 'medium-format') {
                zoneBX = 702.0; zoneBY = 70.0; zoneBW = 3150.0 - 702.0; zoneBH = 2070.0 - 70.0;
                borderWidth = 3840.0;
                borderHeight = 2160.0;
            }
            const ZONE_B_WIDTH_RATIO = zoneBW / borderWidth;
            const ZONE_B_HEIGHT_RATIO = zoneBH / borderHeight;
            const ZONE_B_ASPECT = (zoneBW) / (zoneBH); // landscape zoneB aspect
            const targetCanvasW = (virtualCanvasSize?.w || canvas.width);
            const targetCanvasH = (virtualCanvasSize?.h || canvas.height);
            const canvasAspect = targetCanvasW / targetCanvasH;
            // In border mode we already padded at load to a document aspect of either 16:9 (landscape) or 9:16 (portrait),
            // so originalImageDimensions reflect that virtual document size.
            const sourceAspect = originalImageDimensions.w / originalImageDimensions.h;
            const canvasIsPortrait = targetCanvasH > targetCanvasW;

            // Normalize to landscape space if portrait: swap X/Y for BOTH image and border logic
            // For cine engines, use measured canvas aspect but snap near 16:9 to avoid resolution-dependent flips.
            // For stills-like engines, keep exact document aspect (16:9 or 9:16) to remain invariant.
            const isCineEngine = (window.__borderEngine === '8mm' || window.__borderEngine === '16mm' || window.__borderEngine === '35mm-178' || window.__borderEngine === '35mm-240' || window.__borderEngine === '35mm-133');
            const measuredNormCanvasAspect = canvasIsPortrait ? (1 / canvasAspect) : canvasAspect;
            const canonicalLandscapeDocAR = 16 / 9;
            let normCanvasAspect;
            if (isCineEngine) {
                const epsilon = 1e-4;
                normCanvasAspect = Math.abs(measuredNormCanvasAspect - canonicalLandscapeDocAR) < epsilon ? canonicalLandscapeDocAR : measuredNormCanvasAspect;
            } else {
                const DOC_ASPECT = canvasIsPortrait ? (9/16) : (16/9);
                normCanvasAspect = canvasIsPortrait ? (1 / DOC_ASPECT) : DOC_ASPECT;
            }
            const normSourceAspect = canvasIsPortrait ? (1 / sourceAspect) : sourceAspect;
            const zoneW = ZONE_B_WIDTH_RATIO;  // landscape zoneB width
            const zoneH = ZONE_B_HEIGHT_RATIO; // landscape zoneB height

            // Fit image into canvas in normalized (landscape) space to get covered UV
            let coveredUVWidth = 1.0, coveredUVHeight = 1.0;
            if (normCanvasAspect > normSourceAspect) {
                coveredUVWidth = normSourceAspect / normCanvasAspect;
            } else {
                coveredUVHeight = normCanvasAspect / normSourceAspect;
            }

            // How much we need to scale the IMAGE so that zoneB just covers it
            const scaleRatioX = ZONE_B_WIDTH_RATIO / coveredUVWidth;
            const scaleRatioY = ZONE_B_HEIGHT_RATIO / coveredUVHeight;
            let imageScaleToCoverZoneB = Math.max(scaleRatioX, scaleRatioY);
            // For 8mm, 16mm, 35mm-178, 35mm-133: target long-edge fit at overscan=1 (use the smaller ratio)
            // For 35mm-240: needs special handling due to very wide zone aspect ratio
            if (window.__borderEngine === '8mm' || window.__borderEngine === '16mm' || window.__borderEngine === '35mm-178' || window.__borderEngine === '35mm-133') {
                imageScaleToCoverZoneB = Math.min(scaleRatioX, scaleRatioY);
            } else if (window.__borderEngine === '35mm-240') {
                // Special handling for 35mm-240's very wide zone (2.37 aspect ratio)
                // This engine has a much wider zoneB than others, requiring special scaling logic
                // Compare image aspect to zone aspect to decide scaling direction
                if (normSourceAspect < ZONE_B_ASPECT) {
                    // Image is narrower than zone: use width-based scaling (fit width, crop height)
                    imageScaleToCoverZoneB = scaleRatioX;
                } else {
                    // Image is wider than zone: use height-based scaling (fit height, crop width)
                    imageScaleToCoverZoneB = scaleRatioY;
                }
            }
            // 35mm-133 uses default behavior (like 35mm stills) - no override needed

            // Decide if image is narrower than zoneB (in normalized space)
            const isNarrower = normSourceAspect < ZONE_B_ASPECT;

            // Border scales
            let borderScaleAt0;      // base near 0 (slightly outside frame)
            let borderScaleAt0_1;    // target at overscan = 0.1 (zoneB just covers)
            if (window.__borderEngine === '8mm' || window.__borderEngine === '16mm' || window.__borderEngine === '35mm-178' || window.__borderEngine === '35mm-133') {
                // 8mm/16mm/35mm-178/35mm-133: compute gate scale mapping border->canvas in normalized landscape space
                const normBorderAspect = borderWidth / borderHeight;
                let gateScaleX = 1.0, gateScaleY = 1.0;
                if (normCanvasAspect > normBorderAspect) {
                    gateScaleY = normBorderAspect / normCanvasAspect;
                } else if (normCanvasAspect < normBorderAspect) {
                    gateScaleX = normCanvasAspect / normBorderAspect;
                }

                // At overscan 0.1, choose the smaller solution so Zone B just covers
                // along the long-edge-driven direction (matches expected values)
                borderScaleAt0_1 = Math.min(gateScaleX / ZONE_B_WIDTH_RATIO, gateScaleY / ZONE_B_HEIGHT_RATIO);

                // At overscan 0, keep slightly outside frame using cushion relative to min-ratio solution
                const cushion = 1.19;
                borderScaleAt0 = (1.0 / Math.min(scaleRatioX, scaleRatioY)) * cushion;
            } else if (window.__borderEngine === 'medium-format') {
                // Medium Format: compute 0.1 "just covers" via pure gate solve using MF zoneB
                const normBorderAspect = borderWidth / borderHeight;
                let gateScaleX = 1.0, gateScaleY = 1.0;
                if (normCanvasAspect > normBorderAspect) {
                    gateScaleY = normBorderAspect / normCanvasAspect;
                } else if (normCanvasAspect < normBorderAspect) {
                    gateScaleX = normCanvasAspect / normBorderAspect;
                }
                borderScaleAt0_1 = Math.min(gateScaleX / ZONE_B_WIDTH_RATIO, gateScaleY / ZONE_B_HEIGHT_RATIO);
                // Keep slightly outside frame near 0; avoid stills wide-AR tweaks
                const cushion = 1.19;
                borderScaleAt0 = (1.0 / Math.min(scaleRatioX, scaleRatioY)) * cushion;
                if (window.__debugOverscan) {
                    console.log(`MF gate-solve: gateScaleX=${gateScaleX.toFixed(3)} gateScaleY=${gateScaleY.toFixed(3)} ZONE_B_WIDTH_RATIO=${ZONE_B_WIDTH_RATIO.toFixed(3)} ZONE_B_HEIGHT_RATIO=${ZONE_B_HEIGHT_RATIO.toFixed(3)} -> borderScaleAt0_1=${borderScaleAt0_1.toFixed(3)}`);
                }
            } else if (window.__borderEngine === '35mm-240') {
                // Special handling for 35mm-240's very wide zone (2.37 aspect ratio)
                // This engine has a much wider zoneB than others, requiring special cushion logic
                // at overscan 0 to ensure zoneB edges are safely outside the image frame
                const normBorderAspect = borderWidth / borderHeight;
                let gateScaleX = 1.0, gateScaleY = 1.0;
                if (normCanvasAspect > normBorderAspect) {
                    gateScaleY = normBorderAspect / normCanvasAspect;
                } else if (normCanvasAspect < normBorderAspect) {
                    gateScaleX = normCanvasAspect / normBorderAspect;
                }

                // For 35mm-240, use the ratio that matches our image scale choice
                if (normSourceAspect < ZONE_B_ASPECT) {
                    // Image is narrower than zone: width-driven scaling
                    borderScaleAt0_1 = gateScaleX / ZONE_B_WIDTH_RATIO;
                    // For 35mm-240, we need a larger cushion at overscan 0 to ensure zoneB edges are safely outside
                    // The cushion increases as the image gets narrower relative to the very wide zoneB
                    // We also need to account for texture overhang that makes zoneB edges visible even when "touching"
                    const aspectRatioDifference = ZONE_B_ASPECT - normSourceAspect;
                    // Use a more aggressive cushion formula that accounts for texture overhang
                    // Base cushion of 1.19 + exponential increase for narrower images
                    const cushion = 1.19 + (aspectRatioDifference * 0.25) + Math.pow(aspectRatioDifference, 1.5) * 0.08;
                    borderScaleAt0 = (1.0 / scaleRatioX) * cushion;
                    
                    // Debug logging for 35mm-240
                    if (window.__debugOverscan) {
                        console.log(`35mm-240 Debug: normSourceAspect=${normSourceAspect.toFixed(3)}, ZONE_B_ASPECT=${ZONE_B_ASPECT.toFixed(3)}, aspectRatioDifference=${aspectRatioDifference.toFixed(3)}, cushion=${cushion.toFixed(3)}, borderScaleAt0=${borderScaleAt0.toFixed(3)}`);
                    }
                } else {
                    // Image is wider than zone: height-driven scaling
                    borderScaleAt0_1 = gateScaleY / ZONE_B_HEIGHT_RATIO;
                    borderScaleAt0 = (1.0 / scaleRatioY) * 1.19;
                }
            } else if (isNarrower) {
                borderScaleAt0 = 1.52;
                // Use the original curve for the transition shape in narrower case
                const tRaw = (normSourceAspect - 1.0) / (ZONE_B_ASPECT - 1.0);
                const t = Math.max(0, Math.min(1, tRaw));
                borderScaleAt0_1 = 1.0 + 0.71 * Math.pow(t, 2.5);
                // Keep image scale locked to border at/after 0.1
                imageScaleToCoverZoneB = 1.0 / borderScaleAt0_1;
            } else {
                // Default case - primarily 35mm stills engine and 35mm additive
                borderScaleAt0 = Math.max(1 / zoneW, 1 / zoneH) * 1.02;
                
                                    // For wide images in 35mm stills, we need to adjust the border scale at overscan 0.1
                    // to make the zoneB window small enough to eliminate gaps
                    if (normSourceAspect > 1.78) { // Wider than 16:9
                        // For wide images, we need to reduce the border scale to make the zoneB window smaller
                        // The wider the image, the more we need to reduce the scale
                        const aspectRatioFactor = normSourceAspect / 1.78; // How much wider than 16:9
                        const baseScale = 1.0 / imageScaleToCoverZoneB; // Original calculation (1.425 for 2.39:1)
                        
                        // Progressive reduction: wider images get more scale reduction
                        const scaleReduction = (aspectRatioFactor - 1.0) * 0.8; // Reduce scale for wider images
                        borderScaleAt0_1 = baseScale * (1.0 - scaleReduction);
                        
                        if (window.__debugOverscan) {
                            console.log(`Debug: Wide image adjustment - aspectRatioFactor=${aspectRatioFactor.toFixed(3)}, baseScale=${baseScale.toFixed(3)}, scaleReduction=${scaleReduction.toFixed(3)}`);
                        }
                    } else {
                        borderScaleAt0_1 = 1.0 / imageScaleToCoverZoneB;
                    }
                
                // Debug logging for default case (35mm stills)
                if (window.__debugOverscan) {
                    console.log(`Debug: Default case - zoneW=${zoneW.toFixed(3)}, zoneH=${zoneH.toFixed(3)}`);
                    console.log(`Debug: Default case - borderScaleAt0=${borderScaleAt0.toFixed(3)}, borderScaleAt0_1=${borderScaleAt0_1.toFixed(3)}`);
                    console.log(`Debug: Default case - imageScaleToCoverZoneB=${imageScaleToCoverZoneB.toFixed(3)}`);
                }
            }

            const overscanValue = parseFloat(overscanSlider.value);
            let targetBorderScale, targetImageScale;
            
            // Debug logging to show which path we're taking
            if (window.__debugOverscan) {
                console.log(`Debug: overscanValue=${overscanValue}, borderEngine=${window.__borderEngine}, normSourceAspect=${normSourceAspect.toFixed(3)}`);
            }
            if (overscanValue < 0.1) {
                targetImageScale = 1.0;
                const t = overscanValue / 0.1;
                targetBorderScale = borderScaleAt0 * (1.0 - t) + borderScaleAt0_1 * t;
            } else {
                const t = (overscanValue - 0.1) / 0.9;
                if (window.__borderEngine === '8mm' || window.__borderEngine === '16mm' || window.__borderEngine === '35mm-178' || window.__borderEngine === '35mm-133') {
                    // 8mm/16mm/35mm-178/35mm-133: transition border from ZoneB-just-covers to long-edge fit; image from 1.0 to zoneB long-edge ratio
                    const normBorderAspect = borderWidth / borderHeight;
                    let gateScaleX = 1.0, gateScaleY = 1.0;
                    if (normCanvasAspect > normBorderAspect) {
                        gateScaleY = normBorderAspect / normCanvasAspect;
                    } else if (normCanvasAspect < normBorderAspect) {
                        gateScaleX = normCanvasAspect / normBorderAspect;
                    }
                    const longEdgeFitScale = Math.min(gateScaleX, gateScaleY);
                    const imageScaleAt1 = (normCanvasAspect >= normBorderAspect) ? ZONE_B_HEIGHT_RATIO : ZONE_B_WIDTH_RATIO;
                    const eased = Math.pow(Math.max(0.0, Math.min(1.0, t)), 0.4);
                    targetBorderScale = borderScaleAt0_1 * (1.0 - eased) + longEdgeFitScale * eased;
                    targetImageScale = 1.0 * (1.0 - eased) + imageScaleAt1 * eased;
                } else if (window.__borderEngine === '35mm-240') {
                    // Special handling for 35mm-240's very wide zone (2.37 aspect ratio)
                    // Maintains the same scaling direction established at overscan 0.1
                    const normBorderAspect = borderWidth / borderHeight;
                    let gateScaleX = 1.0, gateScaleY = 1.0;
                    if (normCanvasAspect > normBorderAspect) {
                        gateScaleY = normBorderAspect / normCanvasAspect;
                    } else if (normCanvasAspect < normBorderAspect) {
                        gateScaleX = normCanvasAspect / normBorderAspect;
                    }
                    
                    // For images with aspect ratio over 2:1, compress the overscan effect from 0.1 to 1.0
                    // so that overscan 1.0 gives the same result as overscan 0.1 would normally give
                    let adjustedT = t;
                    if (normSourceAspect > 2.0) {
                        // Compress the range: t=1.0 should give the same result as t=0.1 normally would
                        // This means we need to scale t by 0.1 when it's above 0.1
                        if (t > 0.1) {
                            adjustedT = 0.1 + (t - 0.1) * 0.1;
                        }
                    }
                    
                    const eased = Math.pow(Math.max(0.0, Math.min(1.0, adjustedT)), 0.4);
                    
                    // Debug logging for 35mm-240 overscan compression
                    if (window.__debugOverscan && normSourceAspect > 2.0) {
                        console.log(`35mm-240 Overscan Compression: normSourceAspect=${normSourceAspect.toFixed(3)}, originalT=${t.toFixed(3)}, adjustedT=${adjustedT.toFixed(3)}, eased=${eased.toFixed(3)}`);
                    }
                    
                    if (normSourceAspect < ZONE_B_ASPECT) {
                        // Image is narrower than zone: width-driven transition
                        const longEdgeFitScale = gateScaleX;
                        const imageScaleAt1 = ZONE_B_WIDTH_RATIO;
                        targetBorderScale = borderScaleAt0_1 * (1.0 - eased) + longEdgeFitScale * eased;
                        targetImageScale = 1.0 * (1.0 - eased) + imageScaleAt1 * eased;
                    } else {
                        // Image is wider than zone: height-driven transition, but border needs to scale down more
                        const longEdgeFitScale = Math.min(gateScaleX, gateScaleY); // Use smaller scale for better fit
                        const imageScaleAt1 = ZONE_B_HEIGHT_RATIO;
                        targetBorderScale = borderScaleAt0_1 * (1.0 - eased) + longEdgeFitScale * eased;
                        targetImageScale = 1.0 * (1.0 - eased) + imageScaleAt1 * eased;
                    }

                } else if (window.__borderEngine === '35mm-stills' || window.__borderEngine === '35mm-add' || window.__borderEngine === 'medium-format') {
                    // 35mm stills / add / medium-format share the same shape,
                    // but medium-format should maintain the 0.1 relationship exactly when zooming out.
                    if (window.__debugOverscan) {
                        console.log(`Debug: Stills-like path (engine=${window.__borderEngine}), t=${t.toFixed(3)}`);
                    }
                    targetBorderScale = borderScaleAt0_1 * (1.0 - t) + 1.0 * t;
                    let imageScaleAt1Desired;
                    if (window.__borderEngine === 'medium-format') {
                        // Zoom out the pair as a unit: at t=1, image scale equals 1 / borderScaleAt0_1
                        imageScaleAt1Desired = 1.0 / Math.max(1e-6, borderScaleAt0_1);
                        if (window.__debugOverscan) {
                            console.log(`Debug: MediumFormat imageScaleAt1Desired from 1/borderScaleAt0_1 = ${(imageScaleAt1Desired).toFixed(3)}`);
                        }
                    } else {
                        // Preserve existing 35mm-stills behavior
                        imageScaleAt1Desired = imageScaleToCoverZoneB;
                        if (normSourceAspect >= 1.78) {
                            const x = normSourceAspect - 1.78;
                            const a = 0.5066, b = 0.0352, c = 0.73; // fitted coefficients
                            const y = a * x * x + b * x + c;
                            imageScaleAt1Desired = Math.min(0.98, Math.max(0.73, y));
                            if (window.__debugOverscan) {
                                console.log(`Debug: 35mm-stills imageScaleAt1Desired: ar=${normSourceAspect.toFixed(3)}, x=${x.toFixed(3)}, y=${y.toFixed(3)}, clamped=${imageScaleAt1Desired.toFixed(3)}`);
                            }
                        }
                    }
                    targetImageScale = 1.0 * (1.0 - t) + imageScaleAt1Desired * t;
                } else {
                    // Default fallback behavior for any other engines
                    targetBorderScale = borderScaleAt0_1 * (1.0 - t) + 1.0 * t;
                    targetImageScale = 1.0 * (1.0 - t) + imageScaleToCoverZoneB * t;
                }
            }

            // Apply dynamic aspect multiplier in border canvas mode to hide 16:9 padding
            // Multiplier formula (TCL-style from Nuke):
            // (sourceLongEdge/sourceShortEdge) > (16/9) ?
            //   (sourceLongEdge/sourceShortEdge)/(16/9) : (16/9)/(sourceLongEdge/sourceShortEdge)
            if (currentShapeIsBorder()) {
                const srcW0 = (sourceNativeDimensions && sourceNativeDimensions.w) ? sourceNativeDimensions.w : originalImageDimensions.w;
                const srcH0 = (sourceNativeDimensions && sourceNativeDimensions.h) ? sourceNativeDimensions.h : originalImageDimensions.h;
                if (srcW0 > 0 && srcH0 > 0) {
                    const longOverShort = (srcW0 >= srcH0) ? (srcW0 / srcH0) : (srcH0 / srcW0);
                    const SIXTEEN_NINE = 16 / 9;
                    const aspectMultiplier = (longOverShort > SIXTEEN_NINE)
                        ? (longOverShort / SIXTEEN_NINE)
                        : (SIXTEEN_NINE / longOverShort);
                    targetImageScale *= aspectMultiplier;
                    // Clamp to slider limits to avoid invalid values
                    const imgMin = parseFloat(imageScaleSlider.min || '0.25');
                    const imgMax = parseFloat(imageScaleSlider.max || '2');
                    targetImageScale = Math.max(imgMin, Math.min(imgMax, targetImageScale));
                    if (window.__debugOverscan) {
                        console.log(`Aspect multiplier applied: long/short=${longOverShort.toFixed(6)}, mult=${aspectMultiplier.toFixed(6)} -> imageScale=${targetImageScale.toFixed(6)}`);
                    }

                    // Additional zoneB-aware multiplier (only when native AR is narrower than 16:9)
                    // Goal: bring the edges of the original image to just cover the current Zone B window, without revealing padding.
                    if (longOverShort < SIXTEEN_NINE) {
                        const zoneBAspect = ZONE_B_ASPECT; // landscape zone B aspect (>= 1)
                        let zoneMultiplier = 1.0;

                        const engine = window.__borderEngine || '';
                        const isStillsLike = (engine === '35mm-add' || engine === '35mm-stills' || engine === 'medium-format');
                        const isCine133 = (engine === '35mm-133');
                        const isCineNoAdjust = (engine === '16mm' || engine === '35mm-178' || engine === '8mm' || engine === '35mm-240');

                        if (!isCineNoAdjust) {
                            if (isStillsLike) {
                                // Works for 35mm stills/add and medium format (matches provided targets)
                                // zoneMultiplier = max(srcAR, zoneAR) / (16/9)
                                zoneMultiplier = Math.max(longOverShort, zoneBAspect) / SIXTEEN_NINE;
                            } else if (isCine133) {
                                // 35mm 1.33 cine needs a gentler, AR-dependent correction.
                                // Fit a compact model to the user targets:
                                // F(longOverShort) = (zoneAR / (16/9)) ^ g(A_src), with
                                // g(A_src) ≈ a - b * ((A_src - 1.05) / ( (16/9) - 1.05 )), clamped to [0, +inf)
                                // a ~= 0.703, b ~= 0.938 gives ~0.887 at 1.05 and ~0.979 at 1.50
                                const base = zoneBAspect / SIXTEEN_NINE;
                                const denom = Math.max(1e-6, (SIXTEEN_NINE - 1.05));
                                const t = Math.max(0, Math.min(1, (longOverShort - 1.05) / denom));
                                const a = 0.703, b = 0.938;
                                const g = Math.max(0.0, a - b * t);
                                zoneMultiplier = Math.pow(base, g);
                            } else {
                                // Default: stills-like behavior as a reasonable fallback
                                zoneMultiplier = Math.max(longOverShort, zoneBAspect) / SIXTEEN_NINE;
                            }

                            // Interpolate multiplier weight: 0 at overscan=0, full at overscan=0.1, then constant
                            let zoneWeight = 1.0;
                            if (overscanValue < 0.1) {
                                // Non-linear ramp: stay near 0 for most of [0, 0.1), then ramp late and fast
                                const x = Math.max(0, Math.min(1, overscanValue / 0.1));
                                const start = 0.65; // begin ramp ~65% through the segment (overscan ~0.065)
                                const gamma = 2.0;  // steeper near the end; increase for even later/faster ramp
                                let y = (x - start) / (1 - start);
                                y = Math.max(0, Math.min(1, y));
                                zoneWeight = Math.pow(y, gamma);
                            }
                            const effectiveZoneMultiplier = 1.0 + zoneWeight * (zoneMultiplier - 1.0);
                            targetImageScale *= effectiveZoneMultiplier;
                            targetImageScale = Math.max(imgMin, Math.min(imgMax, targetImageScale));
                            if (window.__debugOverscan) {
                                console.log(`Zone multiplier applied: engine=${engine}, zoneAR=${zoneBAspect.toFixed(6)}, baseMult=${zoneMultiplier.toFixed(6)}, weight=${zoneWeight.toFixed(3)}, effMult=${effectiveZoneMultiplier.toFixed(6)} -> imageScale=${targetImageScale.toFixed(6)}`);
                            }
                        }
                    }
                }
            }

            borderScaleSlider.value = targetBorderScale;
            imageScaleSlider.value = targetImageScale;
            
            // Debug logging for final values and verification
            if (window.__debugOverscan) {
                console.log(`Debug: Final values - targetBorderScale=${targetBorderScale.toFixed(3)}, targetImageScale=${targetImageScale.toFixed(3)}`);
                console.log(`Debug: Slider values after setting - borderScaleSlider.value=${borderScaleSlider.value}, imageScaleSlider.value=${imageScaleSlider.value}`);
            }
            
            updateSliderLabels();
            render();
        }

        let forceOriginalWorkingLoadOnce = false;
        let loadingOverlayTimeout = null;
        
        function showImageLoadingOverlay(immediate = false) {
            if (!imageLoadingOverlay) return;
            
            // Clear any existing timeout
            if (loadingOverlayTimeout) {
                clearTimeout(loadingOverlayTimeout);
                loadingOverlayTimeout = null;
            }
            
            if (immediate) {
                // Show immediately for mode switches
                imageLoadingOverlay.classList.add('active');
                imageLoadingOverlay.setAttribute('aria-hidden', 'false');
            } else {
                // Delay showing by 500ms to avoid flicker for fast operations
                loadingOverlayTimeout = setTimeout(() => {
                    if (imageLoadingOverlay) {
                        imageLoadingOverlay.classList.add('active');
                        imageLoadingOverlay.setAttribute('aria-hidden', 'false');
                    }
                    loadingOverlayTimeout = null;
                }, 500);
            }
        }

        function hideImageLoadingOverlay() {
            if (!imageLoadingOverlay) return;
            
            // Clear any pending timeout
            if (loadingOverlayTimeout) {
                clearTimeout(loadingOverlayTimeout);
                loadingOverlayTimeout = null;
            }
            
            imageLoadingOverlay.classList.remove('active');
            imageLoadingOverlay.setAttribute('aria-hidden', 'true');
        }

        function beginImageLoadTransition(immediate = false) {
            if (suppressImageFade) {
                isImageLoadTransitionActive = false;
                hideImageLoadingOverlay();
                return;
            }
            isImageLoadTransitionActive = true;
            if (!canvas.style.transition) {
                canvas.style.transition = 'opacity 180ms ease';
            }
            void canvas.offsetWidth;
            canvas.style.opacity = '0';
            showImageLoadingOverlay(immediate);
        }

        function finishImageLoadTransition() {
            isImageLoadTransitionActive = false;
            hideImageLoadingOverlay();
        }

        function abortImageLoadTransition() {
            if (!isImageLoadTransitionActive) {
                hideImageLoadingOverlay();
                return;
            }
            isImageLoadTransitionActive = false;
            hideImageLoadingOverlay();
            canvas.style.visibility = 'visible';
            canvas.style.opacity = '1';
        }

        function loadImageAndResize(fileOrBlob, callback) {
            // Show processing transition for higher resolutions (above 2048px) OR when not suppressing fade
            const rawSlider = document.getElementById('maxResSlider').value;
            const isHighRes = parseInt(rawSlider, 10) > 2048;
            const isModeSwitch = !suppressImageFade;
            const shouldShowProcessing = isHighRes || isModeSwitch;
            if (shouldShowProcessing) {
                // Show immediately for mode switches, delayed for resolution changes
                beginImageLoadTransition(isModeSwitch);
            }
            const img = new Image();
            const url = URL.createObjectURL(fileOrBlob);
            img.onload = () => {
                URL.revokeObjectURL(url);
                const isOriginalMax = (parseInt(rawSlider,10) >= ORIGINAL_SLIDER_VALUE) || forceOriginalWorkingLoadOnce;
                
                // Apply aspect ratio multiplier to resolution for non-16:9 border modes
                const aspectMultiplier = getAspectRatioMultiplier();
                const maxEdgeSliderBase = isOriginalMax ? Number.MAX_SAFE_INTEGER : parseInt(rawSlider, 10);
                const maxEdgeSlider = isOriginalMax ? Number.MAX_SAFE_INTEGER : Math.round(maxEdgeSliderBase * aspectMultiplier);
                const oW = img.naturalWidth, oH = img.naturalHeight, aspect = oW / oH;
                let cW = oW, cH = oH;
                if (!isOriginalMax) {
                    if (currentShapeIsBorder()) {
                        // Scale based on final padded document long-edge (16:9 or 9:16),
                        // so the padded canvas adheres to the slider cap.
                        const isPortraitDoc = (oH > oW);
                        const t = isPortraitDoc ? (9/16) : (16/9); // doc width/height aspect
                        const A = aspect; // width/height of source
                        // Compute the unscaled document long-edge
                        let L0;
                        if (t >= 1) {
                            // landscape document (16:9)
                            L0 = (A <= t) ? (oH * t) : oW;
                        } else {
                            // portrait document (9:16)
                            L0 = (A > t) ? (oW / t) : oH;
                        }
                        if (L0 > maxEdgeSlider) {
                            // Compute scale so padded long-edge equals cap
                            let s;
                            if (t >= 1) {
                                s = (A <= t) ? (maxEdgeSlider / (oH * t)) : (maxEdgeSlider / oW);
                            } else {
                                s = (A > t) ? ((maxEdgeSlider * t) / oW) : (maxEdgeSlider / oH);
                            }
                            s = Math.min(1, s);
                            cW = Math.max(1, Math.round(oW * s));
                            cH = Math.max(1, Math.round(oH * s));
                        } else {
                            // No downscale needed
                            cW = oW; cH = oH;
                        }
                    } else {
                        // Image mode: cap the image long-edge directly
                        if (Math.max(oW, oH) > maxEdgeSlider) {
                            if (oW >= oH) { cW = maxEdgeSlider; cH = Math.round(cW / aspect); }
                            else { cH = maxEdgeSlider; cW = Math.round(cH * aspect); }
                        }
                    }
                }
                const rCanvas = document.createElement('canvas');
                rCanvas.width = cW; rCanvas.height = cH;
                rCanvas.getContext('2d').drawImage(img, 0, 0, cW, cH);
                img.onload = null; img.onerror = null; img.src = '';
                loadMainImage(rCanvas);
                // Reset one-shot force flag after use
                if (forceOriginalWorkingLoadOnce) forceOriginalWorkingLoadOnce = false;
                if(callback) callback();
            };
            img.onerror = () => {
                URL.revokeObjectURL(url);
                img.src = '';
                abortImageLoadTransition();
                alert("Could not load image file.");
                if(callback) callback(new Error("Image load failed"));
            };
            img.src = url;
        }
        function loadMainImage(imageSource) {
            if (!appContainer.classList.contains('image-loaded')) {
                appContainer.classList.add('image-loaded');
                const pct0 = Math.max(0, Math.min(100, parseInt(backgroundSlider.value,10)||0));
                const g0 = Math.round(255 * (pct0 / 100));
                viewport.style.backgroundColor = `rgb(${g0},${g0},${g0})`;
            }
            const prevScale = scale;
            const prevOffsetX = offsetX;
            const prevOffsetY = offsetY;
            const prevFitScale = fitScale;
            // Prepare fade-in unless suppressed (e.g., proxy/export reloads)
            if (!suppressImageFade) {
                canvas.style.opacity = '0';
                canvas.style.visibility = 'hidden';
                // Use a 400ms fade for image loads
                canvas.style.transition = 'opacity 400ms ease';
            }
            // Track the native (pre-pad) source dimensions for border-mode aspect multiplier
            sourceNativeDimensions = { w: imageSource.width || 0, h: imageSource.height || 0 };
            // If border mode is active, pad the source to the document aspect:
            // - Landscape source -> 16:9
            // - Portrait source  -> 9:16
            if (currentShapeIsBorder()) {
                const srcW = imageSource.width;
                const srcH = imageSource.height;
                const isPortrait = srcH > srcW;
                const targetAspect = isPortrait ? (9/16) : (16/9);
                const srcAspect = srcW / srcH;
                let padW = srcW;
                let padH = srcH;
                if (!isPortrait) {
                  // Landscape document target (16:9)
                  if (srcAspect > targetAspect) {
                    // Wider than 16:9 -> increase height
                    padH = Math.round(srcW / targetAspect);
                  } else if (srcAspect < targetAspect) {
                    // Narrower than 16:9 -> increase width
                    padW = Math.round(srcH * targetAspect);
                  }
                } else {
                  // Portrait document target (9:16)
                  const targetAspectInv = 1 / targetAspect; // 16/9 (~1.778)
                  const srcAspectInv = srcH / srcW;         // invert comparison in portrait space
                  if (srcAspectInv > targetAspectInv) {
                    // Taller than 9:16 -> increase width (portrait doc)
                    // padW/padH should equal 9:16 => width = height * (9/16)
                    padW = Math.round(srcH * targetAspect);
                  } else if (srcAspectInv < targetAspectInv) {
                    // Narrower than 9:16 -> increase height (portrait doc)
                    // height = width * (16/9)
                    padH = Math.round(srcW * targetAspectInv);
                  }
                }
                if (padW !== srcW || padH !== srcH) {
                  const padded = document.createElement('canvas');
                  padded.width = padW; padded.height = padH;
                  const pctx = padded.getContext('2d');
                  // Fill pure red for testing (rgb 1 0 0 in [0..1] -> 255,0,0 in 8-bit)
                  pctx.fillStyle = 'rgb(255,0,0)';
                  pctx.fillRect(0,0,padW,padH);
                  // Center the original image on the padded canvas
                  const dx = Math.floor((padW - srcW) / 2);
                  const dy = Math.floor((padH - srcH) / 2);
                  pctx.drawImage(imageSource, dx, dy, srcW, srcH);
                  imageSource = padded;
                }
            }
            originalImageDimensions = { w: imageSource.width, h: imageSource.height };
            calculateAndStoreMinPixelValue(imageSource);
            if (typeof calculateAndStoreMaxPixelValue === 'function') {
                try { calculateAndStoreMaxPixelValue(imageSource); } catch(_){}
            }
            canvas.style.visibility = 'hidden';
            // Update canvas dimensions AFTER texture is set to avoid showing old texture in new dimensions
            canvas.width = imageSource.width; canvas.height = imageSource.height;
            // Update aspect button labels based on canvas orientation
            updateAspectButtonLabels();
            // Avoid allocating a full set of float FBOs at full resolution when we'll render tiled
            if (Math.max(canvas.width, canvas.height) <= MAX_SAFE_FBO_RES) {
              resizeFBOs(canvas.width, canvas.height);
            } else {
              // Ensure any previous full-res buffers are released
              fbos = (typeof cleanupFBOs === 'function') ? cleanupFBOs(fbos) : {};
            }
            if (imageTexture) gl.deleteTexture(imageTexture);
            if (originalSrgbTexture) gl.deleteTexture(originalSrgbTexture);
            if (postMtfSrgbTexture) gl.deleteTexture(postMtfSrgbTexture);
            if (rawImageTexture) gl.deleteTexture(rawImageTexture);
            if (rawSrgbTexture) gl.deleteTexture(rawSrgbTexture);
            if (chromaProcessedTexture) { gl.deleteTexture(chromaProcessedTexture); chromaProcessedTexture = null; }
            // Keep an untouched copy of the loaded image so chroma pre-bake can be re-run on param changes
            rawImageTexture = createTexture(imageSource, false);
            rawSrgbTexture = createTexture(imageSource, false); // Store original sRGB (pre-bake source)
            
            // IMMEDIATELY set the new texture to avoid showing old image in new dimensions
            // Set a temporary simple texture first before processing
            imageTexture = rawImageTexture;
            originalSrgbTexture = rawSrgbTexture;
            
            // Pre-bake chromatic aberration (or bypass when samples=0)
            rebuildChromaPrebake();
            const newFit = calculateFitScale();
            fitScale = newFit;
            if (preserveViewOnNextLoad && prevFitScale) {
                const zoomFactor = prevFitScale > 0 ? (prevScale / prevFitScale) : 1.0;
                const newScale = zoomFactor * fitScale;
                const ratio = newScale / (prevScale || 1.0);
                scale = newScale;
                offsetX = prevOffsetX * ratio;
                offsetY = prevOffsetY * ratio;
                updateTransform(false);
                preserveViewOnNextLoad = false;
            } else {
                // No animation on initial fit to avoid flash
                scale = fitScale;
                offsetX = 0;
                offsetY = 0;
                updateTransform(false);
            }
            calculateOverscanScales();
            randomizeDust();
            updateSliderLabels();
            updatePanelHeight();
            
            // Ensure the new image is fully rendered before showing it
            render();
            
            // Trigger fade-in reliably on the next paint
            if (!suppressImageFade) {
                requestAnimationFrame(() => {
                    void canvas.offsetWidth;
                    requestAnimationFrame(() => {
                        canvas.style.visibility = 'visible';
                        canvas.style.opacity = '1';
                        finishImageLoadTransition();
                    });
                });
            } else {
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                finishImageLoadTransition();
            }
            // Auto-reset suppression flag for future loads
            suppressImageFade = false;
        }

        function handleFileSelect(event) { if(!event.target.files.length) return; originalFileBlob = event.target.files[0]; suppressImageFade = false; loadImageAndResize(originalFileBlob); }
        async function loadFromCameraRoll() {
            if (typeof Capacitor === 'undefined' || !Capacitor.isNativePlatform()) { uploadImageInput.click(); return; }
            try {
                const photo = await Capacitor.Plugins.Camera.getPhoto({ quality: 100, allowEditing: false, resultType: 'uri', source: 'PHOTOS', correctOrientation: true });
                const response = await fetch(Capacitor.convertFileSrc(photo.webPath));
                originalFileBlob = await response.blob();
                suppressImageFade = false;
                loadImageAndResize(originalFileBlob);
            } catch (e) { console.error('Camera roll error:', e); if (!e.message?.toLowerCase().includes('cancelled')) alert(`Could not load image: ${e.message}`); }
        }
        function loadGrainFromURL(url) { const img = new Image(); img.onload = () => { if (grainTexture) gl.deleteTexture(grainTexture); grainDimensions = { w: img.naturalWidth, h: img.naturalHeight }; grainTexture = createTexture(img, true); if(imageTexture) render(); }; img.src = url; }
        function loadDustFromURL(url) { const img = new Image(); img.onload = () => { if (dustTexture) gl.deleteTexture(dustTexture); dustTexture = createTexture(img, true); if(imageTexture) render(); }; img.src = url; }
        function loadBorderFromURL(url) { 
            const img = new Image(); 
            img.onload = () => { 
                if (borderTexture) gl.deleteTexture(borderTexture); 
                borderTexture = createTexture(img, false, true); 
                // Store the original border texture for blur operations
                if (originalBorderTexture) gl.deleteTexture(originalBorderTexture);
                originalBorderTexture = borderTexture;
                // Apply blur if in any special border mode and blur is enabled
                const isSpecialBorderEngine = ['8mm', '16mm', '35mm-178', '35mm-240', '35mm-133'].includes(window.__borderEngine);
                if (isSpecialBorderEngine && borderBlurSlider && parseFloat(borderBlurSlider.value) > 0) {
                    applyBorderBlur();
                }
                if(imageTexture) render(); 
            }; 
            img.src = url; 
        }

function applyBorderBlur() {
    if (!originalBorderTexture || !borderBlurSlider) return;

    const blurRadius = parseFloat(borderBlurSlider.value);
    const isSpecialBorderEngine = ['8mm', '16mm', '35mm-178', '35mm-240', '35mm-133'].includes(window.__borderEngine);
    
    // Skip if we're not in a border engine mode that supports blur
    if (!isSpecialBorderEngine) return;

    // Keep a reference to the old texture, but DO NOT delete it yet.
    const oldBlurredTexture = (borderTexture && borderTexture !== originalBorderTexture) ? borderTexture : null;

    // Handle the zero-blur case.
    if (blurRadius <= 0) {
        borderTexture = originalBorderTexture; // Point back to the clean, original texture.
        // Now that we're no longer using the old blurred texture, it's safe to delete it.
        if (oldBlurredTexture) {
            gl.deleteTexture(oldBlurredTexture);
        }
        if (imageTexture) render(); // Re-render with the clean border.
        return;
    }

    // --- Perform the blur operation ---
    const borderSize = 3840;
    const borderHeight = 2160;

    if (!borderBlurFBO || borderBlurFBO.width !== borderSize) {
        if (borderBlurFBO) cleanupFBOs({fbo: borderBlurFBO});
        borderBlurFBO = createFBO(borderSize, borderHeight, false);
    }
    if (!borderBlurPingPongFBO || borderBlurPingPongFBO.width !== borderSize) {
        if (borderBlurPingPongFBO) cleanupFBOs({fbo: borderBlurPingPongFBO});
        borderBlurPingPongFBO = createFBO(borderSize, borderHeight, false);
    }

    const fullRect = { x: 0, y: 0, w: borderSize, h: borderHeight };
    const resolution = [borderSize, borderHeight];
    const prevViewport = gl.getParameter(gl.VIEWPORT);
    gl.viewport(0, 0, borderSize, borderHeight);

    // Horizontal pass (always reads from the clean original).
    gl.bindFramebuffer(gl.FRAMEBUFFER, borderBlurPingPongFBO.fbo);
    drawQuadWithRegions(progs.separableBlur, { 
        u_image: originalBorderTexture,
        u_texelSize: [1 / borderSize, 1 / borderHeight], 
        u_blurRadius: blurRadius, 
        u_direction: [1, 0] 
    }, fullRect, fullRect, resolution, resolution);
    
    // Vertical pass. This writes the final, correctly blurred result into borderBlurFBO.
    gl.bindFramebuffer(gl.FRAMEBUFFER, borderBlurFBO.fbo);
    drawQuadWithRegions(progs.separableBlur, { 
        u_image: borderBlurPingPongFBO.texture, 
        u_texelSize: [1 / borderSize, 1 / borderHeight], 
        u_blurRadius: blurRadius, 
        u_direction: [0, 1] 
    }, fullRect, fullRect, resolution, resolution);
    
    // --- Resource Management ---

    // 1. Assign the NEWLY created blurred texture to be the active one.
    borderTexture = borderBlurFBO.texture;

    // 2. NOW that the new texture is assigned and the old one is no longer needed, DELETE the old one.
    if (oldBlurredTexture) {
        gl.deleteTexture(oldBlurredTexture);
    }

    // 3. Detach the new texture from the FBO so it doesn't get accidentally modified or deleted later.
    const newTexForFBO = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, newTexForFBO);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, borderSize, borderHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.bindFramebuffer(gl.FRAMEBUFFER, borderBlurFBO.fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, newTexForFBO, 0);
    borderBlurFBO.texture = newTexForFBO;

    // --- Final Render ---
    gl.viewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);
    if (imageTexture) render(); // Re-render with the new blurred border.
}

        function loadSprocketFromURL(url) { const img = new Image(); img.onload = () => { if (sprocketTexture) gl.deleteTexture(sprocketTexture); sprocketTexture = createTexture(img, false, true); if(imageTexture) render(); }; img.src = url; }
        function loadMaskATexture(url) { const img = new Image(); img.onload = () => { if (maskATexture) gl.deleteTexture(maskATexture); maskATexture = createTexture(img, false); gl.bindTexture(gl.TEXTURE_2D, maskATexture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); if(imageTexture) render(); }; img.onerror = () => { console.error("Failed to load mask texture from URL:", url); }; img.src = url; }
        function loadMaskBTexture(url) { const img = new Image(); img.onload = () => { if (maskBTexture) gl.deleteTexture(maskBTexture); maskBTexture = createTexture(img, false); gl.bindTexture(gl.TEXTURE_2D, maskBTexture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); if(imageTexture) render(); }; img.onerror = () => { console.error("Failed to load mask texture from URL:", url); }; img.src = url; }
        function loadMaskCTexture(url) { const img = new Image(); img.onload = () => { if (maskCTexture) gl.deleteTexture(maskCTexture); maskCTexture = createTexture(img, false); gl.bindTexture(gl.TEXTURE_2D, maskCTexture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); if(imageTexture) render(); }; img.onerror = () => { console.error("Failed to load mask texture from URL:", url); }; img.src = url; }

        // Dynamically derive panels/buttons so new submenus are auto-included
        let allPanels = [];
        let allPanelButtons = [];
        function refreshPanelLists() {
            allPanels = Array.from(document.querySelectorAll('.slider-panel'));
            allPanelButtons = allPanels.map(p => document.getElementById((p.id || '').replace('Panel','Btn'))).filter(Boolean);
        }
        refreshPanelLists();
        function hideAllPanels() {
            refreshPanelLists();
            // Remove active state from panels/buttons
            allPanels.forEach(p=>p.classList.remove('active'));
            allPanelButtons.forEach(b=>b.classList.remove('active'));
            // Reset stored padding; no panel remains open
            lastPanelPadding = 0;
            // Animate transform gently to the new clamped position (no panel padding)
            updateTransform(true);
        }
        function showPanel(panel, btn){
            refreshPanelLists();
            const isAlreadyActive = btn.classList.contains('active');
            if (isAlreadyActive) {
                // Toggle off: close panels and animate to bottom clamp
                hideAllPanels();
                return;
            }
            // Switch without passing through a "no active panel" state to avoid bottom reset
            // Preserve previous panel height during the switch
            const prev = document.querySelector('.slider-panel.active');
            if (prev) {
                try {
                    const ph = prev.getBoundingClientRect().height || 0;
                    if (ph > 0) lastPanelPadding = ph;
                } catch (_) {}
            }
            allPanels.forEach(p=>p.classList.remove('active'));
            allPanelButtons.forEach(b=>b.classList.remove('active'));
            panel.classList.add('active');
            btn.classList.add('active');
            // Recompute bounds without animation (avoid snapping to bottom on menu switch)
            updateTransform(false);
            // After panel expands, update stored padding and clamp again smoothly
            setTimeout(() => {
                refreshPanelLists();
                try {
                    const nh = panel.getBoundingClientRect().height || 0;
                    if (nh > 0) lastPanelPadding = nh;
                } catch(_) {}
                updateTransform(false);
            }, 350);
        }
        function setAppHeight() { document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`); }
        function updateTopbarHeight(){ const tb=document.getElementById('topToolbar'); if (tb) document.documentElement.style.setProperty('--topbar-height', `${tb.offsetHeight}px`); }
        function updateControlsHeight() { if (mainControls) bottomUI.style.setProperty('--controls-height', `${mainControls.offsetHeight}px`); }
        function updatePanelHeight() { if (window.innerWidth <= 768) { const item = document.querySelector('.slider-item'); if (item) { const style = window.getComputedStyle(item); bottomUI.style.setProperty('--panel-max-height', `${(item.offsetHeight + parseFloat(style.marginBottom)) * 2.5}px`); } } else { bottomUI.style.removeProperty('--panel-max-height'); } }
        function handleDoubleClick() { if (!imageTexture) return; if (Math.abs(scale - fitScale) < 0.01) zoomTo100(); else fitToView(); }
        function randomizeDust() {
            loadDustFromURL(dustSources[Math.floor(Math.random() * dustSources.length)]);
            dustMoveXSlider.value = Math.random() * 3 - 1; dustMoveYSlider.value = Math.random() * 3 - 1; dustRotateSlider.value = Math.random() * 2;
            updateSliderLabels(); if (imageTexture) render();
        }

        function formatK(px) { return `${Math.round(parseInt(px,10)/1024)}k`; }
        function formatPx(px) { const v = parseInt(px,10)||0; return v >= ORIGINAL_SLIDER_VALUE ? 'Original' : `${v} px`; }
        function clampRes(px) {
            let v = Math.round(parseInt(px,10)||0);
            if (v >= ORIGINAL_SLIDER_VALUE) return ORIGINAL_SLIDER_VALUE;
            return Math.max(1024, Math.min(4096, v));
        }
        function snapRes(px) {
            let v = Math.round(parseInt(px,10)||0);
            if (v >= ORIGINAL_SLIDER_VALUE) return ORIGINAL_SLIDER_VALUE;
            v = Math.max(1024, Math.min(4096, v));
            return Math.round(v/1024) * 1024;
        }
        function isOriginalSelectedOn(sliderEl) { return !!sliderEl && parseInt(sliderEl.value,10) >= ORIGINAL_SLIDER_VALUE; }

        function initializeDraggableSliders() {
            document.querySelectorAll('.slider-item, .gauge-slider-container').forEach(item => {
                const slider = item.querySelector('input[type="range"]');
                if (!slider) return;
                let isDragging = false, initialClientX = 0, initialValue = 0, throttleTimeout = null;
                let initialClientY = 0, dragDirection = null, shouldZoomToFit = false;
                const handleMove = (e) => {
                    if (!isDragging) return;
                    const isLiveFullRenderSlider = LIVE_FULL_RENDER_SLIDER_IDS.has(slider.id);
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    if (dragDirection === null) { 
                        const deltaX = Math.abs(clientX - initialClientX); 
                        const deltaY = Math.abs(clientY - initialClientY); 
                        if (deltaX > 5 || deltaY > 5) { 
                            dragDirection = deltaX > deltaY ? 'horizontal' : 'vertical'; 
                            
                            if (dragDirection === 'horizontal') {
                                // This is a horizontal drag - enable preview mode for border controls
                                const cheatAspectProxyEnabled = cheatAspectProxyToggle?.checked || false;
                                const isBorderControl = (slider.id === 'overscan' || slider.id === 'framing' || slider.id === 'borderScale' || slider.id === 'imageScale' || slider.id === 'adjacentFrameDistance' || slider.id === 'borderBlur' || (cheatAspectProxyEnabled && (slider.id === 'cheatAspectX' || slider.id === 'cheatAspectY')) || slider.id === 'sprocketScale' || slider.id === 'sprocket16mmScale' || slider.id === 'sprocket35mm178Scale' || slider.id === 'sprocket35mm178Translation' || slider.id === 'sprocket35mm240Scale' || slider.id === 'sprocket35mm240Translation' || slider.id === 'sprocket35mm133Scale' || slider.id === 'sprocket35mm133Translation');
                                if (isBorderControl) {
                                    // Enter interactive preview without changing working resolution
                                    isSimplePreviewing = true;
                                }
                                
                                // Trigger zoom-to-fit only when horizontal movement is detected
                                if (shouldZoomToFit) {
                                    if (imageTexture && scale > fitScale + 0.001) { fitToView(); }
                                    shouldZoomToFit = false; // Only trigger once
                                }
                            }
                        } 
                    }
                    if (dragDirection === 'vertical') { 
                        // If this is vertical scrolling over a preview slider, reset preview mode
                        const cheatAspectProxyEnabled = cheatAspectProxyToggle?.checked || false;
                        const isPreviewSlider = (slider.id === 'overscan' || slider.id === 'framing' || slider.id === 'borderScale' || slider.id === 'imageScale' || slider.id === 'adjacentFrameDistance' || slider.id === 'borderBlur' || (cheatAspectProxyEnabled && (slider.id === 'cheatAspectX' || slider.id === 'cheatAspectY')) || slider.id === 'sprocketScale' || slider.id === 'sprocket16mmScale' || slider.id === 'sprocket35mm178Scale' || slider.id === 'sprocket35mm178Translation' || slider.id === 'sprocket35mm240Scale' || slider.id === 'sprocket35mm240Translation' || slider.id === 'sprocket35mm133Scale' || slider.id === 'sprocket35mm133Translation');
                        if (isPreviewSlider && isSimplePreviewing) {
                            isSimplePreviewing = false;
                            render(); // Restore full render
                        }
                        return; 
                    }
                    e.preventDefault();
                    const rect = slider.getBoundingClientRect();
                    const valueRange = parseFloat(slider.max) - parseFloat(slider.min);
                    const effectiveWidth = rect.width * 0.65;
                    const valuePerPixel = valueRange / effectiveWidth;
                    const deltaX = clientX - initialClientX;
                    let newValue = initialValue + (deltaX * valuePerPixel);
                    const min=parseFloat(slider.min), max=parseFloat(slider.max), step=parseFloat(slider.step);
                    newValue = Math.round(Math.max(min, Math.min(max, newValue)) / step) * step;

                    if (slider.value != newValue) {
                        slider.value = newValue;
                        if (slider.id === 'overscan') {
                            calculateOverscanScales();
                        } else if (slider.id === 'maxResSlider') {
                            slider.value = snapRes(slider.value);
                            document.getElementById('maxResVal').textContent = formatPx(slider.value);
                        } else if (slider.id === 'exportResSlider') {
                            slider.value = snapRes(slider.value);
                            document.getElementById('exportResVal').textContent = formatPx(slider.value);
                        } else if (slider.id === 'backgroundSlider') {
                            updateBackgroundFromSlider();
                        } else {
                            updateSliderLabels();
                        }
                    }

                    if (!throttleTimeout) {
                        // Fast preview while dragging overscan/border/image scale
                        const cheatAspectProxyEnabled = cheatAspectProxyToggle?.checked || false;
                        if (slider.id === 'overscan' || slider.id === 'framing' || slider.id === 'borderScale' || slider.id === 'imageScale' || slider.id === 'adjacentFrameDistance' || slider.id === 'borderBlur' || (cheatAspectProxyEnabled && (slider.id === 'cheatAspectX' || slider.id === 'cheatAspectY')) || slider.id === 'sprocketScale' || slider.id === 'sprocket16mmScale' || slider.id === 'sprocket35mmCineScale' || slider.id === 'sprocket35mmCineTranslation') {
                            isSimplePreviewing = true;
                            if (slider.id === 'borderBlur') {
                                const isSpecialBorderEngine = ['8mm', '16mm', '35mm-178', '35mm-240', '35mm-133'].includes(window.__borderEngine);
                                if (isSpecialBorderEngine && originalBorderTexture) {
                                    // Live apply blur while dragging for all special border engine modes
                                applyBorderBlur();
                                }
                            } else if (slider.id === 'cheatAspectY' || slider.id === 'cheatAspectX') {
                                // For Y scaling, we need to recalculate overscan as it affects ZoneB dimensions
                                calculateOverscanScales();
                                
                                // Update adjacent frame distance when either cheat aspect changes
                                if (adjacentFrameDistanceValLabel) {
                                    // Always calculate from the original base value to avoid compounding
                                    const effectiveValue = Math.round(originalAdjacentFrameDistance);
                                    adjacentFrameDistanceValLabel.textContent = effectiveValue.toString();
                                    
                                    // CRITICAL: Update the actual slider value to match the effective display value
                                    // This ensures the slider starts from the correct position when manually dragged
                                    adjacentFrameDistanceSlider.value = effectiveValue;
                                }
                                
                                render();
                            } else {
                                render();
                            }
                        } else if (slider.id === 'diffusionThreshold') {
                            updateSliderLabels();
                            if (diffusionThresholdPreviewToggle && diffusionThresholdPreviewToggle.checked) {
                                thresholdPreviewActive = true;
                                suppressRenders = true;
                                renderDiffusionThresholdPreview();
                            }
                        } else if (slider.id === 'diffusionThreshold2') {
                            updateSliderLabels();
                            if (diffusionThresholdPreview2Toggle && diffusionThresholdPreview2Toggle.checked) {
                                thresholdPreviewActive = true;
                                suppressRenders = true;
                                renderDiffusionThreshold2Preview();
                            }
                        } else if (slider.id === 'cheatAspectX' || slider.id === 'cheatAspectY') {
                            // Cheat aspect sliders not in proxy mode - render live with full pipeline
                            calculateOverscanScales();
                            if (imageTexture) render();
                        } else if (slider.id === 'backgroundSlider') {
                            updateBackgroundFromSlider();
                        } else if (slider.id === 'framePadding') {
                            // Frame padding should render live without preview mode
                            if (imageTexture) render();
                        } else if (slider.id !== 'maxResSlider') {
                            // Invalidate diffusion cache for diffusion-related sliders
                            if (slider.id.includes('diffusion') || slider.id === 'halationIntensity' || slider.id === 'mtfMask' || slider.id === 'mtfSoftness' || slider.id === 'blackpoint' || slider.id === 'whitepoint' || slider.id === 'thresholdGamma' || slider.id === 'coreBlur' || slider.id === 'midBlur' || slider.id === 'outerBlur' || slider.id === 'midBlurGain' || slider.id === 'outerBlurGain' || slider.id.includes('tintR2') || slider.id.includes('tintG2') || slider.id.includes('tintB2')) {
                                invalidateDiffusionBuffer();
                            }
                            if (isLiveFullRenderSlider) {
                                triggerLiveFullRender(slider.id);
                            } else if (imageTexture) {
                                render();
                            }
                        }
                        throttleTimeout = setTimeout(() => { throttleTimeout = null; }, 80);
                    }
                };
                const stopDrag = () => {
                    if (!isDragging) return;
                    const isLiveFullRenderSlider = LIVE_FULL_RENDER_SLIDER_IDS.has(slider.id);
                    isDragging = false;
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('mouseup', stopDrag);
                    window.removeEventListener('touchend', stopDrag);
                    
                    // Handle vertical drag end - ensure preview mode is reset
                    if (dragDirection === 'vertical') {
                        const cheatAspectProxyEnabled = cheatAspectProxyToggle?.checked || false;
                            const isPreviewSlider = (slider.id === 'overscan' || slider.id === 'framing' || slider.id === 'borderScale' || slider.id === 'imageScale' || slider.id === 'adjacentFrameDistance' || slider.id === 'borderBlur' || (cheatAspectProxyEnabled && (slider.id === 'cheatAspectX' || slider.id === 'cheatAspectY')) || slider.id === 'sprocketScale' || slider.id === 'sprocket16mmScale' || slider.id === 'sprocket35mm178Scale' || slider.id === 'sprocket35mm178Translation' || slider.id === 'sprocket35mm240Scale' || slider.id === 'sprocket35mm240Translation' || slider.id === 'sprocket35mm133Scale' || slider.id === 'sprocket35mm133Translation');
                        if (isPreviewSlider && isSimplePreviewing) {
                            isSimplePreviewing = false;
                            render(); // Restore full render
                        }
                        return; // Don't run horizontal drag cleanup
                    }
                    
                    if (dragDirection === 'horizontal') {
                        clearTimeout(throttleTimeout);
                        throttleTimeout = null;
                        // End of fast preview, re-enable full pipeline
                        const cheatAspectProxyEnabled = cheatAspectProxyToggle?.checked || false;
                        const wasPreviewSlider = (slider.id === 'overscan' || slider.id === 'framing' || slider.id === 'borderScale' || slider.id === 'imageScale' || slider.id === 'adjacentFrameDistance' || slider.id === 'borderBlur' || (cheatAspectProxyEnabled && (slider.id === 'cheatAspectX' || slider.id === 'cheatAspectY')) || slider.id === 'sprocketScale' || slider.id === 'sprocket16mmScale' || slider.id === 'sprocket35mmCineScale' || slider.id === 'sprocket35mmCineTranslation');
                        if (slider.id === 'overscan') {
                            calculateOverscanScales();
                        } else if (slider.id === 'borderBlur') {
                            // Ensure final full-res render path reflects the new blur
                            const isSpecialBorderEngine = ['8mm', '16mm', '35mm-178', '35mm-240', '35mm-133', '35mm-add'].includes(window.__borderEngine);
                            if (isSpecialBorderEngine && originalBorderTexture) {
                                applyBorderBlur(); // <<< Final call to apply blur correctly
                            }
                        } else if (slider.id === 'diffusionThreshold' || slider.id === 'diffusionThreshold2') {
                            thresholdPreviewActive = false;
                            suppressRenders = false;
                            invalidateDiffusionBuffer();
                            render();
                        } else if (slider.id === 'maxResSlider') {
                            if (originalFileBlob) { 
                                // Only trigger processing overlay for resolutions above 2048px
                                const currentRes = parseInt(slider.value, 10);
                                if (currentRes <= 2048) {
                                    suppressImageFade = true;
                                }
                                loadImageAndResize(originalFileBlob); 
                            }
                        }
                        if (wasPreviewSlider) {
                            // Exit interactive preview and run full pipeline
                            isSimplePreviewing = false;
                            render();
                        } else if (slider.id === 'framePadding') {
                            // Frame padding should render live without preview mode
                            if (imageTexture) render();
                        } else {
                            // Invalidate diffusion cache for diffusion-related sliders at end of drag
                            if (slider.id.includes('diffusion') || slider.id === 'halationIntensity' || slider.id === 'mtfMask' || slider.id === 'mtfSoftness' || slider.id === 'blackpoint' || slider.id === 'whitepoint' || slider.id === 'thresholdGamma' || slider.id === 'coreBlur' || slider.id === 'midBlur' || slider.id === 'outerBlur' || slider.id === 'midBlurGain' || slider.id === 'outerBlurGain' || slider.id.includes('tintR2') || slider.id.includes('tintG2') || slider.id.includes('tintB2')) {
                                invalidateDiffusionBuffer();
                            }
                            if (slider.id !== 'maxResSlider') {
                                if (isLiveFullRenderSlider) {
                                    triggerLiveFullRender(slider.id, true);
                                } else if (imageTexture) {
                                    render();
                                }
                            }
                        }
                    }
                };
                const startDrag = (e) => {
                    // If this control lives inside settings menu, require it to be visible
                    const insideSettings = !!item.closest('.settings-menu');
                    if (insideSettings && !settingsMenuOverlay.classList.contains('visible')) return;
                    isDragging = true;
                    dragDirection = null;
                    shouldZoomToFit = false;
                    const touch = e.touches ? e.touches[0] : e;
                    initialClientX = touch.clientX;
                    initialClientY = touch.clientY;
                    initialValue = parseFloat(slider.value);
                    
                                            const cheatAspectProxyEnabled = cheatAspectProxyToggle?.checked || false;
                    const isBorderControl = (slider.id === 'overscan' || slider.id === 'framing' || slider.id === 'borderScale' || slider.id === 'imageScale' || slider.id === 'adjacentFrameDistance' || slider.id === 'borderBlur' || (cheatAspectProxyEnabled && (slider.id === 'cheatAspectX' || slider.id === 'cheatAspectY')) || slider.id === 'sprocketScale' || slider.id === 'sprocket16mmScale' || slider.id === 'sprocket35mmCineScale' || slider.id === 'sprocket35mmCineTranslation');
                    if (isBorderControl) {
                        // <<< FIX: Only trigger zoom-to-fit for the main scaling sliders after horizontal movement is detected.
                        if (slider.id === 'overscan' || slider.id === 'borderScale' || slider.id === 'imageScale') {
                            shouldZoomToFit = true; // Set flag, will trigger on horizontal movement
                        }
                        
                        // NOTE: isSimplePreviewing will be set in handleMove when horizontal drag is detected
                        // Don't set it here immediately, as the user might be trying to scroll vertically
                    }
                    window.addEventListener('mousemove', handleMove);
                    window.addEventListener('touchmove', handleMove, { passive: false });
                    window.addEventListener('mouseup', stopDrag);
                    window.addEventListener('touchend', stopDrag);
                };
                item.addEventListener('mousedown', startDrag);
                item.addEventListener('touchstart', startDrag, { passive: false });
            });
        }
        imageWrapper.addEventListener('mousedown',handleMouseDown); window.addEventListener('mousemove',handleMouseMove); window.addEventListener('mouseup',handleMouseUp); viewport.addEventListener('wheel',handleWheel,{passive:false});
        viewport.addEventListener('click', (e) => {
            refreshPanelLists();
            if (allPanels.some(p => p.classList.contains('active')) && !bottomUI.contains(e.target) && !e.target.closest('.main-btn')) hideAllPanels();
        });

        // Canvas top menu interactions
        if (canvasMenuBtn && canvasPanel) {
            canvasMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isActive = canvasPanel.classList.contains('active');
                if (isActive) {
                    canvasPanel.classList.remove('active');
                    canvasMenuBtn.classList.remove('active');
                } else {
                    // Close any open bottom panels before opening canvas menu
                    hideAllPanels();
                    canvasPanel.classList.add('active');
                    canvasMenuBtn.classList.add('active');
                    updateTopbarHeight();
                }
            });
            // Close when clicking away
            document.addEventListener('click', (e) => {
                if (!canvasPanel.classList.contains('active')) return;
                if (topToolbar.contains(e.target) || canvasPanel.contains(e.target)) return;
                canvasPanel.classList.remove('active');
                canvasMenuBtn.classList.remove('active');
            });
        }

        // Canvas shape toggle and aspect buttons
        const canvasShapeToggle = document.getElementById('canvasShapeToggle');
        const canvasAspectButtons = document.getElementById('canvasAspectButtons');
        function setAspectButtonsEnabled(enabled) {
            if (!canvasAspectButtons) return;
            canvasAspectButtons.querySelectorAll('.engine-btn').forEach(b => {
                if (enabled) b.classList.remove('disabled'); else b.classList.add('disabled');
            });
        }
        function currentShapeIsBorder() {
            const sel = canvasShapeToggle && canvasShapeToggle.querySelector('.engine-btn.selected');
            return !!sel && sel.dataset.shape === 'border';
        }
        if (canvasShapeToggle) {
            canvasShapeToggle.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const prevWasBorder = currentShapeIsBorder();
                canvasShapeToggle.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                setAspectButtonsEnabled(btn.dataset.shape === 'border');
                 // When entering border mode, default aspect selection is 16:9
                 if (btn.dataset.shape === 'border') {
                     window.__docAspectMode = '16:9';
                     const aspectBtns = document.getElementById('canvasAspectButtons');
                     if (aspectBtns) {
                         aspectBtns.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                         const def = aspectBtns.querySelector('[data-aspect="16:9"]');
                         if (def) def.classList.add('selected');
                     }
                 }
                 // Show loading overlay immediately for mode switch transition
                 showImageLoadingOverlay(true);
                 // Reload current image to apply/remove border document padding (16:9 or 9:16) immediately
                 try {
                   if (originalFileBlob) {
                     // Reuse existing file blob; loadImageAndResize will respect current mode
                     // Don't suppress fade for mode switches - we want to see the transition
                     suppressImageFade = false;
                     loadImageAndResize(originalFileBlob);
                   } else if (rawSrgbTexture || rawImageTexture) {
                    // Fallback: draw current GL texture back to a canvas and reload
                    const tmp = document.createElement('canvas');
                    const w = canvas.width; const h = canvas.height;
                    tmp.width = w; tmp.height = h;
                    const ctx2d = tmp.getContext('2d');
                    // Best-effort: use existing <canvas> as a source via toDataURL
                    // Note: reading back from WebGL is complex; this fallback uses the visible canvas bitmap
                    try {
                      const dataUrl = canvas.toDataURL('image/png');
                      const img = new Image();
                      img.onload = () => { ctx2d.drawImage(img, 0, 0); loadMainImage(tmp); };
                      img.src = dataUrl;
                    } catch (_) { /* noop */ }
                  }
                } catch (_) { /* ignore reload errors */ }
            });
        // initialize disabled state
        setAspectButtonsEnabled(currentShapeIsBorder());
        // initialize aspect button labels
        updateAspectButtonLabels();
        }
        // (removed placeholder listener)

        // Function to update aspect button labels based on canvas orientation
        function updateAspectButtonLabels() {
            if (!canvasAspectButtons) return;
            const isPortrait = canvas.height > canvas.width;
            canvasAspectButtons.querySelectorAll('.engine-btn').forEach(btn => {
                const aspect = btn.dataset.aspect;
                if (!aspect) return;
                
                // Update button text based on orientation
                if (aspect === '1:1') {
                    btn.textContent = '1:1';
                } else if (isPortrait) {
                    // Flip the aspect ratio for portrait mode
                    const parts = aspect.split(':');
                    btn.textContent = `${parts[1]}:${parts[0]}`;
                } else {
                    // Use original aspect for landscape mode
                    btn.textContent = aspect;
                }
            });
        }

        // Canvas aspect buttons: 16:9 (default), 5:3, 3:2, 7:5, 4:3, 5:4, 1:1
        if (canvasAspectButtons) {
            canvasAspectButtons.addEventListener('click', (e) => {
                const b = e.target.closest('.engine-btn');
                if (!b || b.classList.contains('disabled')) return;
                const aspect = b.dataset.aspect;
                if (!aspect) return;

                // Update selection UI
                canvasAspectButtons.querySelectorAll('.engine-btn').forEach(x => x.classList.remove('selected'));
                b.classList.add('selected');

                // Compute start crop (normalized) before changing aspect
                const startCropNorm = __rectToNorm(getCropRectForDims(canvas.width, canvas.height), canvas.width, canvas.height);

                // Apply new aspect mode
                window.__docAspectMode = aspect;

                // Prepare zoom-to-fit transform animation if currently at fit
                const wasAtFitScale = Math.abs(scale - fitScale) < 0.001;
                fitScale = calculateFitScale();
                if (wasAtFitScale) {
                    // Trigger the same transform animation speed as zoom-to-fit
                    fitToView();
                }

                // Start proxy/preview for the transition
                isSimplePreviewing = true;

                // Compute end crop (normalized) after aspect change
                const endCropNorm = __rectToNorm(getCropRectForDims(canvas.width, canvas.height), canvas.width, canvas.height);
                __aspectCropAnim = {
                    active: true,
                    start: startCropNorm,
                    end: endCropNorm,
                    t0: performance.now(),
                    dur: 300
                };

                // Drive the animation and render preview frames
                const step = () => {
                    if (!__aspectCropAnim || !__aspectCropAnim.active) return;
                    render();
                    const now = performance.now();
                    const done = (now - __aspectCropAnim.t0) >= __aspectCropAnim.dur;
                    if (!done) {
                        requestAnimationFrame(step);
                    } else {
                        __aspectCropAnim.active = false;
                        isSimplePreviewing = false;
                        render(); // final full render
                    }
                };
                requestAnimationFrame(step);
            });
        }
        imageWrapper.addEventListener('dblclick', handleDoubleClick);
        let lastTap = 0; imageWrapper.addEventListener('touchend', (e) => { if (isDragging || e.touches.length > 0) return; const now = Date.now(); if(now - lastTap < 300){ handleDoubleClick(); e.preventDefault(); } lastTap = now; });
        let touchStartDist=0, touchStartScale=1;
        imageWrapper.addEventListener('touchstart', (e) => { 
            // Check if touch is over a popup menu or slider panel
            if (e.touches.length > 0) {
                const target = e.touches[0].target;
                const blockerOpen = document.querySelector('.settings-menu-overlay.visible, .presets-menu-overlay.visible, .film-stock-menu-overlay.visible, .modal-overlay.visible');
                if (blockerOpen) return;
                if (target && (target.closest('.slider-panel') || target.closest('.settings-menu') || target.closest('.film-stock-menu') || target.closest('.presets-menu') || target.closest('.modal-overlay'))) {
                    return; // Don't handle image pan/hold when touching menus
                }
            }
            
            try { if (document.activeElement) document.activeElement.blur(); } catch(_){}
            if(e.touches.length===1) {
                handleMouseDown(e.touches[0]);
            } else if(e.touches.length===2) { 
                cancelHold(); 
                isDragging=false; 
                canvas.classList.remove('grabbing');
                const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; 
                touchStartDist=Math.sqrt(dx*dx+dy*dy); 
                touchStartScale=scale; 
            }
        });
        window.addEventListener('touchmove', (e) => { 
            const blockerOpen = document.querySelector('.settings-menu-overlay.visible, .presets-menu-overlay.visible, .film-stock-menu-overlay.visible, .modal-overlay.visible');
            if (blockerOpen) return;
            if(e.touches.length===1) {
                handleMouseMove(e.touches[0]);
            } else if(e.touches.length===2) { 
                cancelHold(); 
                e.preventDefault(); 
                const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY, dist=Math.sqrt(dx*dx+dy*dy); 
                const rect=viewport.getBoundingClientRect(), cX=(e.touches[0].clientX+e.touches[1].clientX)/2-rect.left, cY=(e.touches[0].clientY+e.touches[1].clientY)/2-rect.top; 
                if (touchStartDist > 0) setZoom(touchStartScale*(dist/touchStartDist), cX, cY, false);
            }
        });
        window.addEventListener('touchend', (e) => { if (e.touches.length === 0) handleMouseUp(); });
        const frameBtn = document.getElementById('frameBtn');
        if (frameBtn) frameBtn.addEventListener('click',()=> showPanel(borderPanel, borderBtn));
        returnMinBtn.addEventListener("click",()=>{ returnMinBtn.classList.toggle('active'); if (returnMinBtn.classList.contains('active')) { if (returnMaxBtn) returnMaxBtn.classList.remove('active'); if (returnMaxSourceBtn) returnMaxSourceBtn.classList.remove('active'); } render(); });
        if (returnMaxBtn) returnMaxBtn.addEventListener("click",()=>{ returnMaxBtn.classList.toggle('active'); if (returnMaxBtn.classList.contains('active')) { returnMinBtn.classList.remove('active'); if (returnMaxSourceBtn) returnMaxSourceBtn.classList.remove('active'); } render(); });
        if (returnMaxSourceBtn) returnMaxSourceBtn.addEventListener("click",()=>{ returnMaxSourceBtn.classList.toggle('active'); if (returnMaxSourceBtn.classList.contains('active')) { returnMinBtn.classList.remove('active'); if (returnMaxBtn) returnMaxBtn.classList.remove('active'); } render(); });
        uploadImageInput.addEventListener("change",handleFileSelect);
        grainStockSelect.addEventListener('change', (e) => { if (!grainSources[e.target.value]) return; loadGrainFromURL(grainSources[e.target.value]); render(); });
        sprocketStockSelect.addEventListener('change', (e) => { const url = sprocketSources[e.target.value]; if (url) loadSprocketFromURL(url); render(); });
        loadImageBtn.addEventListener('click', loadFromCameraRoll);
        halationBtn.addEventListener('click',()=>showPanel(halationPanel,halationBtn));
        if (opticsBtn) opticsBtn.addEventListener('click',()=>showPanel(opticsPanel,opticsBtn));
        textureBtn.addEventListener('click',()=>showPanel(texturePanel,textureBtn));
        dustBtn.addEventListener('click', ()=>showPanel(dustPanel, dustBtn));
        borderBtn.addEventListener('click', ()=>showPanel(borderPanel, borderBtn));
        randomizeDustBtn.addEventListener('click', randomizeDust);
[halationEnabledToggle, textureEnabledToggle, dustEnabledToggle, mtfLinearToggle].forEach(t => t.addEventListener('change', () => {
            if (t === halationEnabledToggle || t === mtfLinearToggle) {
                invalidateDiffusionBuffer();
            }
            render();
        }));
        if (whiteCompSlider) whiteCompSlider.addEventListener('input', () => { 
            updateSliderLabels(); 
            invalidateDiffusionBuffer(); 
            render(); 
        });
        if (whiteCompLimitSlider) whiteCompLimitSlider.addEventListener('input', () => { 
            updateSliderLabels(); 
            invalidateDiffusionBuffer(); 
            render(); 
        });
        
        // <<< FIX: UPDATED SLIDER EVENT LISTENERS
        if (borderBlurSlider) {
            borderBlurSlider.addEventListener('input', () => {
                updateSliderLabels();
                // Save the current value for this engine mode
                if (window.__borderEngine) {
                    borderBlurSettings[window.__borderEngine] = parseFloat(borderBlurSlider.value);
                }
                // Apply blur in real-time during dragging for all border engine modes
                const isSpecialBorderEngine = ['8mm', '16mm', '35mm-178', '35mm-240', '35mm-133'].includes(window.__borderEngine);
                if (isSpecialBorderEngine && originalBorderTexture) {
                    applyBorderBlur();
                }
            });
            borderBlurSlider.addEventListener('change', () => {
                // Save the current value for this engine mode
                if (window.__borderEngine) {
                    borderBlurSettings[window.__borderEngine] = parseFloat(borderBlurSlider.value);
                }
                applyBorderBlur();
            });
        }
        if (sprocketScaleSlider) {
            sprocketScaleSlider.addEventListener('input', () => {
                updateSliderLabels();
                render();
            });
            sprocketScaleSlider.addEventListener('change', () => {
                updateSliderLabels();
                render();
            });
        }
        // 16mm sprocket scale slider
        const sprocket16mmScaleSlider = document.getElementById('sprocket16mmScale');
        if (sprocket16mmScaleSlider) {
            sprocket16mmScaleSlider.addEventListener('input', () => {
                updateSliderLabels();
                render();
            });
            sprocket16mmScaleSlider.addEventListener('change', () => {
                updateSliderLabels();
                render();
            });
        }
        // 35mm cine sprocket scale and translation sliders
        const sprocket35mmCineScaleSlider = document.getElementById('sprocket35mmCineScale');
        if (sprocket35mmCineScaleSlider) {
            sprocket35mmCineScaleSlider.addEventListener('input', () => {
                updateSliderLabels();
                render();
            });
            sprocket35mmCineScaleSlider.addEventListener('change', () => {
                updateSliderLabels();
                render();
            });
        }
        const sprocket35mmCineTranslationSlider = document.getElementById('sprocket35mmCineTranslation');
        if (sprocket35mmCineTranslationSlider) {
            sprocket35mmCineTranslationSlider.addEventListener('input', () => {
                updateSliderLabels();
                render();
            });
            sprocket35mmCineTranslationSlider.addEventListener('change', () => {
                updateSliderLabels();
                render();
            });
        }
        overscanSlider.addEventListener('input', () => {
            calculateOverscanScales();
            
            // Hide/show framing slider based on overscan value
            const overscanValue = parseFloat(overscanSlider.value);
            if (overscanValue < 0.1) {
                framingSliderItem.style.display = 'none';
                framingSlider.value = '1.0';
                updateSliderLabels();
            } else {
                framingSliderItem.style.display = 'block';
            }
        });
        
        // Initial state check for framing slider visibility
        const initialOverscanValue = parseFloat(overscanSlider.value);
        if (initialOverscanValue < 0.1) {
            framingSliderItem.style.display = 'none';
            framingSlider.value = '1.0';
            updateSliderLabels();
        }
        
        // Adjacent frame distance slider event listeners
        if (adjacentFrameDistanceSlider) {
            adjacentFrameDistanceSlider.addEventListener('input', () => {
                // Update the original base value when user manually changes the slider
                const currentSliderValue = parseFloat(adjacentFrameDistanceSlider.value);
                // Store the raw slider value since shader handles cheat aspect scaling
                originalAdjacentFrameDistance = Math.round(currentSliderValue);
                
                updateSliderLabels();
                render();
            });
            adjacentFrameDistanceSlider.addEventListener('change', () => {
                // Update the original base value when user manually changes the slider
                const currentSliderValue = parseFloat(adjacentFrameDistanceSlider.value);
                // Store the raw slider value since shader handles cheat aspect scaling
                originalAdjacentFrameDistance = Math.round(currentSliderValue);
                
                updateSliderLabels();
                render();
            });
        }
        
        // Frame padding slider event listeners
        if (framePaddingSlider) {
            framePaddingSlider.addEventListener('input', () => {
                updateSliderLabels();
                render();
            });
            framePaddingSlider.addEventListener('change', () => {
                updateSliderLabels();
                render();
            });
        }
        
        framingSlider.addEventListener('input', () => {
            updateSliderLabels();
            render();
        });
        framingSlider.addEventListener('change', () => {
            updateSliderLabels();
            render();
        });
        const startPreview = () => isPreviewingBorder = true;
        [borderScaleSliderItem, overscanSliderItem, framingSliderItem, imageScaleSliderItem, document.getElementById('adjacentFrameDistanceSliderRow'), document.getElementById('framePaddingSliderRow')].forEach(item => { if(item) { item.addEventListener('mousedown', startPreview); item.addEventListener('touchstart', startPreview); } });
        const endPreview = () => { if (isPreviewingBorder) { isPreviewingBorder = false; render(); } };
        window.addEventListener('mouseup', endPreview); window.addEventListener('touchend', endPreview);

        async function saveCanvasToCameraRoll(fileName) { const { Filesystem, Media } = Capacitor.Plugins; const dataUrl = canvas.toDataURL('image/png'); const base64Data = dataUrl.replace(/^data:image\/png;base64,/, ''); const savedFile = await Filesystem.writeFile({ path: fileName, data: base64Data, directory: 'CACHE' }); await Media.savePhoto({ path: savedFile.uri, album: { name: "Halation", create: true } }); await Filesystem.deleteFile({ path: fileName, directory: 'CACHE' }); }
        
        saveBtn.addEventListener("click", async () => {
            if (!imageTexture) return;
            const debugMode = true; // Export timing
            const debugStart = performance.now();
            const workingMaxRaw = maxResSlider.value;
            const exportRaw = exportResSlider ? exportResSlider.value : workingMaxRaw;
            const workingIsOriginal = parseInt(workingMaxRaw,10) >= ORIGINAL_SLIDER_VALUE;
            const exportIsOriginal = parseInt(exportRaw,10) >= ORIGINAL_SLIDER_VALUE;
            
            // Apply aspect ratio multiplier to resolution values for non-16:9 border modes
            const aspectMultiplier = getAspectRatioMultiplier();
            const workingMaxBase = workingIsOriginal ? ORIGINAL_SLIDER_VALUE : parseInt(workingMaxRaw,10);
            const exportMaxBase = exportIsOriginal ? ORIGINAL_SLIDER_VALUE : parseInt(exportRaw,10);
            
            // Apply multiplier to get the actual rendering resolution (behind the scenes)
            const workingMax = workingIsOriginal ? ORIGINAL_SLIDER_VALUE : Math.round(workingMaxBase * aspectMultiplier);
            const exportMax = exportIsOriginal ? ORIGINAL_SLIDER_VALUE : Math.round(exportMaxBase * aspectMultiplier);
            let shouldUseCPU = (cpuTilingToggle && cpuTilingToggle.checked) && ((exportIsOriginal) || (exportMax > 1024));
            // Force CPU path when cropping aspect is active in border mode to guarantee exact output dimensions
            if (currentShapeIsBorder() && (window.__docAspectMode || '16:9') !== '16:9') {
                shouldUseCPU = true;
            }
            const banded = !!(bandedCPUToggle && bandedCPUToggle.checked);
            const computeExportDims = () => {
                const oW = originalImageDimensions.w || canvas.width;
                const oH = originalImageDimensions.h || canvas.height;
                if (exportIsOriginal) return { w:oW, h:oH };
                let w=oW,h=oH; const maxEdge = exportMax;
                if (Math.max(oW,oH) > maxEdge) {
                    const aspect = oW/oH; if (oW>=oH){w=maxEdge; h=Math.round(w/aspect);} else {h=maxEdge; w=Math.round(h*aspect);} }
                return { w, h };
            };
            const expDims = computeExportDims();

            if (shouldUseCPU) {
                // CPU tiling path: reload at target, assemble on 2D canvas, save, then restore working
                const prevWorkingBase = workingMaxBase; // Store the original unmultiplied value
                if (originalFileBlob && (exportMax !== workingMax || exportIsOriginal !== workingIsOriginal)) {
                    if (exportIsOriginal) { forceOriginalWorkingLoadOnce = true; }
                    // Use the original (unmultiplied) export resolution value so loadImageAndResize can apply the multiplier correctly
                    maxResSlider.value = exportIsOriginal ? '4096' : exportMaxBase; // working slider capped at 4k
                    document.getElementById('maxResVal').textContent = formatPx(maxResSlider.value);
                    suppressImageFade = true;
                    await new Promise((resolve) => loadImageAndResize(originalFileBlob, resolve));
                }

                try {
                    isTilingRenderInProgress = true; showProgressIndicator();
                    const filename = `halation_${Date.now()}.png`;
                    const targetMaxDim = exportIsOriginal ? ORIGINAL_SLIDER_VALUE : exportMax;
                    await exportTiledToCPUAndSave(targetMaxDim, filename);
                } finally {
                    isTilingRenderInProgress = false; hideProgressIndicator();
                }

                if (originalFileBlob && (exportMax !== workingMax || exportIsOriginal !== workingIsOriginal)) {
                    // Restore the original unmultiplied working resolution value
                    maxResSlider.value = workingIsOriginal ? maxResSlider.value /* stays at 4k cap */ : prevWorkingBase;
                    document.getElementById('maxResVal').textContent = formatPx(maxResSlider.value);
                    suppressImageFade = true;
                    await new Promise((resolve) => loadImageAndResize(originalFileBlob, resolve));
                }
                if (debugMode) {
                    const ms = (performance.now() - debugStart).toFixed(0);
                    const tileSize = banded ? 512 : TILE_SIZE;
                    const tilesX = Math.ceil(expDims.w / tileSize);
                    const tilesY = Math.ceil(expDims.h / tileSize);
                    console.log(`[DEBUG] Export CPU (${banded?'banded':'normal'}) ${expDims.w}x${expDims.h}, tiles=${tilesX}x${tilesY}, tileSize=${tileSize}, total=${ms}ms`);
                }
            } else {
                // Existing GPU path (no cropping mode)
                if (originalFileBlob && exportMax !== workingMax) {
                    // Use the original (unmultiplied) export resolution value so loadImageAndResize can apply the multiplier correctly
                    maxResSlider.value = exportMaxBase; document.getElementById('maxResVal').textContent = formatPx(exportMaxBase);
                    suppressImageFade = true;
                    await new Promise((resolve) => loadImageAndResize(originalFileBlob, resolve));
                }

                isTilingRenderInProgress = true;
                showProgressIndicator();
                await renderTiled();
                isTilingRenderInProgress = false;
                hideProgressIndicator();

                if (typeof Capacitor !== 'undefined' && Capacitor.isNativePlatform()) {
                    try { await saveCanvasToCameraRoll(`halation_${Date.now()}.png`); alert('Image saved to Halation album!'); }
                    catch (e) { console.error('Error saving image:', e); alert(`Could not save image: ${e.message || 'Unknown'}`); }
                } else {
                    const link = document.createElement('a'); link.download = `halation_${Date.now()}.png`; link.href = canvas.toDataURL('image/png'); link.click();
                }

                if (originalFileBlob && exportMax !== workingMax) {
                    // Restore the original unmultiplied working resolution value
                    maxResSlider.value = workingMaxBase; document.getElementById('maxResVal').textContent = formatPx(workingMaxBase);
                    suppressImageFade = true;
                    await new Promise((resolve) => loadImageAndResize(originalFileBlob, resolve));
                }
                if (debugMode) {
                    const ms = (performance.now() - debugStart).toFixed(0);
                    const tileSize = TILE_SIZE;
                    const tilesX = Math.ceil(canvas.width / tileSize);
                    const tilesY = Math.ceil(canvas.height / tileSize);
                    console.log(`[DEBUG] Export GPU ${canvas.width}x${canvas.height}, tiles=${tilesX}x${tilesY}, tileSize=${tileSize}, total=${ms}ms`);
                }
            }
        });
        
        async function processBatch(files) {
            if (!files?.length) return;
            
            isBatchExportMode = true;
            // Store original working resolution
            const originalWorkingResRaw = maxResSlider ? maxResSlider.value : '2048';
            const exportResRaw = exportResSlider ? exportResSlider.value : originalWorkingResRaw;
            const originalWorkingIsOriginal = parseInt(originalWorkingResRaw,10) >= ORIGINAL_SLIDER_VALUE;
            const exportIsOriginal = parseInt(exportResRaw,10) >= ORIGINAL_SLIDER_VALUE;
            const originalWorkingRes = originalWorkingIsOriginal ? ORIGINAL_SLIDER_VALUE : parseInt(originalWorkingResRaw, 10);
            const exportRes = exportIsOriginal ? ORIGINAL_SLIDER_VALUE : parseInt(exportResRaw, 10);
            const shouldUseCPU = (cpuTilingToggle && cpuTilingToggle.checked) && ((exportIsOriginal) || (exportRes > 1024));
            
            const batchProgress = document.createElement('div'); batchProgress.className = 'progress-indicator visible'; batchProgress.innerHTML = `Processing Batch...<br><span id="batchCounter">0 / ${files.length}</span>`; document.body.appendChild(batchProgress);
            const counter = document.getElementById('batchCounter');
            let success = 0, fail = 0; let times = [];
            
            for (const [i, file] of files.entries()) {
                counter.textContent = `${i + 1} / ${files.length}`;
                try {
                    const t0 = performance.now();
                    // For CPU path, leave working res alone unless we need to bump to export
                    if (shouldUseCPU) {
                        if (exportIsOriginal) { forceOriginalWorkingLoadOnce = true; }
                        maxResSlider.value = exportIsOriginal ? '4096' : exportRes;
                        document.getElementById('maxResVal').textContent = formatPx(maxResSlider.value);
                        await new Promise((resolve, reject) => loadImageAndResize(file, (err) => err ? reject(err) : resolve()));
                        await new Promise(r => setTimeout(r, 50));
                        const targetMaxDim = exportIsOriginal ? ORIGINAL_SLIDER_VALUE : exportRes;
                        await exportTiledToCPUAndSave(targetMaxDim, `halation_batch_${Date.now()}_${file.name}`);
                        success++;
                    } else {
                        // GPU path
                        if (maxResSlider && exportRes !== originalWorkingRes) {
                            maxResSlider.value = exportRes;
                            document.getElementById('maxResVal').textContent = formatPx(exportRes);
                        }
                        await new Promise((resolve, reject) => loadImageAndResize(file, (err) => err ? reject(err) : resolve()));
                        await new Promise(r => setTimeout(r, 100));
                        await renderTiled();
                        await saveCanvasToCameraRoll(`halation_batch_${Date.now()}_${file.name}`);
                        success++;
                    }
                    times.push(performance.now() - t0);
                } catch (error) { fail++; console.error(`Failed on image ${i + 1}:`, error); }
            }
            
            // Restore original working resolution
            if (maxResSlider && (exportRes !== originalWorkingRes || exportIsOriginal !== originalWorkingIsOriginal)) {
                maxResSlider.value = originalWorkingIsOriginal ? ORIGINAL_SLIDER_VALUE : originalWorkingRes;
                document.getElementById('maxResVal').textContent = formatPx(maxResSlider.value);
            }
            
            document.body.removeChild(batchProgress);
            isBatchExportMode = false;
            // Debug summary
            if (times.length) {
                const sum = times.reduce((a,b)=>a+b,0), avg = sum/times.length, max = Math.max(...times), min = Math.min(...times);
                console.log(`[DEBUG] Batch summary: images=${files.length}, mode=${shouldUseCPU?'CPU':'GPU'}${shouldUseCPU?(', '+(banded?'banded':'normal')):''}, avg=${avg.toFixed(0)}ms, min=${min.toFixed(0)}ms, max=${max.toFixed(0)}ms`);
            }
            alert(`${success}/${files.length} Images saved successfully to camera roll.`);
        }
        batchBtn.addEventListener('click', () => uploadBatchInput.click());
        uploadBatchInput.addEventListener('change', (e) => { if (!e.target.files.length) return; const files = Array.from(e.target.files); showBatchProcessModal(files); e.target.value = ''; });
        const filmStockBtn = document.getElementById('filmStockBtn'), filmStockMenuOverlay = document.getElementById('filmStockMenuOverlay'), settingsBtn = document.getElementById('settingsBtn'), settingsMenuOverlay = document.getElementById('settingsMenuOverlay'), presetsBtn = document.getElementById('presetsBtn'), presetsMenuOverlay = document.getElementById('presetsMenuOverlay');
        function toggleMenu(overlay, button) { const topToolbar = document.getElementById('topToolbar'); const menu = overlay.querySelector('div[class$="-menu"]'); if (overlay === filmStockMenuOverlay || overlay === presetsMenuOverlay) { menu.style.top = `${topToolbar.offsetHeight}px`; } const isOpen = overlay.classList.toggle('visible'); button.classList.toggle('menu-open', isOpen); if (isOpen) [filmStockMenuOverlay, settingsMenuOverlay, presetsMenuOverlay].forEach(o => { if (o !== overlay && o.classList.contains('visible')) { o.classList.remove('visible'); const b = document.getElementById(o.id.replace('MenuOverlay', 'Btn')); if (b) b.classList.remove('menu-open'); } }); }
        filmStockBtn.addEventListener('click', () => toggleMenu(filmStockMenuOverlay, filmStockBtn)); filmStockMenuOverlay.addEventListener('click', (e) => { if (e.target === filmStockMenuOverlay) toggleMenu(filmStockMenuOverlay, filmStockBtn); });
        settingsBtn.addEventListener('click', () => toggleMenu(settingsMenuOverlay, settingsBtn)); settingsMenuOverlay.addEventListener('click', (e) => { if (e.target === settingsMenuOverlay) toggleMenu(settingsMenuOverlay, settingsBtn); });
        presetsBtn.addEventListener('click', () => toggleMenu(presetsMenuOverlay, presetsBtn)); presetsMenuOverlay.addEventListener('click', (e) => { if (e.target === presetsMenuOverlay) toggleMenu(presetsMenuOverlay, presetsBtn); });
        function updateBackgroundFromSlider() { 
            // Keep visibility check for interactive use (prevents slider use when menu closed)
            if (!settingsMenuOverlay.classList.contains('visible')) return; 
            const pct = Math.max(0, Math.min(100, parseInt(backgroundSlider.value,10)||0)); 
            backgroundVal.textContent = `${pct}%`; 
            const g = Math.round(255 * (pct/100)); 
            viewport.style.backgroundColor = `rgb(${g},${g},${g})`; 
        }
        
        function applyBackgroundColor() { 
            // Version without visibility check - ONLY for loading preferences on startup
            const pct = Math.max(0, Math.min(100, parseInt(backgroundSlider.value,10)||0)); 
            const backgroundVal = document.getElementById('backgroundVal');
            if (backgroundVal) backgroundVal.textContent = `${pct}%`; 
            const g = Math.round(255 * (pct/100)); 
            viewport.style.backgroundColor = `rgb(${g},${g},${g})`; 
        }
        if (backgroundSlider) { 
            backgroundSlider.addEventListener('input', () => {
                updateBackgroundFromSlider();
                // No auto-save - user will use "Set as Default" button
            }); 
            updateBackgroundFromSlider(); 
        }
        dropShadowToggle.addEventListener('change', () => { 
            // Keep visibility check for interactive use (prevents toggle when menu closed)
            if (!settingsMenuOverlay.classList.contains('visible')) return;
            appContainer.classList.toggle('drop-shadow-enabled', dropShadowToggle.checked); 
            // No auto-save - user will use "Set as Default" button
        });

        // App Settings Default Buttons Event Listeners
        const setDefaultsBtn = document.getElementById('setDefaultsBtn');
        const resetDefaultsBtn = document.getElementById('resetDefaultsBtn');
        
        if (setDefaultsBtn) {
            setDefaultsBtn.addEventListener('click', setAsDefaultSettings);
        }
        
        if (resetDefaultsBtn) {
            resetDefaultsBtn.addEventListener('click', resetToDefaultSettings);
        }

        // Factory Defaults Buttons Event Listeners
        const setFactoryDefaultBtn = document.getElementById('setFactoryDefaultBtn');
        const restoreFactoryDefaultBtn = document.getElementById('restoreFactoryDefaultBtn');
        const defaultSettingsItem = document.getElementById('defaultSettingsItem');
        
        if (setFactoryDefaultBtn) {
            setFactoryDefaultBtn.addEventListener('click', setCurrentAsFactoryDefaults);
        }
        
        if (restoreFactoryDefaultBtn) {
            restoreFactoryDefaultBtn.addEventListener('click', restoreFactoryDefaults);
        }

        // Batch Modal Event Listeners
        const useCurrentSettingsToggle = document.getElementById('useCurrentSettingsToggle');
        const cancelBatchBtn = document.getElementById('cancelBatchBtn');
        const confirmBatchBtn = document.getElementById('confirmBatchBtn');
        const batchProcessModal = document.getElementById('batchProcessModal');
        
        console.log('[WEB] Batch modal elements found:', {
            useCurrentSettingsToggle: !!useCurrentSettingsToggle,
            cancelBatchBtn: !!cancelBatchBtn,
            confirmBatchBtn: !!confirmBatchBtn,
            batchProcessModal: !!batchProcessModal
        });
        
        if (useCurrentSettingsToggle) {
            useCurrentSettingsToggle.addEventListener('change', () => {
                // Visibility protection like settings menu
                const batchProcessModal = document.getElementById('batchProcessModal');
                if (!batchProcessModal || !batchProcessModal.classList.contains('visible')) return;
                
                updatePresetContainerState();
                
                // If switching back to current settings, restore original settings
                if (useCurrentSettingsToggle.checked && selectedBatchPreset && currentBatchOriginalSettings) {
                    console.log('[WEB] Restoring original settings (switching back to current)');
                    selectedBatchPreset = null;
                    batchPresetAnimationInProgress = true;
                    updateBatchProcessButtonState();
                    
                    // Clear preset selection visually
                    document.querySelectorAll('.batch-preset-item').forEach(i => {
                        i.style.backgroundColor = '';
                        i.style.color = '';
                    });
                    
                    // Apply original settings
                    applyPreset(currentBatchOriginalSettings);
                    
                    // Wait for animations
                    setTimeout(() => {
                        batchPresetAnimationInProgress = false;
                        updateBatchProcessButtonState();
                    }, 1000);
                }
            });
        }
        
        if (cancelBatchBtn) {
            cancelBatchBtn.addEventListener('click', () => {
                // Visibility protection like settings menu
                const batchProcessModal = document.getElementById('batchProcessModal');
                if (!batchProcessModal || !batchProcessModal.classList.contains('visible')) return;
                
                console.log('[WEB] Cancel batch button clicked');
                
                // Restore original settings if we had applied a preset
                if (selectedBatchPreset && currentBatchOriginalSettings) {
                    console.log('[WEB] Restoring original settings on cancel...');
                    applyPreset(currentBatchOriginalSettings);
                }
                
                closeBatchModal();
            });
        }
        
        if (confirmBatchBtn) {
            confirmBatchBtn.addEventListener('click', async () => {
                // Visibility protection like settings menu
                const batchProcessModal = document.getElementById('batchProcessModal');
                if (!batchProcessModal || !batchProcessModal.classList.contains('visible')) return;
                
                console.log('[WEB] Confirm batch button clicked');
                
                // Don't process if animation in progress
                if (batchPresetAnimationInProgress) {
                    console.log('[WEB] Animation in progress, ignoring click');
                    return;
                }
                
                const useCurrentSettings = useCurrentSettingsToggle ? useCurrentSettingsToggle.checked : true;
                console.log('[WEB] useCurrentSettings:', useCurrentSettings, 'selectedBatchPreset:', selectedBatchPreset?.name, 'currentBatchFiles:', currentBatchFiles.length);
                
                if (!useCurrentSettings && !selectedBatchPreset) {
                    alert('Please select a preset or use current settings.');
                    return;
                }
                
                // Store files locally before closing modal
                const filesToProcess = [...currentBatchFiles];
                const originalSettingsToRestore = currentBatchOriginalSettings;
                const wasUsingPreset = !useCurrentSettings && selectedBatchPreset;
                
                closeBatchModal();
                
                // Process batch with current settings (preset already applied to UI if selected)
                if (filesToProcess.length > 0) {
                    console.log('[WEB] Processing batch with current settings...');
                    await processBatch(filesToProcess);
                    
                    // Restore original settings if we used a preset
                    if (wasUsingPreset && originalSettingsToRestore) {
                        console.log('[WEB] Restoring original settings after batch...');
                        applyPreset(originalSettingsToRestore);
                        console.log('[WEB] Original settings restored with animation');
                    }
                } else {
                    console.error('[WEB] No files to process!');
                }
            });
        }
        
        // Close modal when clicking outside
        if (batchProcessModal) {
            batchProcessModal.addEventListener('click', (e) => {
                if (e.target === batchProcessModal) {
                    closeBatchModal();
                }
            });
        }
        
        // Make the "Default Settings" item clickable to apply factory defaults
        if (defaultSettingsItem) {
            const defaultSettingsName = defaultSettingsItem.querySelector('.preset-item-name');
            if (defaultSettingsName) {
                defaultSettingsName.addEventListener('click', () => {
                    applyFactoryDefaults();
                    toggleMenu(presetsMenuOverlay, presetsBtn);
                });
            }
        }

        // --- Chroma Ab pre-bake (first step after load) ---
        function getChromaParams() {
            const samplesEl = document.getElementById('chromaSamples');
            const blurEl = document.getElementById('chromaBlur');
            const falloffEl = document.getElementById('chromaFalloff');
            const toggleEl = document.getElementById('chromaToggle');
            const samples = samplesEl ? parseInt(samplesEl.value, 10) || 0 : 0;
            const blur = blurEl ? parseFloat(blurEl.value) || 0 : 0;
            const falloff = falloffEl ? parseFloat(falloffEl.value) || 1.0 : 1.0;
            const enabled = toggleEl ? !!toggleEl.checked : true;
            return { samples: enabled ? samples : 0, blur, falloff };
        }

        function rebuildChromaPrebake() {
            if (!rawImageTexture || !originalImageDimensions.w || !originalImageDimensions.h) return;
            const w = originalImageDimensions.w, h = originalImageDimensions.h;
            const { samples, blur, falloff } = getChromaParams();

            // Clean up previously processed texture to avoid leaks
            if (chromaProcessedTexture) { try { gl.deleteTexture(chromaProcessedTexture); } catch(_){} chromaProcessedTexture = null; }

            if (samples <= 0 || blur <= 0.0) {
                imageTexture = rawImageTexture;
                originalSrgbTexture = rawSrgbTexture;
                // Keep black/white sampling from raw
                recomputeMinMaxFromRawTexture(rawSrgbTexture, w, h);
                return;
            }

            const srcRect = { x: 0, y: 0, w, h };
            const dstRect = { x: 0, y: 0, w, h };
            const tmpFBO = createFBO(w, h, false);
            gl.bindFramebuffer(gl.FRAMEBUFFER, tmpFBO.fbo);
            gl.viewport(0, 0, w, h);
            drawQuadWithRegions(progs.chromaAb, {
                u_image: rawImageTexture,
                u_samplesF: samples,
                u_blur: blur,
                u_falloff: falloff,
                u_fullUVRect: [0, 0, w, h]
            }, srcRect, dstRect, [w, h], [w, h]);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            chromaProcessedTexture = tmpFBO.texture;
            // We can delete the FBO while keeping the texture
            gl.deleteFramebuffer(tmpFBO.fbo);

            imageTexture = chromaProcessedTexture;
            originalSrgbTexture = chromaProcessedTexture;
            // Keep black/white sampling from RAW to avoid CA contamination
            recomputeMinMaxFromRawTexture(rawSrgbTexture, w, h);
        }

        const addPresetModal = document.getElementById('addPresetModal'), presetNameInput = document.getElementById('presetNameInput'), presetParamsList = document.getElementById('presetParamsList'), userPresetsList = document.getElementById('userPresetsList'), savePresetBtn = document.getElementById('savePresetBtn'), cancelPresetBtn = document.getElementById('cancelPresetBtn'), addPresetBtn = document.getElementById('addPresetBtn'), presetModalTitle = document.getElementById('presetModalTitle');
        let userPresets = [], editingPresetIndex = -1;
        const PRESET_STORAGE_KEY = 'halationUserPresets', capacitorStorage = (typeof Capacitor !== 'undefined' && Capacitor.isNativePlatform()) ? Capacitor.Plugins.Storage : null;
        const presetParameters = {
            // Halation controls
            'halationEnabledToggle': { label: 'Halation Enabled', type: 'toggle' },
            'mtfLinearToggle': { label: 'MTF in Linear', type: 'toggle' },
            'halationIntensity': { label: 'Intensity', type: 'slider' },
            'whitepoint': { label: 'Whitepoint', type: 'slider' },
            'mtfMask': { label: 'MTF Mask', type: 'slider' },
            'mtfSoftness': { label: 'MTF Softness', type: 'slider' },
            'blackpoint': { label: 'Blackpoint', type: 'slider' },
            'thresholdGamma': { label: 'Threshold Gamma', type: 'slider' },
            'coreBlur': { label: 'Core Blur', type: 'slider' },
            'midBlur': { label: 'Mid Blur', type: 'slider' },
            'outerBlur': { label: 'Outer Blur', type: 'slider' },
            'midBlurGain': { label: 'Mid Gain', type: 'slider' },
            'outerBlurGain': { label: 'Outer Gain', type: 'slider' },
            'tintR2': { label: 'R Tint', type: 'slider' },
            'tintG2': { label: 'G Tint', type: 'slider' },
            'tintB2': { label: 'B Tint', type: 'slider' },
            'diffusionRadius': { label: 'Diffusion A Radius', type: 'slider' },
            'diffusionStrength': { label: 'Diffusion A Strength', type: 'slider' },
            'diffusionRadiusB': { label: 'Diffusion B Radius', type: 'slider' },
            'diffusionStrengthB': { label: 'Diffusion B Strength', type: 'slider' },
            'diffusionRadiusC': { label: 'Diffusion C Radius', type: 'slider' },
            'diffusionStrengthC': { label: 'Diffusion C Strength', type: 'slider' },
            'diffusionTintR': { label: 'Diffusion R Tint', type: 'slider' },
            'diffusionTintG': { label: 'Diffusion G Tint', type: 'slider' },
            'diffusionTintB': { label: 'Diffusion B Tint', type: 'slider' },
            'diffusionIntensity': { label: 'Diffusion Intensity', type: 'slider' },
            'diffusionThreshold': { label: 'Diffusion Threshold', type: 'slider' },
            'diffusionThresholdPreviewToggle': { label: 'Diffusion Threshold Preview', type: 'toggle' },
            'diffusionSubtractToggle': { label: 'Subtract Source', type: 'toggle' },
            
            // Diffusion 02 controls
            'diffusionRadiusD': { label: 'Diffusion D Radius', type: 'slider' },
            'diffusionStrengthD': { label: 'Diffusion D Strength', type: 'slider' },
            'diffusionRadiusE': { label: 'Diffusion E Radius', type: 'slider' },
            'diffusionStrengthE': { label: 'Diffusion E Strength', type: 'slider' },
            'diffusionRadiusF': { label: 'Diffusion F Radius', type: 'slider' },
            'diffusionStrengthF': { label: 'Diffusion F Strength', type: 'slider' },
            'diffusionTint2R': { label: 'Diffusion 02 Tint R', type: 'slider' },
            'diffusionTint2G': { label: 'Diffusion 02 Tint G', type: 'slider' },
            'diffusionTint2B': { label: 'Diffusion 02 Tint B', type: 'slider' },
            'diffusionSpread2': { label: 'Diffusion 02 Spread', type: 'slider' },
            'diffusionGamma2': { label: 'Diffusion 02 Gamma', type: 'slider' },
            'diffusionIntensity2': { label: 'Diffusion 02 Intensity', type: 'slider' },
            'diffusionThreshold2': { label: 'Diffusion 02 Threshold', type: 'slider' },
            'thresholdGamma2': { label: 'Threshold Gamma', type: 'slider' },
            'thresholdWhite2': { label: 'Threshold White', type: 'slider' },
            'diffusionSubtract2Toggle': { label: 'Subtract Source 02', type: 'toggle' },
            'diffusionMinRgbToggle': { label: 'Min RGB Toggle', type: 'toggle' },
            'diffusionPremultiplyToggle': { label: 'Premultiply Toggle', type: 'toggle' },
            'halationScreenToggle': { label: 'Screen Toggle', type: 'toggle' },
            
            // Whitepoint compensation controls
            'whiteCompSlider': { label: 'Whitepoint Compensation', type: 'slider' },
            'whiteCompLimit': { label: 'Whitepoint Limit', type: 'slider' },
            
            // Texture controls
            'textureEnabledToggle': { label: 'Texture Enabled', type: 'toggle' },
            'grainStockSelect': { label: 'Grain Stock', type: 'select' },
            'grainScale': { label: 'Grain Scale', type: 'slider' },
            'grainIntensity': { label: 'Grain Intensity', type: 'slider' },
            'grainSaturation': { label: 'Grain Saturation', type: 'slider' },
            'grainReduceShadows': { label: 'Grain Reduce Shadows', type: 'slider' },
            'grainShadowSat': { label: 'Grain Shadow Sat', type: 'slider' },
            'grainReduceHighlights': { label: 'Grain Reduce Highlights', type: 'slider' },
            'grainHighlightSat': { label: 'Grain Highlight Sat', type: 'slider' },
            'highPassRadius': { label: 'High Pass Radius', type: 'slider' },
            'highPassOpacity': { label: 'High Pass Opacity', type: 'slider' },
            // Chroma Ab (pre-bake)
            'chromaToggle': { label: 'Chroma Enabled', type: 'toggle' },
            'chromaSamples': { label: 'Chroma Samples', type: 'slider' },
            'chromaBlur': { label: 'Chroma Blur', type: 'slider' },
            'chromaFalloff': { label: 'Chroma Falloff', type: 'slider' },
            
            // Border controls (sliders only)
            'overscan': { label: 'Overscan', type: 'slider' },
            'framing': { label: 'Framing', type: 'slider' },
            'borderScale': { label: 'Border Scale', type: 'slider' },
            'imageScale': { label: 'Image Scale', type: 'slider' },
            'adjacentFrameDistance': { label: 'Adjacent Frame Distance', type: 'slider' },
            'framePadding': { label: 'Frame Padding', type: 'slider' },
            'sprocketScale': { label: 'Sprocket Scale', type: 'slider' },
            'blackLevelBias': { label: 'Black Level Bias', type: 'slider' },
            'sprocketStockSelect': { label: 'Sprocket Stock', type: 'select' },
            'sprocketContrast': { label: 'Sprocket Contrast', type: 'slider' },
            
            // Border engine and selections (NEW)
            'borderEngine': { label: 'Border Engine', type: 'custom' },
            'current8mmBorder': { label: '8mm Border Type', type: 'custom' },
            'current8mmSprocket': { label: '8mm Sprocket Type', type: 'custom' },
            'current16mmBorder': { label: '16mm Border Type', type: 'custom' },
            'current16mmSprocket': { label: '16mm Sprocket Type', type: 'custom' },
            'current35mm178Border': { label: '35mm 1.78 Border Type', type: 'custom' },
            'current35mm178Sprocket': { label: '35mm 1.78 Sprocket Type', type: 'custom' },
            'current35mm240Border': { label: '35mm 2.40 Border Type', type: 'custom' },
            'current35mm240Sprocket': { label: '35mm 2.40 Sprocket Type', type: 'custom' },
            'current35mm133Border': { label: '35mm 1.33 Border Type', type: 'custom' },
            'current35mm133Sprocket': { label: '35mm 1.33 Sprocket Type', type: 'custom' },
            
            // Dust controls (enabled only, not position/rotation)
            'dustEnabledToggle': { label: 'Dust Enabled', type: 'toggle' }
        };
        async function savePresetsToStorage() { const d=JSON.stringify(userPresets); if(capacitorStorage) await capacitorStorage.set({key:PRESET_STORAGE_KEY,value:d}); else localStorage.setItem(PRESET_STORAGE_KEY,d); }
        async function loadPresetsFromStorage() { let d; if(capacitorStorage) d=(await capacitorStorage.get({key:PRESET_STORAGE_KEY})).value; else d=localStorage.getItem(PRESET_STORAGE_KEY); if(d){userPresets=JSON.parse(d);renderPresetsList();} }
        function renderPresetsList() { userPresetsList.innerHTML = ''; if (userPresets.length === 0) { userPresetsList.innerHTML = '<p style="text-align:center;color:#888;font-size:14px;padding:20px 0;">No presets.</p>'; return; } userPresets.forEach((preset, i) => { const item=document.createElement('div'); item.className='preset-item'; item.innerHTML=`<span class="preset-item-name">${preset.name}</span><button class="preset-item-menu-btn">...</button><ul class="preset-item-menu"><li data-action="edit">Edit</li><li data-action="delete">Delete</li></ul>`; item.querySelector('.preset-item-name').addEventListener('click', () => { applyPreset(preset); toggleMenu(presetsMenuOverlay, presetsBtn); }); const menuBtn=item.querySelector('.preset-item-menu-btn'), menu=item.querySelector('.preset-item-menu'); menuBtn.addEventListener('click', e => { e.stopPropagation(); document.querySelectorAll('.preset-item-menu.show').forEach(m => { if(m!==menu) m.classList.remove('show'); }); menu.classList.toggle('show'); }); menu.addEventListener('click', e => { e.stopPropagation(); if (e.target.dataset.action === 'edit') openEditPresetModal(i); else if (e.target.dataset.action === 'delete' && confirm(`Delete "${preset.name}"?`)) deletePreset(i); menu.classList.remove('show'); }); userPresetsList.appendChild(item); }); }
        document.addEventListener('click', () => document.querySelectorAll('.preset-item-menu.show').forEach(m => m.classList.remove('show')));

        // Override presets list to use inline icon buttons: Overwrite, Edit, Delete
        function renderPresetsList() {
            userPresetsList.innerHTML = '';
            if (userPresets.length === 0) {
                userPresetsList.innerHTML = '<p style="text-align:center;color:#888;font-size:14px;padding:20px 0;">No presets.</p>';
                return;
            }
            userPresets.forEach((preset, i) => {
                const item = document.createElement('div');
                item.className = 'preset-item';
                const nameSpan = document.createElement('span');
                nameSpan.className = 'preset-item-name';
                nameSpan.textContent = preset.name;
                nameSpan.addEventListener('click', () => { applyPreset(preset); toggleMenu(presetsMenuOverlay, presetsBtn); });

                const btns = document.createElement('div');
                btns.className = 'preset-actions';

                const overwriteBtn = document.createElement('button');
                overwriteBtn.className = 'icon-btn';
                overwriteBtn.title = 'Overwrite';
                overwriteBtn.innerHTML = '<span class="icon icon-save"></span>';
                overwriteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!confirm(`Overwrite "${preset.name}" with current settings?`)) return;
                    const current = captureCurrentSettings();
                    userPresets[i] = { name: preset.name, values: current.values };
                    savePresetsToStorage();
                    renderPresetsList();
                });

                const editBtn = document.createElement('button');
                editBtn.className = 'icon-btn';
                editBtn.title = 'Edit';
                editBtn.innerHTML = '<span class="icon icon-edit"></span>';
                editBtn.addEventListener('click', (e) => { e.stopPropagation(); openEditPresetModal(i); });

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'icon-btn';
                deleteBtn.title = 'Delete';
                deleteBtn.innerHTML = '<span class="icon icon-trash"></span>';
                deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); if (confirm(`Delete "${preset.name}"?`)) deletePreset(i); });

                btns.appendChild(overwriteBtn);
                btns.appendChild(editBtn);
                btns.appendChild(deleteBtn);
                item.appendChild(nameSpan);
                item.appendChild(btns);
                userPresetsList.appendChild(item);
            });
        }
        function applyPreset(preset) { 
            // Apply regular form controls
            Object.keys(preset.values).forEach(k => { 
                const el=document.getElementById(k); 
                if(el) { 
                    if(el.type==='checkbox') el.checked=preset.values[k]; 
                    else el.value=preset.values[k]; 
                }
            }); 
            
            // Apply custom border engine variables by triggering actual button clicks
            // This ensures proper sequencing and visual transitions
            
            // First, apply border engine selection
            if (preset.values.hasOwnProperty('borderEngine')) {
                const targetEngine = preset.values['borderEngine'];
                const borderEngineButtons = document.getElementById('borderEngineButtons');
                if (borderEngineButtons) {
                    const targetBtn = borderEngineButtons.querySelector(`[data-engine="${targetEngine}"]`);
                    if (targetBtn && targetEngine !== borderEngine) {
                        // Trigger the actual click event to ensure proper handling
                        targetBtn.click();
                    }
                }
            }
            
            // Then apply border and sprocket selections for each engine
            // Use setTimeout to ensure border engine change has completed
            setTimeout(() => {
                if (preset.values.hasOwnProperty('current8mmBorder')) {
                    const buttons = document.getElementById('border8mmButtons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-border="${preset.values['current8mmBorder']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current8mmSprocket')) {
                    const buttons = document.getElementById('sprocket8mmButtons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-sprocket="${preset.values['current8mmSprocket']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current16mmBorder')) {
                    const buttons = document.getElementById('border16mmButtons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-border="${preset.values['current16mmBorder']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current16mmSprocket')) {
                    const buttons = document.getElementById('sprocket16mmButtons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-sprocket="${preset.values['current16mmSprocket']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current35mm178Border')) {
                    const buttons = document.getElementById('border35mm178Buttons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-border="${preset.values['current35mm178Border']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current35mm178Sprocket')) {
                    const buttons = document.getElementById('sprocket35mm178Buttons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-sprocket="${preset.values['current35mm178Sprocket']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current35mm240Border')) {
                    const buttons = document.getElementById('border35mm240Buttons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-border="${preset.values['current35mm240Border']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current35mm240Sprocket')) {
                    const buttons = document.getElementById('sprocket35mm240Buttons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-sprocket="${preset.values['current35mm240Sprocket']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current35mm133Border')) {
                    const buttons = document.getElementById('border35mm133Buttons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-border="${preset.values['current35mm133Border']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
                if (preset.values.hasOwnProperty('current35mm133Sprocket')) {
                    const buttons = document.getElementById('sprocket35mm133Buttons');
                    if (buttons) {
                        const targetBtn = buttons.querySelector(`[data-sprocket="${preset.values['current35mm133Sprocket']}"]`);
                        if (targetBtn) targetBtn.click();
                    }
                }
            }, 100); // Small delay to ensure border engine change completes first
            
            calculateOverscanScales();
            
            // Ensure programmatic select changes are valid and load associated textures
            const gsSel = document.getElementById('grainStockSelect');
            if (gsSel) {
                const valid = Array.from(gsSel.options).filter(o=>!o.disabled).map(o=>o.value);
                if (!valid.includes(gsSel.value)) {
                    gsSel.value = valid.includes('35mm P400') ? '35mm P400' : valid[0];
                }
                if (grainSources[gsSel.value]) { loadGrainFromURL(grainSources[gsSel.value]); }
            }
            const spSel = document.getElementById('sprocketStockSelect');
            if (spSel) {
                const valid = Array.from(spSel.options).map(o=>o.value);
                if (!valid.includes(spSel.value)) {
                    spSel.value = valid.includes('Spectra 400') ? 'Spectra 400' : valid[0];
                }
                // Only load generic sprocket when not in special engines
                const be = window.__borderEngine;
                const isSpecial = (be === '8mm' || be === '16mm' || be === '35mm-178' || be === '35mm-240' || be === '35mm-133' || be === '35mm-add' || be === 'medium-format');
                if (!isSpecial && sprocketSources[spSel.value]) { loadSprocketFromURL(sprocketSources[spSel.value]); }
            }
            // Ensure labels reflect new values and pre-baked chroma is updated
            updateSliderLabels();
            rebuildChromaPrebake();
            if (imageTexture) render();
        }
        function deletePreset(i) { userPresets.splice(i,1); savePresetsToStorage(); renderPresetsList(); }
        function openAddPresetModal() { editingPresetIndex=-1; presetModalTitle.textContent='Add New Preset'; presetNameInput.value=''; presetParamsList.innerHTML=''; Object.entries(presetParameters).forEach(([id, {label}]) => { presetParamsList.innerHTML+=`<div class="preset-param-item"><label for="param-${id}">${label}</label><input type="checkbox" id="param-${id}" data-param-id="${id}" checked></div>`; }); addPresetModal.classList.add('visible'); }
        function openEditPresetModal(i) { editingPresetIndex=i; const preset=userPresets[i]; presetModalTitle.textContent='Edit Preset'; presetNameInput.value=preset.name; presetParamsList.innerHTML=''; Object.entries(presetParameters).forEach(([id, {label}]) => { presetParamsList.innerHTML+=`<div class="preset-param-item"><label for="param-${id}">${label}</label><input type="checkbox" id="param-${id}" data-param-id="${id}" ${preset.values.hasOwnProperty(id)?'checked':''}></div>`; }); addPresetModal.classList.add('visible'); toggleMenu(presetsMenuOverlay, presetsBtn); }
        function closePresetModal() { addPresetModal.classList.remove('visible'); }
        addPresetBtn.addEventListener('click', openAddPresetModal); cancelPresetBtn.addEventListener('click', closePresetModal);

        // --- BATCH PROCESSING MODAL ---
        let currentBatchFiles = [];
        let selectedBatchPreset = null;
        let currentBatchOriginalSettings = null;
        let batchPresetAnimationInProgress = false;
        
        function showBatchProcessModal(files) {
            currentBatchFiles = files;
            selectedBatchPreset = null;
            currentBatchOriginalSettings = captureCurrentSettings(); // Store original settings
            batchPresetAnimationInProgress = false;
            
            // Update modal description
            const batchModalDescription = document.getElementById('batchModalDescription');
            if (batchModalDescription) {
                batchModalDescription.textContent = `Process ${files.length} images`;
            }
            
            // Reset toggle to current settings
            const useCurrentSettingsToggle = document.getElementById('useCurrentSettingsToggle');
            if (useCurrentSettingsToggle) {
                useCurrentSettingsToggle.checked = true;
            }
            
            // Populate presets list
            populateBatchPresetsList();
            
            // Update preset container state
            updatePresetContainerState();
            
            // Show modal
            const batchProcessModal = document.getElementById('batchProcessModal');
            if (batchProcessModal) {
                batchProcessModal.classList.add('visible');
            }
        }
        
        function populateBatchPresetsList() {
            const batchPresetsList = document.getElementById('batchPresetsList');
            if (!batchPresetsList) return;
            
            batchPresetsList.innerHTML = '';
            
            if (userPresets.length === 0) {
                batchPresetsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No presets available</div>';
                return;
            }
            
            userPresets.forEach((preset, index) => {
                const item = document.createElement('div');
                item.className = 'batch-preset-item';
                item.style.cssText = `
                    padding: 12px 15px;
                    border-bottom: 1px solid rgba(255,255,255,0.1);
                    cursor: pointer;
                    transition: background-color 0.2s;
                    font-size: 14px;
                `;
                item.textContent = preset.name;
                
                item.addEventListener('click', async () => {
                    // Visibility protection like settings menu
                    const batchProcessModal = document.getElementById('batchProcessModal');
                    if (!batchProcessModal || !batchProcessModal.classList.contains('visible')) return;
                    
                    // Prevent clicks during animation
                    if (batchPresetAnimationInProgress) return;
                    
                    // Remove selection from other items
                    document.querySelectorAll('.batch-preset-item').forEach(i => {
                        i.style.backgroundColor = '';
                        i.style.color = '';
                    });
                    
                    // Select this item
                    item.style.backgroundColor = '#FFC107';
                    item.style.color = '#000';
                    selectedBatchPreset = preset;
                    
                    // Apply preset to live UI (with animations)
                    console.log('[WEB] Applying preset to live UI:', preset.name);
                    batchPresetAnimationInProgress = true;
                    updateBatchProcessButtonState();
                    
                    // Apply the preset with normal animations
                    applyPreset(preset);
                    
                    // Wait for animations to complete
                    setTimeout(() => {
                        batchPresetAnimationInProgress = false;
                        updateBatchProcessButtonState();
                        console.log('[WEB] Preset animation completed');
                    }, 1000); // Wait for border engine animations
                });
                
                item.addEventListener('mouseenter', () => {
                    if (selectedBatchPreset !== preset) {
                        item.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    }
                });
                
                item.addEventListener('mouseleave', () => {
                    if (selectedBatchPreset !== preset) {
                        item.style.backgroundColor = '';
                    }
                });
                
                batchPresetsList.appendChild(item);
            });
        }
        
        function updateBatchProcessButtonState() {
            const confirmBatchBtn = document.getElementById('confirmBatchBtn');
            if (!confirmBatchBtn) return;
            
            if (batchPresetAnimationInProgress) {
                confirmBatchBtn.disabled = true;
                confirmBatchBtn.textContent = 'Applying preset...';
                confirmBatchBtn.style.opacity = '0.5';
            } else {
                confirmBatchBtn.disabled = false;
                confirmBatchBtn.textContent = 'Process';
                confirmBatchBtn.style.opacity = '1';
            }
        }
        
        function updatePresetContainerState() {
            const useCurrentSettingsToggle = document.getElementById('useCurrentSettingsToggle');
            const presetSelectionContainer = document.getElementById('presetSelectionContainer');
            
            if (!useCurrentSettingsToggle || !presetSelectionContainer) return;
            
            const useCurrentSettings = useCurrentSettingsToggle.checked;
            
            if (useCurrentSettings) {
                // Grey out preset selection
                presetSelectionContainer.style.opacity = '0.4';
                const batchPresetsList = document.getElementById('batchPresetsList');
                if (batchPresetsList) {
                    batchPresetsList.style.pointerEvents = 'none';
                }
                selectedBatchPreset = null;
                
                // Remove any selections
                document.querySelectorAll('.batch-preset-item').forEach(item => {
                    item.style.backgroundColor = '';
                    item.style.color = '';
                });
            } else {
                // Enable preset selection
                presetSelectionContainer.style.opacity = '1';
                const batchPresetsList = document.getElementById('batchPresetsList');
                if (batchPresetsList) {
                    batchPresetsList.style.pointerEvents = 'auto';
                }
            }
        }
        
        // Capture current settings (like saving a preset)
        function captureCurrentSettings() {
            const currentSettings = {
                name: "Batch Backup",
                values: {}
            };
            
            // Capture all preset parameters from current UI state
            Object.keys(presetParameters).forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    const param = presetParameters[id];
                    if (param.type === 'slider') {
                        currentSettings.values[id] = element.value;
                    } else if (param.type === 'toggle') {
                        currentSettings.values[id] = element.checked;
                    } else if (param.type === 'select') {
                        currentSettings.values[id] = element.value;
                    } else if (param.type === 'custom') {
                        // Handle custom border engine variables
                        if (id === 'borderEngine') {
                            currentSettings.values[id] = window.__borderEngine || 'medium-format';
                        } else if (id.includes('Border')) {
                            const engine = id.replace('current', '').replace('Border', '').toLowerCase();
                            currentSettings.values[id] = window[`__current${engine.charAt(0).toUpperCase() + engine.slice(1)}Border`] || 'A';
                        } else if (id.includes('Sprocket')) {
                            const engine = id.replace('current', '').replace('Sprocket', '').toLowerCase();
                            currentSettings.values[id] = window[`__current${engine.charAt(0).toUpperCase() + engine.slice(1)}Sprocket`] || 'A';
                        }
                    }
                }
            });
            
            return currentSettings;
        }

        
        function closeBatchModal() {
            const batchProcessModal = document.getElementById('batchProcessModal');
            if (batchProcessModal) {
                batchProcessModal.classList.remove('visible');
            }
            currentBatchFiles = [];
            selectedBatchPreset = null;
        }
        savePresetBtn.addEventListener('click', () => { 
            const name=presetNameInput.value.trim(); 
            if(!name) {alert('Please enter a name.'); return;} 
            const values={}; 
            
            // Save regular form controls
            document.querySelectorAll('#presetParamsList input:checked').forEach(c => { 
                const id=c.dataset.paramId, el=document.getElementById(id); 
                if(el) {
                    values[id]=el.type==='checkbox'?el.checked:el.value; 
                }
            }); 
            
            // Save custom border engine variables if they're selected
            const checkedParams = Array.from(document.querySelectorAll('#presetParamsList input:checked')).map(c => c.dataset.paramId);
            
            if (checkedParams.includes('borderEngine')) {
                values['borderEngine'] = borderEngine;
            }
            if (checkedParams.includes('current8mmBorder')) {
                values['current8mmBorder'] = current8mmBorder;
            }
            if (checkedParams.includes('current8mmSprocket')) {
                values['current8mmSprocket'] = current8mmSprocket;
            }
            if (checkedParams.includes('current16mmBorder')) {
                values['current16mmBorder'] = current16mmBorder;
            }
            if (checkedParams.includes('current16mmSprocket')) {
                values['current16mmSprocket'] = current16mmSprocket;
            }
            if (checkedParams.includes('current35mm178Border')) {
                values['current35mm178Border'] = current35mm178Border;
            }
            if (checkedParams.includes('current35mm178Sprocket')) {
                values['current35mm178Sprocket'] = current35mm178Sprocket;
            }
            if (checkedParams.includes('current35mm240Border')) {
                values['current35mm240Border'] = current35mm240Border;
            }
            if (checkedParams.includes('current35mm240Sprocket')) {
                values['current35mm240Sprocket'] = current35mm240Sprocket;
            }
            if (checkedParams.includes('current35mm133Border')) {
                values['current35mm133Border'] = current35mm133Border;
            }
            if (checkedParams.includes('current35mm133Sprocket')) {
                values['current35mm133Sprocket'] = current35mm133Sprocket;
            }
            
            const newPreset={name, values}; 
            if (editingPresetIndex > -1) userPresets[editingPresetIndex]=newPreset; 
            else userPresets.push(newPreset); 
            savePresetsToStorage(); 
            renderPresetsList(); 
            closePresetModal(); 
        });
        document.querySelectorAll('.stock-btn').forEach(b => { b.addEventListener('click', () => { document.querySelectorAll('.stock-btn').forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); }); });

        // --- FACTORY DEFAULTS SYSTEM (based on HTML default values) ---
        let factoryDefaults = {
            name: "Factory Defaults",
            values: {
                // Halation controls (from HTML defaults)
                halationEnabledToggle: true,
                mtfLinearToggle: true,
                halationIntensity: "1.0",
                whitepoint: "2.0",
                mtfMask: "2.5",
                mtfSoftness: "9.0",
                blackpoint: "0.2",
                thresholdGamma: "0.7",
                coreBlur: "3.0",
                midBlur: "6.0",
                outerBlur: "20.0",
                midBlurGain: "0.9",
                outerBlurGain: "0.6",
                tintR2: "1.0",
                tintG2: "0.30",
                tintB2: "0.02",
                diffusionRadius: "0",
                diffusionStrength: "0",
                diffusionRadiusB: "0",
                diffusionStrengthB: "0",
                diffusionRadiusC: "0",
                diffusionStrengthC: "0",
                diffusionTintR: "1.0",
                diffusionTintG: "1.0",
                diffusionTintB: "1.0",
                diffusionIntensity: "1.0",
                diffusionThreshold: "1.0",
                diffusionThresholdPreviewToggle: true,
                diffusionSubtractToggle: false,
                
                // Diffusion 02 controls (DEF system)
                diffusionThreshold2: "1.0",
                thresholdGamma2: "1.0",
                thresholdWhite2: "7.22",
                diffusionSubtract2Toggle: false,
                diffusionMinRgbToggle: true,
                diffusionPremultiplyToggle: true,
                halationScreenToggle: false,
                
                // Texture controls
                textureEnabledToggle: true,
                grainStockSelect: "35mm P400",
                grainScale: "1.0",
                grainIntensity: "1.0",
                grainSaturation: "1.0",
                grainReduceShadows: "0.0",
                grainShadowSat: "1.0",
                grainReduceHighlights: "0.0",
                grainHighlightSat: "1.0",
                highPassRadius: "0.5",
                highPassOpacity: "0.5",

                // Chroma Ab defaults
                chromaToggle: true,
                chromaSamples: "5",
                chromaBlur: "0.01",
                chromaFalloff: "1.0",
                
                // Border controls
                overscan: "1.0",
                framing: "1.0",
                borderScale: "1.0",
                imageScale: "1.0",
                adjacentFrameDistance: "100",
                framePadding: "0.00",
                sprocketScale: "1.0",
                blackLevelBias: "0.9",
                sprocketStockSelect: "Spectra 400",
                sprocketContrast: "1.0",
                cheatAspectX: "1.0",
                cheatAspectY: "1.0",
                borderBlur: "0",
                
                // Border engine and selections (defaults to 35mm Stills)
                borderEngine: "35mm-add",
                current8mmBorder: "A",
                current8mmSprocket: "A",
                current16mmBorder: "A",
                current16mmSprocket: "A",
                current35mm178Border: "A",
                current35mm178Sprocket: "A",
                current35mm240Border: "A",
                current35mm240Sprocket: "A",
                current35mm133Border: "A",
                current35mm133Sprocket: "A",
                
                // Dust controls
                dustEnabledToggle: false
            }
        };

        // --- APP SETTINGS PRESET SYSTEM (works exactly like regular presets) ---
        let appSettingsPreset = {
            name: "App Settings",
            values: {
                backgroundSlider: "0",
                dropShadowToggle: true,
                maxResSlider: "2048", 
                exportResSlider: "4096",
                cpuTilingToggle: false,
                bandedCPUToggle: false
            }
        };
        
        const APP_SETTINGS_KEY = 'halationAppSettings';
        const FACTORY_DEFAULTS_KEY = 'halationFactoryDefaults';
        
        // Save app settings using the exact same method as regular presets
        async function saveAppSettings() {
            try {
                const data = JSON.stringify(appSettingsPreset);
                if (capacitorStorage) {
                    await capacitorStorage.set({ key: APP_SETTINGS_KEY, value: data });
                } else {
                    localStorage.setItem(APP_SETTINGS_KEY, data);
                }
                console.log('[WEB] App settings saved:', appSettingsPreset.values);
            } catch (error) {
                console.error('[WEB] Error saving app settings:', error);
            }
        }
        
        // Load app settings using the exact same method as regular presets
        async function loadAppSettings() {
            try {
                let data;
                if (capacitorStorage) {
                    const result = await capacitorStorage.get({ key: APP_SETTINGS_KEY });
                    data = result.value;
                } else {
                    data = localStorage.getItem(APP_SETTINGS_KEY);
                }
                
                if (data) {
                    const loadedSettings = JSON.parse(data);
                    appSettingsPreset = loadedSettings;
                    console.log('[WEB] App settings loaded:', appSettingsPreset.values);
                    
                    // Apply settings after a short delay
                    setTimeout(() => {
                        applyAppSettings();
                    }, 100);
                } else {
                    console.log('[WEB] No saved app settings found, using defaults');
                }
            } catch (error) {
                console.error('[WEB] Error loading app settings:', error);
            }
        }
        
        // Apply app settings using the same approach as regular presets
        function applyAppSettings() {
            const values = appSettingsPreset.values;
            
            // Apply each setting directly (like applyPreset does)
            if (backgroundSlider && values.hasOwnProperty('backgroundSlider')) {
                backgroundSlider.value = values.backgroundSlider;
                applyBackgroundColor();
            }
            
            if (dropShadowToggle && values.hasOwnProperty('dropShadowToggle')) {
                dropShadowToggle.checked = values.dropShadowToggle;
                appContainer.classList.toggle('drop-shadow-enabled', dropShadowToggle.checked);
            }
            
            if (maxResSlider && values.hasOwnProperty('maxResSlider')) {
                // Sanitize any legacy 'Original' value down to 4k for working res
                const v = parseInt(values.maxResSlider, 10);
                maxResSlider.value = snapRes(Math.min(4096, isNaN(v) ? 2048 : v));
                updateResLabels();
            }
            
            if (exportResSlider && values.hasOwnProperty('exportResSlider')) {
                exportResSlider.value = values.exportResSlider;
                updateResLabels();
            }
            if (cpuTilingToggle && values.hasOwnProperty('cpuTilingToggle')) {
                cpuTilingToggle.checked = !!values.cpuTilingToggle;
            }
            if (bandedCPUToggle && values.hasOwnProperty('bandedCPUToggle')) {
                bandedCPUToggle.checked = !!values.bandedCPUToggle;
            }
            
            console.log('[WEB] Applied app settings to UI');

            // Enforce CPU if any slider is at Original
            if ((isOriginalSelectedOn(exportResSlider)) && cpuTilingToggle && !cpuTilingToggle.checked) {
                cpuTilingToggle.checked = true;
            }
            // Show/hide banded row based on CPU tiling
            if (bandedCPURow) {
                bandedCPURow.style.display = (cpuTilingToggle && cpuTilingToggle.checked) ? '' : 'none';
            }
        }
        
        // Capture current app settings from UI (exactly like preset save)
        function captureCurrentAppSettings() {
            const currentSettings = {
                name: "App Settings",
                values: {}
            };
            
            // Capture background slider
            if (backgroundSlider) {
                currentSettings.values.backgroundSlider = backgroundSlider.value;
            }
            
            // Capture drop shadow toggle
            if (dropShadowToggle) {
                currentSettings.values.dropShadowToggle = dropShadowToggle.checked;
            }
            
            // Capture resolution sliders
            if (maxResSlider) {
                currentSettings.values.maxResSlider = maxResSlider.value;
            }
            
            if (exportResSlider) {
                currentSettings.values.exportResSlider = exportResSlider.value;
            }
            if (cpuTilingToggle) {
                currentSettings.values.cpuTilingToggle = cpuTilingToggle.checked;
            }
            if (bandedCPUToggle) {
                currentSettings.values.bandedCPUToggle = bandedCPUToggle.checked;
            }
            
            return currentSettings;
        }
        
        // Save current settings as defaults (like savePresetBtn click)
        async function setAsDefaultSettings() {
            try {
                appSettingsPreset = captureCurrentAppSettings();
                await saveAppSettings();
                console.log('[WEB] Current settings saved as defaults!');
                
                // Visual feedback
                const btn = document.getElementById('setDefaultsBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'Saved!';
                    btn.style.background = '#4CAF50';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 1500);
                }
            } catch (error) {
                console.error('[WEB] Error setting defaults:', error);
            }
        }
        
        // Reset to saved defaults (like loading a preset)
        async function resetToDefaultSettings() {
            try {
                await loadAppSettings();
                console.log('[WEB] Reset to default settings!');
                
                // Visual feedback
                const btn = document.getElementById('resetDefaultsBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'Reset!';
                    btn.style.background = '#2196F3';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 1500);
                }
            } catch (error) {
                console.error('[WEB] Error resetting to defaults:', error);
            }
        }

        // --- FACTORY DEFAULTS SYSTEM ---
        
        // Save factory defaults using the exact same method as regular presets
        async function saveFactoryDefaults() {
            try {
                const data = JSON.stringify(factoryDefaults);
                if (capacitorStorage) {
                    await capacitorStorage.set({ key: FACTORY_DEFAULTS_KEY, value: data });
                } else {
                    localStorage.setItem(FACTORY_DEFAULTS_KEY, data);
                }
                console.log('[WEB] Factory defaults saved:', factoryDefaults.values);
            } catch (error) {
                console.error('[WEB] Error saving factory defaults:', error);
            }
        }
        
        // Load factory defaults from storage (does not apply them, just loads for manual use)
        async function loadFactoryDefaults() {
            try {
                let data;
                if (capacitorStorage) {
                    const result = await capacitorStorage.get({ key: FACTORY_DEFAULTS_KEY });
                    data = result.value;
                } else {
                    data = localStorage.getItem(FACTORY_DEFAULTS_KEY);
                }
                
                if (data) {
                    const loadedDefaults = JSON.parse(data);
                    factoryDefaults = loadedDefaults;
                    console.log('[WEB] Factory defaults loaded from storage:', factoryDefaults.name);
                } else {
                    console.log('[WEB] No saved factory defaults found, using built-in defaults');
                    // Save the built-in defaults for future use (but don't apply them)
                    await saveFactoryDefaults();
                }
            } catch (error) {
                console.error('[WEB] Error loading factory defaults:', error);
            }
        }
        
        // Set current settings as factory defaults (with confirmation)
        async function setCurrentAsFactoryDefaults() {
            const confirmed = confirm('Set current settings as new factory defaults?\n\nThis will overwrite the default preset used when launching the app.');
            if (!confirmed) return;
            
            try {
                // Capture current settings exactly like saving a preset
                const currentSettings = {
                    name: "Factory Defaults",
                    values: {}
                };
                
                // Capture all preset parameters from current UI state
                Object.keys(presetParameters).forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        const param = presetParameters[id];
                        if (param.type === 'slider') {
                            currentSettings.values[id] = element.value;
                        } else if (param.type === 'toggle') {
                            currentSettings.values[id] = element.checked;
                        } else if (param.type === 'select') {
                            currentSettings.values[id] = element.value;
                        } else if (param.type === 'custom') {
                            // Handle custom border engine variables
                            if (id === 'borderEngine') {
                                currentSettings.values[id] = window.__borderEngine || 'medium-format';
                            } else if (id.includes('Border')) {
                                const engine = id.replace('current', '').replace('Border', '').toLowerCase();
                                currentSettings.values[id] = window[`__current${engine.charAt(0).toUpperCase() + engine.slice(1)}Border`] || 'A';
                            } else if (id.includes('Sprocket')) {
                                const engine = id.replace('current', '').replace('Sprocket', '').toLowerCase();
                                currentSettings.values[id] = window[`__current${engine.charAt(0).toUpperCase() + engine.slice(1)}Sprocket`] || 'A';
                            }
                        }
                    }
                });
                
                factoryDefaults = currentSettings;
                await saveFactoryDefaults();
                console.log('[WEB] Current settings saved as factory defaults!');
                
                // Visual feedback
                const btn = document.getElementById('setFactoryDefaultBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'Saved!';
                    btn.style.background = '#4CAF50';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 1500);
                }
            } catch (error) {
                console.error('[WEB] Error setting factory defaults:', error);
            }
        }
        
        // Apply factory defaults (exactly like applyPreset)
        function applyFactoryDefaults() {
            console.log('[WEB] Applying factory defaults...');
            applyPreset(factoryDefaults);
        }
        
        // Restore factory defaults (with confirmation)
        async function restoreFactoryDefaults() {
            const confirmed = confirm('Restore factory defaults?\n\nThis will overwrite the current default preset with original factory settings.');
            if (!confirmed) return;
            
            try {
                // Reset to built-in factory defaults
                factoryDefaults = {
                    name: "Factory Defaults",
                    values: {
                        // Reset to original HTML defaults (same as above)
                        halationEnabledToggle: true,
                        mtfLinearToggle: true,
                        halationIntensity: "1.0",
                        whitepoint: "2.0",
                        mtfMask: "2.5",
                        mtfSoftness: "9.0",
                        blackpoint: "0.2",
                        thresholdGamma: "0.7",
                        coreBlur: "3.0",
                        midBlur: "6.0",
                        outerBlur: "20.0",
                        midBlurGain: "0.9",
                        outerBlurGain: "0.6",
                        tintR2: "1.0",
                        tintG2: "0.30",
                        tintB2: "0.02",
                        diffusionRadius: "0",
                        diffusionStrength: "0",
                        diffusionRadiusB: "0",
                        diffusionStrengthB: "0",
                        diffusionRadiusC: "0",
                        diffusionStrengthC: "0",
                        diffusionTintR: "1.0",
                        diffusionTintG: "1.0",
                        diffusionTintB: "1.0",
                        diffusionIntensity: "1.0",
                        diffusionSubtractToggle: false,
                        textureEnabledToggle: true,
                        grainStockSelect: "35mm P400",
                        grainScale: "1.0",
                        grainIntensity: "1.0",
                        grainSaturation: "1.0",
                        highPassRadius: "0.5",
                        highPassOpacity: "0.5",
                        overscan: "1.0",
                        framing: "1.0",
                        borderScale: "1.0",
                        imageScale: "1.0",
                        adjacentFrameDistance: "100",
                        framePadding: "0.00",
                        sprocketScale: "1.0",
                        blackLevelBias: "0.9",
                        sprocketStockSelect: "Spectra 400",
                        sprocketContrast: "1.0",
                        cheatAspectX: "1.0",
                        cheatAspectY: "1.0",
                        borderBlur: "0",
                        borderEngine: "35mm-add",
                        current8mmBorder: "A",
                        current8mmSprocket: "A",
                        current16mmBorder: "A",
                        current16mmSprocket: "A",
                        current35mm178Border: "A",
                        current35mm178Sprocket: "A",
                        current35mm240Border: "A",
                        current35mm240Sprocket: "A",
                        current35mm133Border: "A",
                        current35mm133Sprocket: "A",
                        dustEnabledToggle: false
                    }
                };
                
                await saveFactoryDefaults();
                console.log('[WEB] Factory defaults restored!');
                
                // Visual feedback
                const btn = document.getElementById('restoreFactoryDefaultBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'Restored!';
                    btn.style.background = '#FF9800';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 1500);
                }
            } catch (error) {
                console.error('[WEB] Error restoring factory defaults:', error);
            }
        }
        window.addEventListener('resize',()=>{ setAppHeight(); updateTopbarHeight(); if(imageTexture){ fitScale=calculateFitScale(); if(Math.abs(scale-fitScale)<0.01) fitToView(); else { scale=constrainScale(scale); updateTransform(false); } updateCheatAspectLimits(); } updateControlsHeight(); updatePanelHeight(); updateAspectButtonLabels(); });
        
        // --- INITIALIZATION ---
        const maxResSlider = document.getElementById('maxResSlider');
        const exportResSlider = document.getElementById('exportResSlider');
        function updateResLabels() {
            if (maxResSlider) document.getElementById('maxResVal').textContent = formatPx(snapRes(maxResSlider.value));
            if (exportResSlider) document.getElementById('exportResVal').textContent = formatPx(snapRes(exportResSlider.value));
        }
        if (maxResSlider) maxResSlider.addEventListener('input', () => { 
            // Only update labels while dragging
            maxResSlider.value = snapRes(maxResSlider.value); 
            updateResLabels(); 
            // No auto-save - user will use "Set as Default" button
        });
        if (exportResSlider) exportResSlider.addEventListener('input', () => { 
            exportResSlider.value = snapRes(exportResSlider.value); 
            updateResLabels(); 
            // No auto-save - user will use "Set as Default" button
        });
        // Apply actions on release only
        if (maxResSlider) maxResSlider.addEventListener('change', () => {
            maxResSlider.value = snapRes(maxResSlider.value);
            updateResLabels();
            if (originalFileBlob) loadImageAndResize(originalFileBlob);
        });
        if (exportResSlider) exportResSlider.addEventListener('change', () => {
            exportResSlider.value = snapRes(exportResSlider.value);
            updateResLabels();
            // Enforce CPU only on release if Original is selected
            if (isOriginalSelectedOn(exportResSlider) && cpuTilingToggle && !cpuTilingToggle.checked) {
                cpuTilingToggle.checked = true;
                if (bandedCPURow) bandedCPURow.style.display = '';
            }
        });
        // Removed custom resolution buttons
        updateResLabels();

        // CPU toggle guardrails
        if (cpuWarningOkBtn && cpuWarningModal) {
            cpuWarningOkBtn.addEventListener('click', () => {
                cpuWarningModal.classList.remove('visible');
            });
        }

        if (cpuTilingToggle) {
            cpuTilingToggle.addEventListener('change', () => {
                const wantsOff = !cpuTilingToggle.checked;
                if (wantsOff && (isOriginalSelectedOn(maxResSlider) || isOriginalSelectedOn(exportResSlider))) {
                    // Show warning and revert back on
                    cpuTilingToggle.checked = true;
                    if (cpuWarningModal) cpuWarningModal.classList.add('visible');
                }
                // Show/hide banded row
                if (bandedCPURow) {
                    bandedCPURow.style.display = cpuTilingToggle.checked ? '' : 'none';
                }
            });
            // Initialize banded row visibility on startup
            if (bandedCPURow) {
                bandedCPURow.style.display = cpuTilingToggle.checked ? '' : 'none';
            }
        }

        setAppHeight(); updateTopbarHeight(); initializeDraggableSliders(); updateControlsHeight(); loadPresetsFromStorage(); loadFactoryDefaults(); loadAppSettings(); updateSliderLabels(); updateCheatAspectLimits();
        document.querySelector('.initial-logo-container').addEventListener('click', loadFromCameraRoll);
        loadGrainFromURL(grainSources[grainStockSelect.value]);
        loadSprocketFromURL(sprocketSources[sprocketStockSelect.value]);
        loadMaskATexture('./assets/grain/maska.png');
        loadMaskBTexture('./assets/grain/maskb.png');
        loadMaskCTexture('./assets/grain/maskc.png');
        loadBorderFromURL('./assets/grain/border.png');
        hideAllPanels();
        // Populate grain stocks with headings and separators
        function populateGrainStocks() {
            const ordered = [
                { header: 'Stills', items: ['35mm E100','35mm P400','35mm P800'] },
                { header: 'Motion', items: ['35mm 500T','35mm 250D','35mm 50D','16mm 500T','16mm 250D','16mm 50D','8mm 500T','8mm 250D','8mm 50D'] },
            ];
            const prev = grainStockSelect.value;
            grainStockSelect.innerHTML = '';
            ordered.forEach(group => {
                const head = document.createElement('option'); head.textContent = group.header; head.disabled = true; head.value=''; grainStockSelect.appendChild(head);
                group.items.forEach(label => {
                    if (!grainSources[label]) return;
                    const opt = document.createElement('option'); opt.value = label; opt.textContent = label; grainStockSelect.appendChild(opt);
                });
            });
            // Restore previous selection if still present, otherwise jump to first valid option
            const validValues = Array.from(grainStockSelect.options).filter(o=>!o.disabled).map(o=>o.value);
            grainStockSelect.value = validValues.includes(prev) ? prev : '35mm P400';
        }
        // Populate sprockets in requested order
        (function populateSprocketsOrdered(){
            const order = [
                'Spectra 100','Spectra 400','Spectra 800','Ektar 100','Fujifilm Pro 400H','Lomography 800','Portra 400','Portra 800'
            ];
            const prev = sprocketStockSelect.value;
            sprocketStockSelect.innerHTML = '';
            order.forEach(label => { const opt=document.createElement('option'); opt.value=label; opt.textContent=label; sprocketStockSelect.appendChild(opt); });
            sprocketStockSelect.value = order.includes(prev) ? prev : 'Spectra 400';
            // Set default sprocket texture
            const def = sprocketSources[sprocketStockSelect.value]; if (def) loadSprocketFromURL(def);
        })();
        populateGrainStocks();

        const allStockButtons = document.querySelectorAll('.stock-btn');
        allStockButtons.forEach(button => { button.addEventListener('click', () => { document.querySelectorAll('.stock-btn').forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); }); });
        const filmStockApplyBtn = document.getElementById('filmStockApplyBtn');
        if (filmStockApplyBtn) {
            filmStockApplyBtn.addEventListener('click', applyFilmPreset);
        }
        function getGaugeLabel() { const v = parseInt(document.getElementById('gaugeSlider').value, 10); return v === 2 ? '35mm' : v === 1 ? '16mm' : '8mm'; }
        // Border engine selection
        const borderEngineButtons = document.getElementById('borderEngineButtons');
        let borderEngine = '35mm-add';
        window.__borderEngine = borderEngine;
        // 8mm selector states
        let current8mmBorder = 'A';
        let current8mmSprocket = 'A';
        // 16mm selector states
        let current16mmBorder = 'A';
        let current16mmSprocket = 'A';
        // 35mm engine selector states  
        let current35mm178Border = 'A';
        let current35mm178Sprocket = 'A';
        let current35mm240Border = 'A';
        let current35mm240Sprocket = 'A';
        let current35mm133Border = 'A';
        let current35mm133Sprocket = 'A';
        if (borderEngineButtons) {
            borderEngineButtons.addEventListener('click', async (e)=>{
                const btn = e.target.closest('.engine-btn'); if(!btn) return;
                const nextEngine = btn.dataset.engine;
                if (nextEngine === borderEngine) return;
                // Helpers
                const currentOverscan = parseFloat(overscanSlider.value);
                const waitNextFrame = () => new Promise(r => requestAnimationFrame(()=>r()));
                const animateOverscan = async (from, to, ms) => new Promise(resolve => {
                    const prevSimple = isSimplePreviewing; isSimplePreviewing = true;
                    const start = performance.now();
                    const step = (t) => {
                        const x = Math.min(1, (t - start) / ms);
                        // Symmetric ease-in-out cubic
                        const e = x < 0.5 ? 4.0 * x * x * x : 1.0 - Math.pow(-2.0 * x + 2.0, 3.0) / 2.0;
                        const v = from + (to - from) * (e < 0 ? 0 : e);
                        overscanSlider.value = v;
                        calculateOverscanScales();
                        if (x < 1) requestAnimationFrame(step); else { isSimplePreviewing = prevSimple; resolve(); }
                    };
                    requestAnimationFrame(step);
                });
                // 1) Animate to 0 using current engine logic (twice as fast)
                if (currentOverscan > 0.0) { await animateOverscan(currentOverscan, 0.0, 500); }
                // 2) Turn off all current overlays and ensure applied
                window.__suppressOverlays = true; render(); await waitNextFrame();
                // Save current border blur value before switching
                if (borderBlurSlider && borderEngine) {
                    borderBlurSettings[borderEngine] = parseFloat(borderBlurSlider.value);
                }
                
                borderEngine = nextEngine;
                window.__borderEngine = borderEngine;
                borderEngineButtons.querySelectorAll('.engine-btn').forEach(b=>b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Restore border blur value for the new engine
                if (borderBlurSlider && borderEngine) {
                    borderBlurSlider.value = borderBlurSettings[borderEngine] || 0;
                    if (borderBlurValLabel) {
                        borderBlurValLabel.textContent = borderBlurSettings[borderEngine].toFixed(1);
                    }
                }
                // Toggle sprocket UI rows
                const sprocket8mmRow = document.getElementById('sprocket8mmRow');
                const border8mmRow = document.getElementById('border8mmRow');
                const sprocket16mmRow = document.getElementById('sprocket16mmRow');
                const border16mmRow = document.getElementById('border16mmRow');
                const sprocket16mmScaleSliderRow = document.getElementById('sprocket16mmScaleSliderRow');
                // 35mm engine elements
                const sprocket35mm178Row = document.getElementById('sprocket35mm178Row');
                const border35mm178Row = document.getElementById('border35mm178Row');
                const sprocket35mm178ScaleSliderRow = document.getElementById('sprocket35mm178ScaleSliderRow');
                const sprocket35mm178TranslationSliderRow = document.getElementById('sprocket35mm178TranslationSliderRow');
                const sprocket35mm240Row = document.getElementById('sprocket35mm240Row');
                const border35mm240Row = document.getElementById('border35mm240Row');
                const sprocket35mm240ScaleSliderRow = document.getElementById('sprocket35mm240ScaleSliderRow');
                const sprocket35mm240TranslationSliderRow = document.getElementById('sprocket35mm240TranslationSliderRow');
                const sprocket35mm133Row = document.getElementById('sprocket35mm133Row');
                const border35mm133Row = document.getElementById('border35mm133Row');
                const sprocket35mm133ScaleSliderRow = document.getElementById('sprocket35mm133ScaleSliderRow');
                const sprocket35mm133TranslationSliderRow = document.getElementById('sprocket35mm133TranslationSliderRow');
                const sprocketStockLabel = document.getElementById('sprocketStockLabel');
                const sprocketStockSelectEl = document.getElementById('sprocketStockSelect');
                const adjacentFrameDistanceSliderRow = document.getElementById('adjacentFrameDistanceSliderRow');
                const borderBlurSliderRow = document.getElementById('borderBlurSliderRow');
                const sprocketScaleSliderRow = document.getElementById('sprocketScaleSliderRow');

                if (sprocket8mmRow && sprocketStockLabel && sprocketStockSelectEl) {
                    const is8 = (borderEngine === '8mm');
                    const is16 = (borderEngine === '16mm');
                    const is35mm178 = (borderEngine === '35mm-178');
                    const is35mm240 = (borderEngine === '35mm-240');
                    const is35mm133 = (borderEngine === '35mm-133');
                    const is35mmAdd = (borderEngine === '35mm-add');
                    const isMediumFormat = (borderEngine === 'medium-format');
                    const isSpecial = is8 || is16 || is35mm178 || is35mm240 || is35mm133 || is35mmAdd || isMediumFormat;
                    
                    // 8mm
                    sprocket8mmRow.style.display = is8 ? '' : 'none';
                    if (border8mmRow) border8mmRow.style.display = is8 ? '' : 'none';
                    
                    // 16mm
                    if (sprocket16mmRow) sprocket16mmRow.style.display = is16 ? '' : 'none';
                    if (border16mmRow) border16mmRow.style.display = is16 ? '' : 'none';
                    if (sprocket16mmScaleSliderRow) sprocket16mmScaleSliderRow.style.display = is16 ? '' : 'none';
                    
                    // 35mm 1.78
                    if (sprocket35mm178Row) sprocket35mm178Row.style.display = is35mm178 ? '' : 'none';
                    if (border35mm178Row) border35mm178Row.style.display = is35mm178 ? '' : 'none';
                    if (sprocket35mm178ScaleSliderRow) sprocket35mm178ScaleSliderRow.style.display = is35mm178 ? '' : 'none';
                    if (sprocket35mm178TranslationSliderRow) sprocket35mm178TranslationSliderRow.style.display = is35mm178 ? '' : 'none';
                    
                    // 35mm 2.40
                    if (sprocket35mm240Row) sprocket35mm240Row.style.display = is35mm240 ? '' : 'none';
                    if (border35mm240Row) border35mm240Row.style.display = is35mm240 ? '' : 'none';
                    if (sprocket35mm240ScaleSliderRow) sprocket35mm240ScaleSliderRow.style.display = is35mm240 ? '' : 'none';
                    if (sprocket35mm240TranslationSliderRow) sprocket35mm240TranslationSliderRow.style.display = is35mm240 ? '' : 'none';
                    
                    // 35mm 1.33
                    if (sprocket35mm133Row) sprocket35mm133Row.style.display = is35mm133 ? '' : 'none';
                    if (border35mm133Row) border35mm133Row.style.display = is35mm133 ? '' : 'none';
                    if (sprocket35mm133ScaleSliderRow) sprocket35mm133ScaleSliderRow.style.display = is35mm133 ? '' : 'none';
                    if (sprocket35mm133TranslationSliderRow) sprocket35mm133TranslationSliderRow.style.display = is35mm133 ? '' : 'none';
                    
                    // Medium Format
                    const sprocketMediumFormatRow = document.getElementById('sprocketMediumFormatRow');
                    if (sprocketMediumFormatRow) sprocketMediumFormatRow.style.display = isMediumFormat ? '' : 'none';
                    
                    // Common UI
                    sprocketStockLabel.style.display = isSpecial ? 'none' : '';
                    sprocketStockSelectEl.style.display = isSpecial ? 'none' : '';
                    // Exception: keep sprocket stock visible for 35mm additive
                    if (borderEngine === '35mm-add') {
                        sprocketStockLabel.style.display = '';
                        sprocketStockSelectEl.style.display = '';
                    }
                    if (adjacentFrameDistanceSliderRow) {
                        // Hide for 35mm additive and medium format engines (they use fixed offsets)
                        adjacentFrameDistanceSliderRow.style.display = (borderEngine === '35mm-add' || borderEngine === 'medium-format') ? 'none' : '';
                    }
                    const framePaddingSliderRow = document.getElementById('framePaddingSliderRow');
                    if (framePaddingSliderRow) {
                        framePaddingSliderRow.style.display = isSpecial ? '' : 'none';
                    }
                    if (borderBlurSliderRow) {
                        borderBlurSliderRow.style.display = isSpecial ? '' : 'none';
                        // Update blur slider max value based on engine
                        const borderBlurSlider = document.getElementById('borderBlur');
                        if (borderBlurSlider && isSpecial) {
                            const maxBlur = is16 ? 20 : 40; // All others use 40
                            borderBlurSlider.max = maxBlur;
                            // Clamp current value if it exceeds new max
                            if (parseFloat(borderBlurSlider.value) > maxBlur) {
                                borderBlurSlider.value = maxBlur;
                            }
                        }
                    }
                    if (sprocketScaleSliderRow) {
                        sprocketScaleSliderRow.style.display = (is8 || is16) ? '' : 'none'; // 35mm engines have their own translation sliders
                    }
                }
                // 3) Load incoming textures and wait for both
                const loadTexture = (url, premultiply) => new Promise(res=>{ const img=new Image(); img.onload=()=>{ const tex=createTexture(img,false,!!premultiply); res(tex); }; img.src=url; });
                
                // <<< FIX: ENHANCED BORDER ENGINE LOGIC
                const loadBorderAndApplyBlur = async (borderPath, sprocketPath) => {
                    const [newOriginalBorder, newSprocket] = await Promise.all([
                        loadTexture(borderPath, true),
                        loadTexture(sprocketPath, true)
                    ]);
                    
                    // Clean up old textures
                    if (originalBorderTexture) gl.deleteTexture(originalBorderTexture);
                    if (borderTexture && borderTexture !== originalBorderTexture) gl.deleteTexture(borderTexture);
                    if (sprocketTexture) gl.deleteTexture(sprocketTexture);
                    
                    // Set new textures
                    originalBorderTexture = newOriginalBorder;
                    borderTexture = newOriginalBorder; // Start with unblurred texture
                    sprocketTexture = newSprocket;
                    
                    // Apply blur if needed
                    const blurValue = parseFloat(borderBlurSlider.value);
                    if (blurValue > 0) {
                    applyBorderBlur();
                    }
                };
                
                if (borderEngine === '8mm') {
                    await loadBorderAndApplyBlur(
                        `./assets/grain/border8mm${current8mmBorder}.png`, 
                        `./assets/grain/sprocket8mm${current8mmSprocket}.png`
                    );
                } else if (borderEngine === '16mm') {
                    await loadBorderAndApplyBlur(
                        `./assets/grain/border16mm${current16mmBorder}.png`, 
                        `./assets/grain/sprocket16mm${current16mmSprocket}.png`
                    );
                } else if (borderEngine === '35mm-178') {
                    await loadBorderAndApplyBlur(
                        `./assets/grain/border35mm_178_${current35mm178Border}.png`, 
                        `./assets/grain/sprocket35mm_178_${current35mm178Sprocket}.png`
                    );
                } else if (borderEngine === '35mm-240') {
                    await loadBorderAndApplyBlur(
                        `./assets/grain/border35mm_240_${current35mm240Border}.png`, 
                        `./assets/grain/sprocket35mm_240_${current35mm240Sprocket}.png`
                    );
                } else if (borderEngine === '35mm-133') {
                    await loadBorderAndApplyBlur(
                        `./assets/grain/border35mm_133_${current35mm133Border}.png`, 
                        `./assets/grain/sprocket35mm_133_${current35mm133Sprocket}.png`
                    );
                } else if (borderEngine === '35mm-add') {
                    await loadBorderAndApplyBlur(
                        `./assets/grain/border.png`,
                        sprocketSources[sprocketStockSelect.value] || `./assets/grain/spectra400.png`
                    );
                } else if (borderEngine === 'medium-format') {
                    const mediumFormatSelect = document.getElementById('sprocketMediumFormatSelect');
                    const selectedStock = mediumFormatSelect ? mediumFormatSelect.value : 'spectra800';
                    await loadBorderAndApplyBlur(
                        `./assets/grain/bordermediumformat_67_A.png`,
                        `./assets/grain/sprocketmediumformat_${selectedStock}.png`
                    );
                } else {
                    // Standard 35mm stills mode
                    if (originalBorderTexture) {
                        gl.deleteTexture(originalBorderTexture);
                        originalBorderTexture = null;
                    }
                    if (borderTexture) gl.deleteTexture(borderTexture);
                    
                    const sprocketUrl = sprocketSources[sprocketStockSelect.value];
                    const [newBorder, newSprocket] = await Promise.all([
                        loadTexture('./assets/grain/border.png', true),
                        sprocketUrl ? loadTexture(sprocketUrl, true) : Promise.resolve(null)
                    ]);
                    
                    borderTexture = newBorder;
                    if (newSprocket) { 
                        if (sprocketTexture) gl.deleteTexture(sprocketTexture); 
                        sprocketTexture = newSprocket; 
                    }
                }
                
                // 4) Re-enable overlays and render once
                window.__suppressOverlays = false; 
                await waitNextFrame(); // Ensure UI state is updated
                calculateOverscanScales(); 
                render(); 
                await waitNextFrame();
                // 5) Animate back to stored overscan using incoming logic
                if (currentOverscan > 0.0) { 
                    // Force recalculate overscan with stored value to trigger the animation
                    const tempValue = overscanSlider.value;
                    overscanSlider.value = 0.0;
                    calculateOverscanScales();
                    await waitNextFrame();
                    await animateOverscan(0.0, currentOverscan, 500); 
                }
                // Update cheat aspect limits for all border engines
                updateCheatAspectLimits();
                // Exit proxy/simple preview and run full pipeline
                isSimplePreviewing = false; render();
            });
        }
        // 8mm sprocket and border controls
        const sprocket8mmButtons = document.getElementById('sprocket8mmButtons');
        if (sprocket8mmButtons) {
            sprocket8mmButtons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const sprocketType = btn.dataset.sprocket;
                if (!sprocketType || sprocketType === current8mmSprocket) return;
                
                // Update button selection
                sprocket8mmButtons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current8mmSprocket = sprocketType;
                const url = `./assets/grain/sprocket8mm${sprocketType}.png`;
                const img = new Image();
                img.onload = () => {
                    if (sprocketTexture) gl.deleteTexture(sprocketTexture);
                    sprocketTexture = createTexture(img, false, true);
                    render();
                };
                img.src = url;
            });
        }
        const border8mmButtons = document.getElementById('border8mmButtons');
        if (border8mmButtons) {
            border8mmButtons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const borderType = btn.dataset.border;
                if (!borderType || borderType === current8mmBorder) return;
                
                // Update button selection
                border8mmButtons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current8mmBorder = borderType;
                const url = `./assets/grain/border8mm${borderType}.png`;
                const img = new Image();
                img.onload = () => {
                    // Clean up old textures
                    if (originalBorderTexture) gl.deleteTexture(originalBorderTexture);
                    if (borderTexture && borderTexture !== originalBorderTexture) gl.deleteTexture(borderTexture);
                    
                    // Set new textures
                    originalBorderTexture = createTexture(img, false, true);
                    borderTexture = originalBorderTexture; // Start with unblurred texture
                    
                    // Apply blur if needed
                    const blurValue = parseFloat(borderBlurSlider.value);
                    if (blurValue > 0) {
                    applyBorderBlur();
                    } else {
                        render(); // Render with the new unblurred border
                    }
                };
                img.src = url;
            });
        }
        
        // 16mm sprocket and border controls
        const sprocket16mmButtons = document.getElementById('sprocket16mmButtons');
        if (sprocket16mmButtons) {
            sprocket16mmButtons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const sprocketType = btn.dataset.sprocket;
                if (!sprocketType || sprocketType === current16mmSprocket) return;
                
                // Update button selection
                sprocket16mmButtons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current16mmSprocket = sprocketType;
                const url = `./assets/grain/sprocket16mm${sprocketType}.png`;
                const img = new Image();
                img.onload = () => {
                    if (sprocketTexture) gl.deleteTexture(sprocketTexture);
                    sprocketTexture = createTexture(img, false, true);
                    render();
                };
                img.src = url;
            });
        }
        
        const border16mmButtons = document.getElementById('border16mmButtons');
        if (border16mmButtons) {
            border16mmButtons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const borderType = btn.dataset.border;
                if (!borderType || borderType === current16mmBorder) return;
                
                // Update button selection
                border16mmButtons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current16mmBorder = borderType;
                const url = `./assets/grain/border16mm${borderType}.png`;
                const img = new Image();
                img.onload = () => {
                    // Clean up old textures
                    if (originalBorderTexture) gl.deleteTexture(originalBorderTexture);
                    if (borderTexture && borderTexture !== originalBorderTexture) gl.deleteTexture(borderTexture);
                    
                    // Set new textures
                    originalBorderTexture = createTexture(img, false, true);
                    borderTexture = originalBorderTexture; // Start with unblurred texture
                    
                    // Apply blur if needed
                    const blurValue = parseFloat(borderBlurSlider.value);
                    if (blurValue > 0) {
                    applyBorderBlur();
                    } else {
                        render(); // Render with the new unblurred border
                    }
                };
                img.src = url;
            });
        }

        // 35mm 1.78 sprocket and border controls
        const sprocket35mm178Buttons = document.getElementById('sprocket35mm178Buttons');
        if (sprocket35mm178Buttons) {
            sprocket35mm178Buttons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const sprocketType = btn.dataset.sprocket;
                if (!sprocketType || sprocketType === current35mm178Sprocket) return;
                
                // Update button selection
                sprocket35mm178Buttons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current35mm178Sprocket = sprocketType;
                const url = `./assets/grain/sprocket35mm_178_${sprocketType}.png`;
                const img = new Image();
                img.onload = () => {
                    if (sprocketTexture) gl.deleteTexture(sprocketTexture);
                    sprocketTexture = createTexture(img, false, true);
                    render();
                };
                img.src = url;
            });
        }
        
        const border35mm178Buttons = document.getElementById('border35mm178Buttons');
        if (border35mm178Buttons) {
            border35mm178Buttons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const borderType = btn.dataset.border;
                if (!borderType || borderType === current35mm178Border) return;
                
                // Update button selection
                border35mm178Buttons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current35mm178Border = borderType;
                const url = `./assets/grain/border35mm_178_${borderType}.png`;
                const img = new Image();
                img.onload = () => {
                    // Clean up old textures
                    if (originalBorderTexture) gl.deleteTexture(originalBorderTexture);
                    if (borderTexture && borderTexture !== originalBorderTexture) gl.deleteTexture(borderTexture);
                    
                    // Set new textures
                    originalBorderTexture = createTexture(img, false, true);
                    borderTexture = originalBorderTexture; // Start with unblurred texture
                    
                    // Apply blur if needed
                    const blurValue = borderBlurSettings['35mm-178'];
                    if (blurValue > 0) {
                        applyBorderBlur();
                    } else {
                        render(); // Render with the new unblurred border
                    }
                };
                img.src = url;
            });
        }

        // 35mm 2.40 sprocket and border controls
        const sprocket35mm240Buttons = document.getElementById('sprocket35mm240Buttons');
        if (sprocket35mm240Buttons) {
            sprocket35mm240Buttons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const sprocketType = btn.dataset.sprocket;
                if (!sprocketType || sprocketType === current35mm240Sprocket) return;
                
                // Update button selection
                sprocket35mm240Buttons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current35mm240Sprocket = sprocketType;
                const url = `./assets/grain/sprocket35mm_240_${sprocketType}.png`;
                const img = new Image();
                img.onload = () => {
                    if (sprocketTexture) gl.deleteTexture(sprocketTexture);
                    sprocketTexture = createTexture(img, false, true);
                    render();
                };
                img.src = url;
            });
        }
        
        const border35mm240Buttons = document.getElementById('border35mm240Buttons');
        if (border35mm240Buttons) {
            border35mm240Buttons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const borderType = btn.dataset.border;
                if (!borderType || borderType === current35mm240Border) return;
                
                // Update button selection
                border35mm240Buttons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current35mm240Border = borderType;
                const url = `./assets/grain/border35mm_240_${borderType}.png`;
                const img = new Image();
                img.onload = () => {
                    // Clean up old textures
                    if (originalBorderTexture) gl.deleteTexture(originalBorderTexture);
                    if (borderTexture && borderTexture !== originalBorderTexture) gl.deleteTexture(borderTexture);
                    
                    // Set new textures
                    originalBorderTexture = createTexture(img, false, true);
                    borderTexture = originalBorderTexture; // Start with unblurred texture
                    
                    // Apply blur if needed
                    const blurValue = borderBlurSettings['35mm-240'];
                    if (blurValue > 0) {
                        applyBorderBlur();
                    } else {
                        render(); // Render with the new unblurred border
                    }
                };
                img.src = url;
            });
        }

        // 35mm 1.33 sprocket and border controls
        const sprocket35mm133Buttons = document.getElementById('sprocket35mm133Buttons');
        if (sprocket35mm133Buttons) {
            sprocket35mm133Buttons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const sprocketType = btn.dataset.sprocket;
                if (!sprocketType || sprocketType === current35mm133Sprocket) return;
                
                // Update button selection
                sprocket35mm133Buttons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current35mm133Sprocket = sprocketType;
                const url = `./assets/grain/sprocket35mm_133_${sprocketType}.png`;
                const img = new Image();
                img.onload = () => {
                    if (sprocketTexture) gl.deleteTexture(sprocketTexture);
                    sprocketTexture = createTexture(img, false, true);
                    render();
                };
                img.src = url;
            });
        }
        const border35mm133Buttons = document.getElementById('border35mm133Buttons');
        if (border35mm133Buttons) {
            border35mm133Buttons.addEventListener('click', (e) => {
                const btn = e.target.closest('.engine-btn');
                if (!btn) return;
                const borderType = btn.dataset.border;
                if (!borderType || borderType === current35mm133Border) return;
                
                // Update button selection
                border35mm133Buttons.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                // Update state and load texture
                current35mm133Border = borderType;
                const url = `./assets/grain/border35mm_133_${borderType}.png`;
                const img = new Image();
                img.onload = () => {
                    // Clean up old textures
                    if (originalBorderTexture) gl.deleteTexture(originalBorderTexture);
                    if (borderTexture && borderTexture !== originalBorderTexture) gl.deleteTexture(borderTexture);
                    
                    // Set new textures
                    originalBorderTexture = createTexture(img, false, true);
                    borderTexture = originalBorderTexture; // Start with unblurred texture
                    
                    // Apply blur if needed
                    const blurValue = borderBlurSettings['35mm-133'];
                    if (blurValue > 0) {
                        applyBorderBlur();
                    } else {
                        render(); // Render with the new unblurred border
                    }
                };
                img.src = url;
            });
        }

        function getSelectedStock() { const sel = document.querySelector('.stock-btn.selected'); return sel ? sel.textContent.trim() : ''; }
        async function applyFilmPreset() {
            if (!filmStockApplyBtn) return;
            // Prevent overlapping applies
            if (suppressRenders || isTilingRenderInProgress) return;
            suppressRenders = true;
            const prevBtnText = filmStockApplyBtn.textContent;
            filmStockApplyBtn.textContent = 'Processingâ€¦';
            filmStockApplyBtn.disabled = true;
            let needTextureReloads = [];
            const gauge = getGaugeLabel();
            const stock = getSelectedStock();
            const setHalation = (p) => {
                halationIntensitySlider.value = p.intensity;
                whitepointSlider.value = p.whitepoint;
                blackpointSlider.value = p.blackpoint;
                thresholdGammaSlider.value = p.thresholdGamma;
                coreBlurSlider.value = p.core;
                midBlurSlider.value = p.mid;
                outerBlurSlider.value = p.outer;
                midBlurGainSlider.value = p.midGain;
                outerBlurGainSlider.value = p.outerGain;
                tintR2Slider.value = p.r;
                tintG2Slider.value = p.g;
                tintB2Slider.value = p.b;
                mtfMaskSlider.value = p.mtfMask;
                mtfSoftnessSlider.value = p.mtfSoftness;
            };
            const setBorder = (label) => {
                if (sprocketSources[label]) {
                    sprocketStockSelect.value = label;
                    needTextureReloads.push(() => new Promise(res=>{ const url=sprocketSources[label]; const img=new Image(); img.onload=()=>{ if (sprocketTexture) gl.deleteTexture(sprocketTexture); sprocketTexture=createTexture(img,false,true); res(); }; img.src=url; }));
                }
            };
            const setTexture = (label, tex) => {
                grainStockSelect.value = label;
                if (grainSources[label]) {
                    needTextureReloads.push(() => new Promise(res=>{ const url=grainSources[label]; const img=new Image(); img.onload=()=>{ if (grainTexture) gl.deleteTexture(grainTexture); grainDimensions={w:img.naturalWidth,h:img.naturalHeight}; grainTexture=createTexture(img,true); res(); }; img.src=url; }));
                }
                grainScaleSlider.value = tex.scale;
                grainIntensitySlider.value = tex.intensity;
                grainSaturationSlider.value = tex.saturation;
                highPassRadiusSlider.value = tex.hpRadius;
                highPassOpacitySlider.value = tex.hpOpacity;
            };
            const baseHal35 = { intensity:1, whitepoint:2, blackpoint:0.2, thresholdGamma:0.7, core:3, mid:6, outer:20, midGain:0.9, outerGain:0.6, r:1, g:0.3, b:0.02 };
            const baseHal16 = { intensity:1, whitepoint:2, blackpoint:0.2, thresholdGamma:0.7, core:10, mid:22, outer:32, midGain:0.9, outerGain:0.6, r:1, g:0.3, b:0.02 };
            const baseHal8  = { intensity:1, whitepoint:2, blackpoint:0.2, thresholdGamma:0.7, core:10, mid:22, outer:32, midGain:0.9, outerGain:0.6, r:1, g:0.3, b:0.02 };
            // Diffusion is now always handled via precomputed buffer - no direct computation
            let diffusionResult = fboSet.addGlowToBase.texture;

            gl.bindFramebuffer(gl.FRAMEBUFFER, fboSet.finalTonemapped.fbo); drawQuadWithRegions(progs.linearToSrgb, { u_image: diffusionResult, u_originalSrgb: fboSet.postMtfSrgb.texture, u_enableWhiteComp: isWhiteCompEnabled(), u_whitePointSrgb: getWhitePointValue() }, tileRect, destRect, tileResolution, tileResolution);
        }

        // Medium Format sprocket selector
        const sprocketMediumFormatSelect = document.getElementById('sprocketMediumFormatSelect');
        if (sprocketMediumFormatSelect) {
            sprocketMediumFormatSelect.addEventListener('change', (e) => {
                const selectedStock = e.target.value;
                if (window.__borderEngine === 'medium-format') {
                    const url = `./assets/grain/sprocketmediumformat_${selectedStock}.png`;
                    const img = new Image();
                    img.onload = () => {
                        if (sprocketTexture) gl.deleteTexture(sprocketTexture);
                        sprocketTexture = createTexture(img, false, true);
                        render();
                    };
                    img.src = url;
                }
            });
        }
        
        // Diffusion tint sliders event listeners
        if (diffusionTintRSlider) {
            diffusionTintRSlider.addEventListener('input', () => {
                diffusionTintRValLabel.textContent = parseFloat(diffusionTintRSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionTintR');
            });
            diffusionTintRSlider.addEventListener('change', () => {
                diffusionTintRValLabel.textContent = parseFloat(diffusionTintRSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionTintR', true);
            });
        }
        if (diffusionTintGSlider) {
            diffusionTintGSlider.addEventListener('input', () => {
                diffusionTintGValLabel.textContent = parseFloat(diffusionTintGSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionTintG');
            });
            diffusionTintGSlider.addEventListener('change', () => {
                diffusionTintGValLabel.textContent = parseFloat(diffusionTintGSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionTintG', true);
            });
        }
        if (diffusionTintBSlider) {
            diffusionTintBSlider.addEventListener('input', () => {
                diffusionTintBValLabel.textContent = parseFloat(diffusionTintBSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionTintB');
            });
            diffusionTintBSlider.addEventListener('change', () => {
                diffusionTintBValLabel.textContent = parseFloat(diffusionTintBSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionTintB', true);
            });
        }

        // Diffusion spread slider event listeners
        if (diffusionSpreadSlider) {
            diffusionSpreadSlider.addEventListener('input', () => {
                diffusionSpreadValLabel.textContent = parseFloat(diffusionSpreadSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionSpread');
            });
            diffusionSpreadSlider.addEventListener('change', () => {
                diffusionSpreadValLabel.textContent = parseFloat(diffusionSpreadSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionSpread', true);
            });
        }

        // Diffusion gamma slider event listeners
        if (diffusionGammaSlider) {
            diffusionGammaSlider.addEventListener('input', () => {
                diffusionGammaValLabel.textContent = parseFloat(diffusionGammaSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionGamma');
            });
            diffusionGammaSlider.addEventListener('change', () => {
                diffusionGammaValLabel.textContent = parseFloat(diffusionGammaSlider.value).toFixed(2);
                invalidateDiffusionBuffer();
                triggerLiveFullRender('diffusionGamma', true);
            });
        }
        
        // Diffusion subtract toggle event listener
        if (diffusionSubtractToggle) {
            diffusionSubtractToggle.addEventListener('change', () => {
                invalidateDiffusionBuffer();
                render();
            });
        }

        // Diffusion subtract 02 toggle event listener
        if (diffusionSubtract2Toggle) {
            diffusionSubtract2Toggle.addEventListener('change', () => {
                invalidateDiffusionBuffer();
                render();
            });
        }

        // Diffusion Min RGB toggle event listener
        if (diffusionMinRgbToggle) {
            diffusionMinRgbToggle.addEventListener('change', () => {
                invalidateDiffusionBuffer();
                render();
            });
        }

        // Diffusion threshold preview
        async function renderDiffusionThresholdPreview() {
            try {
                if (!imageTexture) return;
                const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
                const fullResolution = [canvas.width, canvas.height];
                // Compute at 1K up to addGlowToBase using a temporary FBO set
                const DIFFUSION_TARGET_DIM = 1024;
                const maxDim = Math.max(canvas.width, canvas.height);
                const scale = Math.min(1.0, DIFFUSION_TARGET_DIM / maxDim);
                const previewW = Math.max(1, Math.floor(canvas.width * scale));
                const previewH = Math.max(1, Math.floor(canvas.height * scale));
                const previewRect = { x:0, y:0, w: previewW, h: previewH };

                const tempFBOs = {};
                fboNames.forEach(name => tempFBOs[name] = createFBO(previewW, previewH, supportsFloat && floatFBONames.has(name)));
                gl.viewport(0, 0, previewW, previewH);
                runRenderPipelineUpToDiffusion(fullRect, previewRect, tempFBOs, [previewW, previewH]);

                // Apply threshold gain first, then luma key and premultiply
                const gain = parseFloat((diffusionThresholdSlider && diffusionThresholdSlider.value) || '1') || 1;
                const tmpThresholdAdj = createFBO(previewW, previewH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tmpThresholdAdj.fbo);
                drawQuadWithRegions(progs.applyThresholdGain, { u_image: tempFBOs.addGlowToBase.texture, u_gain: gain, u_fullUVRect: [0,0,1,1] }, previewRect, previewRect, [previewW, previewH], [previewW, previewH]);

                const tmpPremul = createFBO(previewW, previewH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tmpPremul.fbo);
                drawQuadWithRegions(progs.lumaPremultiplyNoGain, { u_image: tmpThresholdAdj.texture, u_fullUVRect: [0,0,1,1] }, previewRect, previewRect, [previewW, previewH], [previewW, previewH]);

                // Blit to screen over black using premultiplied alpha blending
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.disable(gl.BLEND);
                drawQuadWithRegions(progs.solidColor, { u_color: [0,0,0] }, fullRect, fullRect, fullResolution, fullResolution);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                drawQuadWithRegions(progs.passthrough, { u_image: tmpPremul.texture }, previewRect, fullRect, [previewW, previewH], fullResolution);
                gl.disable(gl.BLEND);

                // Cleanup
                Object.values(tempFBOs).forEach(f => { if (f) { gl.deleteFramebuffer(f.fbo); gl.deleteTexture(f.texture); } });
                gl.deleteFramebuffer(tmpThresholdAdj.fbo); gl.deleteTexture(tmpThresholdAdj.texture);
                gl.deleteFramebuffer(tmpPremul.fbo); gl.deleteTexture(tmpPremul.texture);
            } catch(e) { console.warn('Threshold preview failed', e); }
        }

        if (diffusionThresholdSlider) {
            diffusionThresholdSlider.addEventListener('input', () => {
                if (diffusionThresholdValLabel) diffusionThresholdValLabel.textContent = parseFloat(diffusionThresholdSlider.value).toFixed(2);
                if (diffusionThresholdPreviewToggle && diffusionThresholdPreviewToggle.checked) {
                    thresholdPreviewActive = true;
                    suppressRenders = true;
                    renderDiffusionThresholdPreview();
                }
            });
            diffusionThresholdSlider.addEventListener('change', () => {
                if (diffusionThresholdValLabel) diffusionThresholdValLabel.textContent = parseFloat(diffusionThresholdSlider.value).toFixed(2);
                thresholdPreviewActive = false;
                suppressRenders = false;
                invalidateDiffusionBuffer();
                render();
            });
        }

        // Diffusion 02 threshold preview (min-key based), mirroring the main preview behavior
        async function renderDiffusionThreshold2Preview() {
            try {
                const scale = Math.min(1.0, 1024 / Math.max(canvas.width, canvas.height));
                const previewW = Math.max(1, Math.floor(canvas.width * scale));
                const previewH = Math.max(1, Math.floor(canvas.height * scale));
                const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
                const fullResolution = [canvas.width, canvas.height];
                const previewRect = { x: 0, y: 0, w: previewW, h: previewH };

                // Build pipeline up to addGlowToBase at preview res
                const tempFBOs = {};
                fboNames.forEach(name => tempFBOs[name] = createFBO(previewW, previewH, supportsFloat && floatFBONames.has(name)));
                gl.viewport(0, 0, previewW, previewH);
                runRenderPipelineUpToDiffusion(fullRect, previewRect, tempFBOs, [previewW, previewH]);

                // Apply threshold gain first, then create min-key and premultiply with min(r,g,b) as RGB
                const gain = parseFloat((diffusionThreshold2Slider && diffusionThreshold2Slider.value) || '1') || 1;
                const tmpThresholdAdj2 = createFBO(previewW, previewH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, tmpThresholdAdj2.fbo);
                drawQuadWithRegions(progs.applyThresholdGain, { u_image: tempFBOs.addGlowToBase.texture, u_gain: gain, u_fullUVRect: [0,0,1,1] }, previewRect, previewRect, [previewW, previewH], [previewW, previewH]);

                const thresholdGamma = parseFloat((thresholdGamma2Slider && thresholdGamma2Slider.value) || '1') || 1;
                const thresholdWhite = parseFloat((thresholdWhite2Slider && thresholdWhite2Slider.value) || '7.22') || 7.22;

                const keyFBO = createFBO(previewW, previewH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, keyFBO.fbo);
                drawQuadWithRegions(progs.minDesaturate, { u_image: tmpThresholdAdj2.texture, u_thresholdGamma: thresholdGamma, u_thresholdWhite: thresholdWhite }, previewRect, previewRect, [previewW, previewH], [previewW, previewH]);

                const useMinRgb = document.getElementById('diffusionMinRgbToggle') ? document.getElementById('diffusionMinRgbToggle').checked : true;
                const usePremultiply = diffusionPremultiplyToggle ? diffusionPremultiplyToggle.checked : true;
                const premulFBO = createFBO(previewW, previewH, true);
                gl.bindFramebuffer(gl.FRAMEBUFFER, premulFBO.fbo);
                drawQuadWithRegions(progs.conditionalRgbPremultiplyWithKey, { u_image: tmpThresholdAdj2.texture, u_key: keyFBO.texture, u_useMinRgb: useMinRgb, u_usePremultiply: usePremultiply, u_thresholdGamma: thresholdGamma, u_thresholdWhite: thresholdWhite, u_fullUVRect: [0,0,1,1] }, previewRect, previewRect, [previewW, previewH], [previewW, previewH]);

                // Show premultiplication result directly (for debugging)
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.disable(gl.BLEND);
                drawQuadWithRegions(progs.solidColor, { u_color: [0,0,0] }, fullRect, fullRect, fullResolution, fullResolution);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                drawQuadWithRegions(progs.passthrough, { u_image: premulFBO.texture }, previewRect, fullRect, [previewW, previewH], fullResolution);
                gl.disable(gl.BLEND);

                // Cleanup
                Object.values(tempFBOs).forEach(f => { if (f) { gl.deleteFramebuffer(f.fbo); gl.deleteTexture(f.texture); } });
                gl.deleteFramebuffer(tmpThresholdAdj2.fbo); gl.deleteTexture(tmpThresholdAdj2.texture);
                gl.deleteFramebuffer(keyFBO.fbo); gl.deleteTexture(keyFBO.texture);
                gl.deleteFramebuffer(premulFBO.fbo); gl.deleteTexture(premulFBO.texture);
            } catch(e) { console.warn('Threshold 02 preview failed', e); }
        }

        if (diffusionThreshold2Slider) {
            diffusionThreshold2Slider.addEventListener('input', () => {
                if (diffusionThreshold2ValLabel) diffusionThreshold2ValLabel.textContent = parseFloat(diffusionThreshold2Slider.value).toFixed(2);
                if (diffusionThresholdPreview2Toggle && diffusionThresholdPreview2Toggle.checked) {
                    thresholdPreviewActive = true;
                    suppressRenders = true;
                    renderDiffusionThreshold2Preview();
                }
            });
            diffusionThreshold2Slider.addEventListener('change', () => {
                if (diffusionThreshold2ValLabel) diffusionThreshold2ValLabel.textContent = parseFloat(diffusionThreshold2Slider.value).toFixed(2);
                thresholdPreviewActive = false;
                suppressRenders = false;
                invalidateDiffusionBuffer();
                render();
            });
        }

        // Add event listeners for new grain sliders
        if (grainReduceShadowsSlider) {
            grainReduceShadowsSlider.addEventListener('input', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainReduceShadows');
            });
            grainReduceShadowsSlider.addEventListener('change', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainReduceShadows', true);
            });
        }

        if (grainShadowSatSlider) {
            grainShadowSatSlider.addEventListener('input', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainShadowSat');
            });
            grainShadowSatSlider.addEventListener('change', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainShadowSat', true);
            });
        }

        if (grainReduceHighlightsSlider) {
            grainReduceHighlightsSlider.addEventListener('input', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainReduceHighlights');
            });
            grainReduceHighlightsSlider.addEventListener('change', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainReduceHighlights', true);
            });
        }

        if (grainHighlightSatSlider) {
            grainHighlightSatSlider.addEventListener('input', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainHighlightSat');
            });
            grainHighlightSatSlider.addEventListener('change', () => {
                updateSliderLabels();
                triggerLiveFullRender('grainHighlightSat', true);
            });
        }

        // Add event listeners for new threshold sliders
        if (thresholdGamma2Slider) {
            thresholdGamma2Slider.addEventListener('input', () => {
                if (thresholdGamma2ValLabel) thresholdGamma2ValLabel.textContent = parseFloat(thresholdGamma2Slider.value).toFixed(2);
                if (diffusionThresholdPreview2Toggle && diffusionThresholdPreview2Toggle.checked) {
                    thresholdPreviewActive = true;
                    suppressRenders = true;
                    renderDiffusionThreshold2Preview();
                }
            });
            thresholdGamma2Slider.addEventListener('change', () => {
                if (thresholdGamma2ValLabel) thresholdGamma2ValLabel.textContent = parseFloat(thresholdGamma2Slider.value).toFixed(2);
                thresholdPreviewActive = false;
                suppressRenders = false;
                invalidateDiffusionBuffer();
                render();
            });
        }

        if (thresholdWhite2Slider) {
            thresholdWhite2Slider.addEventListener('input', () => {
                if (thresholdWhite2ValLabel) thresholdWhite2ValLabel.textContent = parseFloat(thresholdWhite2Slider.value).toFixed(2);
                if (diffusionThresholdPreview2Toggle && diffusionThresholdPreview2Toggle.checked) {
                    thresholdPreviewActive = true;
                    suppressRenders = true;
                    renderDiffusionThreshold2Preview();
                }
            });
            thresholdWhite2Slider.addEventListener('change', () => {
                if (thresholdWhite2ValLabel) thresholdWhite2ValLabel.textContent = parseFloat(thresholdWhite2Slider.value).toFixed(2);
                thresholdPreviewActive = false;
                suppressRenders = false;
                invalidateDiffusionBuffer();
                render();
            });
        }

        // Add event listener for premultiply toggle
        if (diffusionPremultiplyToggle) {
            diffusionPremultiplyToggle.addEventListener('change', () => {
                invalidateDiffusionBuffer();
                if (imageTexture) render();
            });
        }

        // Add event listener for screen blend toggle
        if (halationScreenToggle) {
            halationScreenToggle.addEventListener('change', () => {
                if (imageTexture) render();
            });
        }

        // Chroma Ab slider listeners (pre-baked at load)
        const chromaSamplesSlider = document.getElementById('chromaSamples');
        const chromaBlurSlider = document.getElementById('chromaBlur');
        const chromaFalloffSlider = document.getElementById('chromaFalloff');
        const chromaToggle = document.getElementById('chromaToggle');
        const chromaSamplesValLabel = document.getElementById('chromaSamplesVal');
        const chromaBlurValLabel = document.getElementById('chromaBlurVal');
        const chromaFalloffValLabel = document.getElementById('chromaFalloffVal');
        let chromaPreviewActive = false;
        let chromaCommitTimer = null;
        function onChromaInput() {
            if (chromaSamplesValLabel && chromaSamplesSlider) chromaSamplesValLabel.textContent = (parseInt(chromaSamplesSlider.value, 10) || 0).toString();
            if (chromaBlurValLabel && chromaBlurSlider) chromaBlurValLabel.textContent = (parseFloat(chromaBlurSlider.value) || 0).toFixed(3);
            if (chromaFalloffValLabel && chromaFalloffSlider) chromaFalloffValLabel.textContent = (parseFloat(chromaFalloffSlider.value) || 0).toFixed(2);
            if (!rawImageTexture) return;
            chromaPreviewActive = true;
            suppressRenders = true; // prevent full pipeline from overwriting preview
            renderChromaPreview();
            if (chromaCommitTimer) clearTimeout(chromaCommitTimer);
            chromaCommitTimer = setTimeout(() => {
                // Keep previewing, but keep the pre-bake in sync for consistency
                rebuildChromaPrebake();
            }, 120);
        }
        function onChromaCommit() {
            if (chromaSamplesValLabel && chromaSamplesSlider) chromaSamplesValLabel.textContent = (parseInt(chromaSamplesSlider.value, 10) || 0).toString();
            if (chromaBlurValLabel && chromaBlurSlider) chromaBlurValLabel.textContent = (parseFloat(chromaBlurSlider.value) || 0).toFixed(3);
            if (chromaFalloffValLabel && chromaFalloffSlider) chromaFalloffValLabel.textContent = (parseFloat(chromaFalloffSlider.value) || 0).toFixed(2);
            chromaPreviewActive = false;
            if (chromaCommitTimer) { clearTimeout(chromaCommitTimer); chromaCommitTimer = null; }
            suppressRenders = false;
            rebuildChromaPrebake();
            render();
        }

        // Chroma Ab live preview while dragging sliders: bypass rest of pipeline
        function renderChromaPreview() {
            if (!rawImageTexture) return;
            const w = originalImageDimensions.w || canvas.width;
            const h = originalImageDimensions.h || canvas.height;
            const maxDim = Math.max(w, h);
            const scale = Math.min(1.0, 1024 / Math.max(canvas.width, canvas.height));
            const previewW = Math.max(1, Math.floor(canvas.width * scale));
            const previewH = Math.max(1, Math.floor(canvas.height * scale));
            const fullRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
            const previewRect = { x: 0, y: 0, w: previewW, h: previewH };

            // Always preview the CA effect regardless of toggle state
            const samples = (document.getElementById('chromaSamples') ? parseInt(document.getElementById('chromaSamples').value, 10) || 0 : 0);
            const blur = (document.getElementById('chromaBlur') ? parseFloat(document.getElementById('chromaBlur').value) || 0 : 0);
            const falloff = (document.getElementById('chromaFalloff') ? parseFloat(document.getElementById('chromaFalloff').value) || 1.0 : 1.0);

            const tmpPreview = createFBO(previewW, previewH, false);
            gl.bindFramebuffer(gl.FRAMEBUFFER, tmpPreview.fbo);
            gl.viewport(0, 0, previewW, previewH);
            drawQuadWithRegions(progs.chromaAb, {
                u_image: rawImageTexture,
                u_samplesF: samples,
                u_blur: blur,
                u_falloff: falloff,
                u_fullUVRect: [0, 0, w, h]
            }, {x:0,y:0,w:w,h:h}, previewRect, [w, h], [previewW, previewH]);

            // Blit to screen over black, centered
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            drawQuadWithRegions(progs.solidColor, { u_color: [0,0,0] }, fullRect, fullRect, [canvas.width, canvas.height], [canvas.width, canvas.height]);
            drawQuadWithRegions(progs.passthrough, { u_image: tmpPreview.texture }, previewRect, fullRect, [previewW, previewH], [canvas.width, canvas.height]);

            gl.deleteFramebuffer(tmpPreview.fbo);
            gl.deleteTexture(tmpPreview.texture);
        }
        // Input/change for drag/click; also use pointerdown to start a RAF loop for platforms that don't fire input continuously
        let chromaPreviewRAF = null;
        function startChromaRAF() {
            chromaPreviewActive = true;
            suppressRenders = true;
            if (!chromaPreviewRAF) {
                const step = () => {
                    if (!chromaPreviewActive) { chromaPreviewRAF = null; return; }
                    renderChromaPreview();
                    chromaPreviewRAF = requestAnimationFrame(step);
                };
                chromaPreviewRAF = requestAnimationFrame(step);
            }
        }
        function endChromaRAFCommit() {
            if (!chromaPreviewActive) return;
            chromaPreviewActive = false;
            suppressRenders = false;
            if (chromaPreviewRAF) { cancelAnimationFrame(chromaPreviewRAF); chromaPreviewRAF = null; }
            onChromaCommit();
        }
        function bindChromaEvents(el) {
            if (!el) return;
            el.addEventListener('input', onChromaInput);
            el.addEventListener('change', onChromaCommit);
            el.addEventListener('pointerdown', startChromaRAF);
            el.addEventListener('mousedown', startChromaRAF);
            el.addEventListener('touchstart', startChromaRAF, { passive: true });
        }
        bindChromaEvents(chromaSamplesSlider);
        bindChromaEvents(chromaBlurSlider);
        bindChromaEvents(chromaFalloffSlider);
        window.addEventListener('pointerup', endChromaRAFCommit);
        window.addEventListener('mouseup', endChromaRAFCommit);
        window.addEventListener('touchend', endChromaRAFCommit, { passive: true });
        if (chromaToggle) { chromaToggle.addEventListener('change', () => { rebuildChromaPrebake(); render(); }); }
        // Fallback: commit on pointer up if preview is active (covers cases where 'change' may not fire)
        window.addEventListener('mouseup', () => { if (chromaPreviewActive) onChromaCommit(); });
        window.addEventListener('touchend', () => { if (chromaPreviewActive) onChromaCommit(); }, { passive: true });






// REPLACE the existing shared image handling code in your index.html with this:

let lastCheckedTimestamp = 0;
let isProcessingSharedImage = false;

// Check for pending images when app starts
window.addEventListener('load', async () => {
    console.log('[WEB] App loaded, checking for shared images...');
    
    // Add a delay to ensure Capacitor is fully initialized
    setTimeout(() => {
        checkForSharedImage();
    }, 1000);
});

// Check UserDefaults for new shared image flag
async function checkForNewSharedImage() {
    if (typeof Capacitor === 'undefined' || !Capacitor.isNativePlatform()) return false;
    if (isProcessingSharedImage) return false;
    
    try {
        const { Preferences } = Capacitor.Plugins;
        
        // First check for batch import
        const batchResult = await checkForBatchImport();
        if (batchResult) return true;
        
        // Then check for single image import
        const fileNameResult = await Preferences.get({ key: 'newSharedImageFileName' });
        const timestampResult = await Preferences.get({ key: 'newSharedImageTimestamp' });
        
        const fileName = fileNameResult.value;
        const newTimestamp = parseFloat(timestampResult.value || '0');
        
        console.log('[WEB] Checking single image - fileName:', fileName, 'timestamp:', newTimestamp);
        
        // If Preferences are empty, try direct file system scan as fallback
        if (!fileName) {
            console.log('[WEB] No filename in Preferences, trying direct file scan...');
            return await checkDocumentsDirectly();
        }
        
        // Process if we have a filename and it's new
        if (fileName && newTimestamp > lastCheckedTimestamp) {
            console.log('[WEB] Found new shared image:', fileName, 'timestamp:', newTimestamp);
            isProcessingSharedImage = true;
            lastCheckedTimestamp = newTimestamp;
            
            // Clear the flags first to prevent re-processing
            await Preferences.remove({ key: 'newSharedImageFileName' });
            await Preferences.remove({ key: 'newSharedImageTimestamp' });
            
            // Load the shared file
            await loadSharedFile(fileName);
            
            isProcessingSharedImage = false;
            return true; // Successfully processed
        }
        
        return false; // Nothing to process
    } catch (error) {
        isProcessingSharedImage = false;
        console.error('[WEB] Error checking for shared image:', error);
        
        // Fallback: try direct file system check
        console.log('[WEB] Preferences failed, trying direct file scan...');
        return await checkDocumentsDirectly();
    }
}

// Check for batch import
async function checkForBatchImport() {
    if (typeof Capacitor === 'undefined' || !Capacitor.isNativePlatform()) return false;
    
    try {
        const { Preferences } = Capacitor.Plugins;

        const batchIdResult = await Preferences.get({ key: 'newSharedBatchId' });
        const batchCountResult = await Preferences.get({ key: 'newSharedBatchCount' });
        const batchFilesResult = await Preferences.get({ key: 'newSharedBatchFiles' });
        const batchTimestampResult = await Preferences.get({ key: 'newSharedBatchTimestamp' });

        const batchId = batchIdResult.value;
        const batchCount = parseInt(batchCountResult.value || '0');
        const batchFiles = batchFilesResult.value;
        const batchTimestamp = parseFloat(batchTimestampResult.value || '0');

        if (batchId && batchFiles && batchTimestamp > lastCheckedTimestamp) {
            console.log('[WEB] Found batch import:', batchCount, 'files, batchId:', batchId);
            isProcessingSharedImage = true;
            lastCheckedTimestamp = batchTimestamp;

            // Clear batch flags
            await Promise.all([
                Preferences.remove({ key: 'newSharedBatchId' }),
                Preferences.remove({ key: 'newSharedBatchCount' }),
                Preferences.remove({ key: 'newSharedBatchFiles' }),
                Preferences.remove({ key: 'newSharedBatchTimestamp' })
            ]);

            // Process batch
            await processBatchFromSharedFiles(batchFiles.split(','));
            isProcessingSharedImage = false;
            return true;
        }
        return false;
    } catch (error) {
        console.error('[WEB] Error checking for batch import:', error);
        return false;
    }
}

// Process batch files from shared import
async function processBatchFromSharedFiles(fileNames) {
    try {
        console.log('[WEB] Processing shared batch:', fileNames.length, 'files');
        
        const { Filesystem } = Capacitor.Plugins;
        const files = [];
        
        // Convert file names to File objects
        for (const fileName of fileNames) {
            try {
                const fileData = await Filesystem.readFile({
                    path: fileName,
                    directory: 'Documents'
                });
                
                // Convert base64 to blob
                const binaryString = atob(fileData.data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'image/png' });
                
                // Create a File object with the original name
                const file = new File([blob], fileName.replace(/^batch_[\d.]+_\d+\./, ''), { type: 'image/png' });
                files.push(file);
                
                // Clean up the shared file
                try {
                    await Filesystem.deleteFile({
                        path: fileName,
                        directory: 'Documents'
                    });
                } catch (deleteError) {
                    console.log('[WEB] Could not delete batch file (non-critical):', deleteError);
                }
            } catch (fileError) {
                console.error('[WEB] Error loading batch file:', fileName, fileError);
            }
        }
        
        if (files.length > 0) {
            console.log('[WEB] Starting batch processing of', files.length, 'shared images');
            
            // Show enhanced batch modal for shared images
            showBatchProcessModal(files);
        }
    } catch (error) {
        console.error('[WEB] Error processing batch from shared files:', error);
    }
}

// Fallback: directly scan Documents directory for new share_ files
async function checkDocumentsDirectly() {
    if (isProcessingSharedImage) return false;
    
    try {
        const { Filesystem } = Capacitor.Plugins;
        
        console.log('[WEB] Scanning Documents directory directly...');
        
        const files = await Filesystem.readdir({
            path: '',
            directory: 'Documents'
        });
        
        // Look for share_ and batch_ files
        const shareFiles = files.files?.filter(f => f.name.startsWith('share_')) || [];
        const batchFiles = files.files?.filter(f => f.name.startsWith('batch_')) || [];
        
        console.log('[WEB] Found', shareFiles.length, 'share files and', batchFiles.length, 'batch files in Documents');
        
        // Check for batch files first (they have priority)
        if (batchFiles.length > 0) {
            // Group batch files by batch ID
            const batchGroups = {};
            batchFiles.forEach(file => {
                const match = file.name.match(/^batch_(\d+\.\d+)_\d+\./);
                if (match) {
                    const batchId = match[1];
                    if (!batchGroups[batchId]) batchGroups[batchId] = [];
                    batchGroups[batchId].push(file.name);
                }
            });
            
            // Get the most recent batch
            const latestBatchId = Object.keys(batchGroups).sort((a, b) => parseFloat(b) - parseFloat(a))[0];
            const batchTimestamp = parseFloat(latestBatchId);
            
            if (batchTimestamp > lastCheckedTimestamp) {
                console.log('[WEB] Found new batch files:', batchGroups[latestBatchId].length, 'files');
                isProcessingSharedImage = true;
                lastCheckedTimestamp = batchTimestamp;
                
                await processBatchFromSharedFiles(batchGroups[latestBatchId]);
                isProcessingSharedImage = false;
                return true;
            }
        }
        
        // Then check for single share files
        if (shareFiles.length > 0) {
            // Get the most recent file by timestamp in filename
            const latestFile = shareFiles.sort((a, b) => {
                const aTime = parseFloat(a.name.match(/share_(\d+\.\d+)/)?.[1] || '0');
                const bTime = parseFloat(b.name.match(/share_(\d+\.\d+)/)?.[1] || '0');
                return bTime - aTime;
            })[0];
            
            const fileTimestamp = parseFloat(latestFile.name.match(/share_(\d+\.\d+)/)?.[1] || '0');
            
            // Only process if this file is newer than what we've seen
            if (fileTimestamp > lastCheckedTimestamp) {
                console.log('[WEB] Found new file via direct scan:', latestFile.name);
                isProcessingSharedImage = true;
                lastCheckedTimestamp = fileTimestamp;
                
                await loadSharedFile(latestFile.name);
                
                isProcessingSharedImage = false;
                return true;
            }
        }
        
        return false;
    } catch (error) {
        console.error('[WEB] Error in direct file scan:', error);
        isProcessingSharedImage = false;
        return false;
    }
}

// Function to check for shared images in Documents directory (startup check)
async function checkForSharedImage() {
    if (typeof Capacitor === 'undefined' || !Capacitor.isNativePlatform()) {
        console.log('[WEB] Not running on native platform');
        return;
    }
    
    try {
        const { Filesystem } = Capacitor.Plugins;
        
        console.log('[WEB] Checking Documents directory for shared files...');
        
        // Check Documents directory (where AppDelegate copies the files)
        const files = await Filesystem.readdir({
            path: '',
            directory: 'Documents'
        });
        
        console.log('[WEB] Files in Documents:', files.files?.length || 0, 'files');
        
        // Look for share_ prefixed files
        const shareFiles = files.files?.filter(f => f.name.startsWith('share_')) || [];
        console.log('[WEB] Found share files:', shareFiles.length);
        
        if (shareFiles.length > 0) {
            // Get the most recent file by timestamp in filename
            const latestFile = shareFiles.sort((a, b) => {
                const aTime = parseFloat(a.name.match(/share_(\d+\.\d+)/)?.[1] || '0');
                const bTime = parseFloat(b.name.match(/share_(\d+\.\d+)/)?.[1] || '0');
                return bTime - aTime;
            })[0];
            
            console.log('[WEB] Loading latest shared file:', latestFile.name);
            await loadSharedFile(latestFile.name);
        }
    } catch (error) {
        console.error('[WEB] Error checking for shared image:', error);
    }
}

// Load shared file from Documents directory
async function loadSharedFile(fileName) {
    if (typeof Capacitor === 'undefined' || !Capacitor.isNativePlatform()) {
        console.log('[WEB] Not on native platform, cannot load shared file');
        return;
    }
    
    try {
        console.log(`[WEB] Attempting to load shared file: ${fileName}`);
        const { Filesystem } = Capacitor.Plugins;
        
        // Read from Documents directory (where AppDelegate copies the files)
        const fileData = await Filesystem.readFile({
            path: fileName,
            directory: 'Documents'
        });
        
        console.log('[WEB] Successfully read file data');
        
        // Convert base64 to blob
        const binaryString = atob(fileData.data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        const blob = new Blob([bytes], { type: 'image/png' });
        
        console.log('[WEB] Created blob from file data, size:', blob.size);
        
        // Load the image into the app
        if (typeof originalFileBlob !== 'undefined' && typeof loadImageAndResize === 'function') {
            originalFileBlob = blob;
            if (typeof suppressImageFade !== 'undefined') {
                suppressImageFade = false;
            }
            loadImageAndResize(originalFileBlob);
            console.log('[WEB] Image loaded into editor successfully');
        } else {
            console.error('[WEB] Required image loading functions not available');
        }
        
        // Clean up: delete the file after successful loading
        try {
            await Filesystem.deleteFile({
                path: fileName,
                directory: 'Documents'
            });
            console.log('[WEB] Cleaned up shared file');
        } catch (deleteError) {
            console.log('[WEB] Could not delete shared file (non-critical):', deleteError);
        }
        
    } catch (error) {
        console.error('[WEB] Error loading shared file:', error);
        alert('Could not load the shared image. Please try again.');
    }
}

// Handle app state changes
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log('[WEB] App went to background');
    } else {
        // App became visible again, check for new images
        console.log('[WEB] App became visible, checking for new images...');
        setTimeout(() => {
            checkForNewSharedImage();
        }, 100);
    }
});

// Listen for Capacitor app events
if (typeof Capacitor !== 'undefined' && Capacitor.Plugins && Capacitor.Plugins.App) {
    // Handle URL opens - this now happens AFTER AppDelegate has processed the file
    Capacitor.Plugins.App.addListener('appUrlOpen', async (data) => {
        console.log('[WEB] App opened with URL:', data.url);
        
        // Parse the URL to check if it's an import
        if (data.url && data.url.includes('import?file=')) {
            console.log('[WEB] Import URL detected, using direct file scan approach...');
            
            // Wait a moment for AppDelegate to finish file operations
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Use direct file scanning since Preferences might not work
            console.log('[WEB] Checking Documents directory for new files...');
            const processed = await checkDocumentsDirectly();
            
            if (!processed) {
                console.log('[WEB] No new files found via direct scan, trying Preferences...');
                // Fallback to Preferences check
                await checkForNewSharedImage();
            }
        }
    });
    
    // Handle app state changes
    Capacitor.Plugins.App.addListener('appStateChange', ({ isActive }) => {
        console.log('[WEB] App state changed, active:', isActive);
        if (isActive) {
            // When app becomes active, check for new images (event-driven only)
        setTimeout(async () => {
                // Try direct scan first (more reliable)
                const directProcessed = await checkDocumentsDirectly();
                
                // If nothing found, try Preferences
                if (!directProcessed) {
            await checkForNewSharedImage();
                }
            }, 100); // Give AppDelegate time to process
        }
    });
}






    })();
</script>




</body>
</html>
